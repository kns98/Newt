/*
 * File generated by SourceCombiner.exe using 76 source files.
 * Created On: 7/29/2022 11:27:09 PM
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Windows.Forms;
using Grimoire;
using CS = Grimoire.CSharpUtility;

//*** SourceCombiner -> original file AssemblyInfo.cs ***
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]

//*** SourceCombiner -> original file Attributes.cs ***

//*** SourceCombiner -> original file Cfg.cs ***

//*** SourceCombiner -> original file Cfg.CSharpCodeGenerator.cs ***
namespace Grimoire
{
    internal partial class Cfg
    {
        private static bool _IsValidIdentifier(string identifier)
        {
            if (string.IsNullOrEmpty(identifier)) return false;
            if (!char.IsLetter(identifier[0]) && '_' != identifier[0])
                return false;
            for (var i = 1; i < identifier.Length; i++)
            {
                var ch = identifier[i];
                if (!char.IsLetterOrDigit(ch) && '_' != ch && '-' != ch)
                    return false;
            }

            return true;
        }

        private static string _GetUniqueName(ICollection<string> names, string name)
        {
            var i = 2;
            var s = name;
            while (names.Contains(s))
            {
                s = string.Concat(name, i.ToString());
                ++i;
            }

            return s;
        }

        public void WriteCSharpSymbolConstantsTo(TextWriter writer, string modifiers)
        {
            if (null == modifiers)
                modifiers = "";
            var names = new HashSet<string>();
            writer.WriteLine(string.Concat("\t", modifiers, " const int EOS=", GetSymbolId("#EOS").ToString(), ";"));
            names.Add("EOS");
            writer.WriteLine(string.Concat("\t", modifiers, " const int ERROR=", GetSymbolId("#ERROR").ToString(),
                ";"));
            names.Add("ERROR");
            foreach (var sym in _EnumSymbols())
            {
                IDictionary<string, object> d;
                object o;
                if (AttributeSets.TryGetValue(sym, out d) && d.TryGetValue("hidden", out o) && o is bool && (bool)o)
                    continue;
                if (AttributeSets.TryGetValue(sym, out d) && d.TryGetValue("collapse", out o) && o is bool && (bool)o)
                    continue;
                var sid = Convert.ToString(sym);
                if (_IsValidIdentifier(sid))
                {
                    string s;
                    if (!string.IsNullOrEmpty(modifiers))
                        s = string.Concat("\t", modifiers, " const int ");
                    else
                        s = string.Concat("\t", modifiers, "const int ");
                    var id = GetSymbolId(sym);
                    s = string.Concat(s, CS.CreateEscapedIdentifier(sid.Replace('-', '_')), " = ");
                    s = _GetUniqueName(names, s);
                    names.Add(s);
                    s = string.Concat(s, id.ToString(), ";");
                    writer.WriteLine(s);
                }
            }
        }

        public void WriteCSharpLL1ParseTableCreateExpressionTo(TextWriter writer,
            (int Left, int[] Right)[][] parseTable = null)
        {
            if (null == parseTable)
                parseTable = ToLL1ParseTable();
            var ntc = _EnumNonTerminals().Count();
            writer.WriteLine("new (int Left, int[] Right)[][] {");
            for (var i = 0; i < ntc; ++i)
            {
                writer.Write("\t");
                if (0 != i) writer.Write(",");
                var d = parseTable[i];
                writer.WriteLine("new (int Left, int[] Right)[] {");
                var j = 0;
                foreach (var t in _EnumTerminals())
                {
                    if (Equals(t, "#ERROR"))
                        continue;
                    writer.Write("\t\t");
                    if (0 != j) writer.Write(",");
                    (int Left, int[] Right) ir;
                    if (null != (ir = d[j]).Right)
                    {
                        writer.Write("(");
                        CS.WriteCSharpLiteralTo(writer, ir.Left);
                        writer.Write(", ");
                        CS.WriteCSharpLiteralTo(writer, ir.Right);
                        writer.WriteLine(")");
                    }
                    else
                    {
                        writer.WriteLine("(-1,null)");
                    }

                    ++j;
                }

                writer.WriteLine("\t\t}");
            }

            writer.Write("}");
        }

        public void WriteCSharpTableDrivenLL1ParserClassTo(TextWriter writer, string name, string modifiers = null,
            FA lexer = null, (int Left, int[] Right)[][] parseTable = null)
        {
            if (string.IsNullOrEmpty(name))
                name = "Parser";
            if (!string.IsNullOrEmpty(modifiers))
                writer.Write(string.Concat(modifiers, " "));
            writer.Write(string.Concat("partial class ", name, " : Grimoire.TableDrivenLL1Parser"));
            writer.WriteLine(" {");
            writer.WriteLine(string.Concat("\tpublic ", name,
                "(Grimoire.ParseContext parseContext=null) : base(_ParseTable,_StartingConfiguration,_LexTable,_Symbols,_SubstitutionsAndHiddenTerminals,_BlockEnds,_CollapsedNonTerminals,_Types,parseContext) { }"));
            WriteCSharpSymbolConstantsTo(writer, "public");
            writer.Write("\tstatic readonly string[] _Symbols = {");
            var delim = "";
            foreach (var sym in _EnumSymbols())
            {
                writer.Write(delim);
                CS.WriteCSharpLiteralTo(writer, sym);
                delim = ", ";
            }

            writer.WriteLine(" };");
            writer.Write("\tstatic readonly (int Left, int[] Right)[][] _ParseTable = ");
            WriteCSharpLL1ParseTableCreateExpressionTo(writer, parseTable);
            writer.WriteLine(";");
            writer.WriteLine();
            writer.Write("\tstatic readonly int[] _SubstitutionsAndHiddenTerminals = new int[] { ");
            delim = "";
            foreach (var sym in _EnumSymbols())
            {
                IDictionary<string, object> attrs;
                if (AttributeSets.TryGetValue(sym, out attrs))
                {
                    if ((bool)attrs.TryGetValue("hidden", false))
                    {
                        writer.Write("-2");
                    }
                    else
                    {
                        var sub = attrs.TryGetValue("substitute");
                        if (null != sub)
                            writer.Write(GetSymbolId(sub as string));
                        else
                            writer.Write(GetSymbolId(sym));
                    }
                }
                else
                {
                    writer.Write(GetSymbolId(sym));
                }

                writer.Write(", ");
            }

            writer.WriteLine("-1 };");
            writer.Write(
                "\tstatic readonly (int SymbolId,bool IsNonTerminal,int NonTerminalCount) _StartingConfiguration = (");
            var ss = StartSymbol;
            var startId = GetSymbolId(ss);
            var isNonTerminal = IsNonTerminal(ss);
            writer.Write(string.Concat(startId, ", "));
            CS.WriteCSharpLiteralTo(writer, isNonTerminal);
            writer.Write(", ");
            CS.WriteCSharpLiteralTo(writer, _EnumNonTerminals().Count());
            writer.WriteLine(");");
            writer.WriteLine("\tstatic readonly string[] _BlockEnds = new string[] { ");
            delim = "\t";
            foreach (var sym in _EnumSymbols())
            {
                writer.Write(delim);
                IDictionary<string, object> attrs;
                if (AttributeSets.TryGetValue(sym, out attrs))
                {
                    var be = attrs.TryGetValue("blockEnd") as string;
                    CS.WriteCSharpLiteralTo(writer, be);
                    writer.WriteLine();
                }
                else
                {
                    writer.WriteLine("null");
                }

                delim = "\t,";
            }

            writer.WriteLine("};");
            writer.WriteLine("\tstatic readonly System.Type[] _Types = new System.Type[] { ");
            delim = "\t";
            foreach (var sym in _EnumSymbols())
            {
                writer.Write(delim);
                IDictionary<string, object> attrs;
                if (AttributeSets.TryGetValue(sym, out attrs))
                {
                    object o;
                    if (attrs.TryGetValue("type", out o) && !string.IsNullOrEmpty(o as string) && !IsNonTerminal(sym))
                    {
                        var id = GetSymbolId(sym);
                        Type t = null;
                        var s = o as string;
                        if (!string.IsNullOrEmpty(s))
                            t = ParserUtility.ResolveType(s);
                        else
                            t = o as Type;
                        if (null == t)
                            throw new InvalidOperationException(string.Concat("Invalid type \"", o, "\"."));
                        writer.Write("typeof(");
                        writer.Write(t.FullName);
                        writer.WriteLine(")");
                    }
                    else
                    {
                        writer.Write("null");
                    }

                    writer.WriteLine();
                }
                else
                {
                    writer.WriteLine("null");
                }

                delim = "\t,";
            }

            writer.WriteLine("};");
            writer.WriteLine("\tstatic readonly int[] _CollapsedNonTerminals = new int[] { ");
            delim = "";
            foreach (var sym in _EnumSymbols())
            {
                writer.Write(delim);
                IDictionary<string, object> attrs;
                if (AttributeSets.TryGetValue(sym, out attrs))
                {
                    object be;
                    if (attrs.TryGetValue("collapse", out be) && be is bool && (bool)be)
                        writer.Write(-3);
                    else
                        writer.Write(-1);
                }
                else
                {
                    writer.Write("-1");
                }

                delim = ",";
            }

            writer.WriteLine("};");
            if (null != lexer)
            {
                writer.Write(
                    "\tstatic readonly (int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] _LexTable = ");
                FA.WriteCSharpDfaTable2CreationExpressionTo(writer, lexer.ToDfaTable2<int>());
                writer.WriteLine(";");
            }

            writer.WriteLine("}");
        }
    }
}

//*** SourceCombiner -> original file CfgException.cs ***

//*** SourceCombiner -> original file CfgMessage.cs ***
namespace Grimoire
{
}

//*** SourceCombiner -> original file CfgRule.cs ***

//*** SourceCombiner -> original file CollectionUtility.cs ***

//*** SourceCombiner -> original file CSharpUtility.cs ***

//*** SourceCombiner -> original file EbnfBinaryExpression.cs ***

//*** SourceCombiner -> original file EbnfClassifier.cs ***

//*** SourceCombiner -> original file EbnfClassifierClassificationDefinition.cs ***

//*** SourceCombiner -> original file EbnfClassifierFormat.cs ***

//*** SourceCombiner -> original file EbnfClassifierProvider.cs ***

//*** SourceCombiner -> original file EbnfConcatExpression.cs ***

//*** SourceCombiner -> original file EbnfDocument.cs ***
//#define PARSER

//*** SourceCombiner -> original file EbnfException.cs ***

//*** SourceCombiner -> original file EbnfExpression.cs ***

//*** SourceCombiner -> original file EbnfLiteralExpression.cs ***

//*** SourceCombiner -> original file EbnfMessage.cs ***
namespace Grimoire
{
}

//*** SourceCombiner -> original file EbnfOptionalExpression.cs ***

//*** SourceCombiner -> original file EbnfOrExpression.cs ***
//*** SourceCombiner -> original file EbnfParser.cs ***
#line 1 "C:\dev\Newt\HighlighterDemo\Ebnf.ebnf"
// Generator Message: Removing rule implicitlist -> production implicitlist because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist -> production because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist -> production implicitlist` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> implicitlist to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> to resolve first-first conflict.
// Generator Message: Removing rule production -> identifier lt attributes gt eq expressions semi because it is part of a first-first conflict.
// Generator Message: Removing rule production -> identifier eq expressions semi because it is part of a first-first conflict.
// Generator Message: Adding rule production -> identifier production` to resolve first-first conflict.
// Generator Message: Adding rule production` -> lt attributes gt eq expressions semi to resolve first-first conflict.
// Generator Message: Adding rule production` -> eq expressions semi to resolve first-first conflict.
// Generator Message: Removing rule expressions -> expression or expressions because it is part of a first-first conflict.
// Generator Message: Removing rule expressions -> expression because it is part of a first-first conflict.
// Generator Message: Adding rule expressions -> expression expressions` to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> or expressions to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol implicitlist2 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist2 -> symbol implicitlist2` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> implicitlist2 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute implicitlist3 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist3 -> comma attribute implicitlist3` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> implicitlist3 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> to resolve first-first conflict.
// Generator Message: Removing rule attribute -> identifier eq attrvalue because it is part of a first-first conflict.
// Generator Message: Removing rule attribute -> identifier because it is part of a first-first conflict.
// Generator Message: Adding rule attribute -> identifier attribute` to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> eq attrvalue to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> to resolve first-first conflict.
//*** SourceCombiner -> original file EbnfParser.cs ***
#line 1 "C:\dev\Newt\HighlighterDemo\Ebnf.ebnf"
// Generator Message: Removing rule implicitlist -> production implicitlist because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist -> production because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist -> production implicitlist` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> implicitlist to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> to resolve first-first conflict.
// Generator Message: Removing rule production -> identifier lt attributes gt eq expressions semi because it is part of a first-first conflict.
// Generator Message: Removing rule production -> identifier eq expressions semi because it is part of a first-first conflict.
// Generator Message: Adding rule production -> identifier production` to resolve first-first conflict.
// Generator Message: Adding rule production` -> lt attributes gt eq expressions semi to resolve first-first conflict.
// Generator Message: Adding rule production` -> eq expressions semi to resolve first-first conflict.
// Generator Message: Removing rule expressions -> expression or expressions because it is part of a first-first conflict.
// Generator Message: Removing rule expressions -> expression because it is part of a first-first conflict.
// Generator Message: Adding rule expressions -> expression expressions` to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> or expressions to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol implicitlist2 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist2 -> symbol implicitlist2` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> implicitlist2 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute implicitlist3 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist3 -> comma attribute implicitlist3` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> implicitlist3 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> to resolve first-first conflict.
// Generator Message: Removing rule attribute -> identifier eq attrvalue because it is part of a first-first conflict.
// Generator Message: Removing rule attribute -> identifier because it is part of a first-first conflict.
// Generator Message: Adding rule attribute -> identifier attribute` to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> eq attrvalue to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> to resolve first-first conflict.
namespace Grimoire
{
}
//*** SourceCombiner -> original file EbnfParser.cs ***
#line 1 "C:\dev\Newt\Perf\ebnf.ebnf"
// Generator Message: Removing rule implicitlist -> production implicitlist because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist -> production because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist -> production implicitlist` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> implicitlist to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> to resolve first-first conflict.
// Generator Message: Removing rule production -> identifier lt attributes gt eq expressions semi because it is part of a first-first conflict.
// Generator Message: Removing rule production -> identifier eq expressions semi because it is part of a first-first conflict.
// Generator Message: Adding rule production -> identifier production` to resolve first-first conflict.
// Generator Message: Adding rule production` -> lt attributes gt eq expressions semi to resolve first-first conflict.
// Generator Message: Adding rule production` -> eq expressions semi to resolve first-first conflict.
// Generator Message: Removing rule expressions -> expression or expressions because it is part of a first-first conflict.
// Generator Message: Removing rule expressions -> expression because it is part of a first-first conflict.
// Generator Message: Adding rule expressions -> expression expressions` to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> or expressions to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol implicitlist2 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist2 -> symbol implicitlist2` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> implicitlist2 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute implicitlist3 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist3 -> comma attribute implicitlist3` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> implicitlist3 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> to resolve first-first conflict.
// Generator Message: Removing rule attribute -> identifier eq attrvalue because it is part of a first-first conflict.
// Generator Message: Removing rule attribute -> identifier because it is part of a first-first conflict.
// Generator Message: Adding rule attribute -> identifier attribute` to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> eq attrvalue to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> to resolve first-first conflict.
//*** SourceCombiner -> original file EbnfProduction.cs ***

//*** SourceCombiner -> original file EbnfRefExpression.cs ***

//*** SourceCombiner -> original file EbnfRegexExpression.cs ***

//*** SourceCombiner -> original file EbnfRepeatExpression.cs ***

//*** SourceCombiner -> original file EbnfUnaryExpression.cs ***
//*** SourceCombiner -> original file Eval.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Eval.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file ExprParser.cs ***
#line 1 "C:\dev\Newt\Eval\Expr.ebnf"
// Generator Message: Removing rule expr -> expr add term because it is directly left recursive.
// Generator Message: Adding rule expr` -> add term expr` to replace rule expr -> expr add term
// Generator Message: Adding rule expr` -> to replace rule expr -> expr add term
// Generator Message: Removing rule term -> term mul factor because it is directly left recursive.
// Generator Message: Adding rule term` -> mul factor term` to replace rule term -> term mul factor
// Generator Message: Adding rule term` -> to replace rule term -> term mul factor

//*** SourceCombiner -> original file FA.cs ***
// by codewitch honey crisis
// article https://www.codeproject.com/Articles/1280690/A-Regular-Expression-Engine-in-Csharp
// CODEDOM option - Include System.CodeDom code generation support
// comment the below to disable CodeDom support 
// if enabled under .NET Core this requires the 
// System.CodeDom nuget package 
//#define CODEDOM

//*** SourceCombiner -> original file FA2.cs ***
// FA w/ Error recovery
namespace Grimoire
{
    internal partial class FA
    {
        public static void WriteCSharpDfaTable2CreationExpressionTo<TAccept>(TextWriter writer,
            (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[]
                PossibleAccepts)[] dfaTable)
        {
            var tuple = string.Concat("(", typeof(TAccept).FullName,
                " Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, ",
                typeof(TAccept).FullName, "[] PossibleAccepts)");
            writer.WriteLine(string.Concat("new ", tuple, "[] {"));
            for (var i = 0; i < dfaTable.Length; i++)
            {
                var dfaEntry = dfaTable[i];
                writer.Write("\t");
                if (0 != i) writer.Write(",");
                writer.WriteLine(string.Concat("(", dfaEntry.Accept,
                    ", new ((char First, char Last)[] Ranges, int Destination)[] {"));
                for (var j = 0; j < dfaEntry.Transitions.Length; j++)
                {
                    var trn = dfaEntry.Transitions[j];
                    writer.Write("\t\t");
                    if (0 != j) writer.Write(",");
                    writer.WriteLine("(new (char First,char Last)[] {");
                    for (var k = 0; k < trn.Ranges.Length; k++)
                    {
                        var rng = trn.Ranges[k];
                        writer.Write("\t\t\t");
                        if (0 != k) writer.Write(",");
                        writer.Write("((char)");
                        // spitting chars here breaks unicode so we use ints
                        // WriteCSharpCharTo doesn't support unicode yet.
                        CSharpUtility.WriteCSharpLiteralTo(writer, (int)rng.First);
                        writer.Write(",(char)");
                        CSharpUtility.WriteCSharpLiteralTo(writer, (int)rng.Last);
                        writer.WriteLine(")");
                    }

                    writer.Write("}");
                    writer.Write(string.Concat(",", trn.Destination));
                    writer.Write(")");
                }

                writer.Write("}, new int[] ");
                writer.Write(CollectionUtility.ToString(dfaEntry.PossibleAccepts));
                writer.WriteLine(")");
            }

            writer.WriteLine("}");
        }

        public static (TAccept Accept, string Value, (int First, int Last)[] ExpectingRanges, TAccept[] ExpectingSymbols
            ) Lex2<TAccept>(
                (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[]
                    PossibleAccepts)[] dfaTable,
                TAccept errorSymbol,
                ParseContext pc,
                StringBuilder sb = null)
        {
            if (null == sb)
                sb = new StringBuilder();
            else
                sb.Clear();
            pc.EnsureStarted();
            var state = 0;
            var dfaEntry = dfaTable[state];
            object acc = dfaEntry.Accept;
            if (-1 == pc.Current)
            {
                if (null == acc)
                    return _DoRecoveryDfat(
                        dfaTable,
                        dfaEntry,
                        errorSymbol,
                        pc,
                        sb,
                        dfaEntry.Transitions);
                if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) ||
                    typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
                    if (-1L == Convert.ToInt64(dfaEntry.Accept))
                        return _DoRecoveryDfat(
                            dfaTable,
                            dfaEntry,
                            errorSymbol,
                            pc,
                            sb,
                            dfaEntry.Transitions);
                return (dfaEntry.Accept, sb.ToString(), null, null);
            }

            while (true)
            {
                var ns = _GetDfatTransition(dfaEntry.Transitions, (char)pc.Current);
                if (-1 == ns)
                {
                    if (null == dfaEntry.Accept)
                        return _DoRecoveryDfat(
                            dfaTable,
                            dfaEntry,
                            errorSymbol,
                            pc,
                            sb,
                            dfaEntry.Transitions);
                    if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) ||
                        typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
                        if (-1L == Convert.ToInt64(dfaEntry.Accept))
                            return _DoRecoveryDfat(
                                dfaTable,
                                dfaEntry,
                                errorSymbol,
                                pc,
                                sb,
                                dfaEntry.Transitions);
                    return (dfaEntry.Accept, sb.ToString(), null, null);
                }

                state = ns;
                dfaEntry = dfaTable[state];
                if (-1 != pc.Current)
                    sb.Append((char)pc.Current);
                if (-1 == pc.Advance())
                {
                    if (null == dfaEntry.Accept)
                        return _DoRecoveryDfat(
                            dfaTable,
                            dfaEntry,
                            errorSymbol,
                            pc,
                            sb,
                            dfaEntry.Transitions);
                    if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) ||
                        typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
                        if (-1L == Convert.ToInt64(dfaEntry.Accept))
                            return _DoRecoveryDfat(
                                dfaTable,
                                dfaEntry,
                                errorSymbol,
                                pc,
                                sb,
                                dfaEntry.Transitions);
                    return (dfaEntry.Accept, sb.ToString(), null, null);
                }
            }
        }

        private static (TAccept Accept, string Value, (int First, int Last)[] ExpectingRanges, TAccept[]
            ExpectingSymbols) _DoRecoveryDfat<TAccept>(
                (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[]
                    PossibleAccepts)[] dfaTable,
                (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[]
                    PossibleAccepts) dfaEntry,
                TAccept errorSymbol,
                ParseContext pc, StringBuilder sb, ((char First, char Last)[] Ranges, int Destination)[] trns)
        {
            var ranges = new List<(int First, int Last)>();
            for (var i = 0; i < dfaEntry.Transitions.Length; i++)
            {
                var trn = dfaEntry.Transitions[i];
                for (var j = 0; j < trn.Ranges.Length; j++)
                {
                    var range = trn.Ranges[j];
                    ranges.Add((range.First, range.Last));
                }
            }

            while (true)
            {
                if (-1 == pc.Current)
                    break;
                sb.Append((char)pc.Current);
                if (-1 != pc.Advance())
                {
                    var dt = _GetDfatTransition(dfaTable[0].Transitions, (char)pc.Current);
                    if (-1 != dt)
                        break;
                }
            }

            return (errorSymbol, sb.ToString(), ranges.ToArray(), dfaEntry.PossibleAccepts);
        }

        private static int _GetDfatTransition(((char First, char Last)[] Ranges, int Destination)[] trns, char ch)
        {
            for (var i = 0; i < trns.Length; ++i)
            {
                var trn = trns[i];
                for (var j = 0; j < trn.Ranges.Length; ++j)
                {
                    var rg = trn.Ranges[j];
                    if (ch >= rg.First && ch <= rg.Last) return trn.Destination;
                }
            }

            return -1; // no state
        }

        public (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[]
            PossibleAccepts)[] ToDfaTable2<TAccept>()
        {
            var fa = this;
            if (!fa.IsDfa)
                fa = fa.ToDfa();
            var closure = fa.FillClosure();
            var cc = closure.Count;
            var result =
                new (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[]
                    PossibleAccepts)[cc];
            for (var i = 0; i < result.Length; i++)
            {
                var cfa = closure[i];
                var possibleAccepts = cfa.AcceptingSymbols.Cast<TAccept>().ToArray();
                var tc = ((IDictionary<FA, ICollection<char>>)cfa.Transitions).Count;
                var transitions = new ((char First, char Last)[] Ranges, int Destination)[tc];
                var j = 0;
                foreach (var trns in (IDictionary<FA, ICollection<char>>)cfa.Transitions)
                {
                    var dranges = _GetRanges(trns.Value).ToArray();
                    var ranges = new (char First, char Last)[dranges.Length];
                    for (var k = 0; k < dranges.Length; k++)
                    {
                        var range = dranges[k];
                        ranges[k] = (range.Key, range.Value);
                    }

                    transitions[j] = (ranges, closure.IndexOf(trns.Key));
                    ++j;
                }

                object acc;
                if (null == cfa.AcceptingSymbol && (typeof(TAccept) == typeof(int) ||
                                                    typeof(TAccept) == typeof(short) ||
                                                    typeof(TAccept) == typeof(long) ||
                                                    typeof(TAccept) == typeof(sbyte)))
                    acc = (TAccept)Convert.ChangeType(-1, typeof(TAccept));
                else
                    acc = cfa.AcceptingSymbol;
                result[i] = ((TAccept)Convert.ChangeType(acc, typeof(TAccept)), transitions, possibleAccepts);
            }

            return result;
        }
    }
}

//*** SourceCombiner -> original file GeneralSettings.Designer.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

//*** SourceCombiner -> original file ISymbolResolver.cs ***

//*** SourceCombiner -> original file ListDictionary.cs ***

//*** SourceCombiner -> original file LLParser.cs ***
namespace Grimoire
{
}
//*** SourceCombiner -> original file Main.cs ***
// if you can't get the thing to build because it can't 
// find EbnfParser, comment this out. Do the build.
// make sure EbnfParser.cs is in your project (it will
// have been generated). Then uncomment this and recompile

//*** SourceCombiner -> original file Main.Designer.cs ***
namespace HighlighterDemo
{
    partial class Main
    {
        /// <summary>
        ///     Required designer variable.
        /// </summary>
        private readonly IContainer components = null;

        private RichTextBox EditBox;

        /// <summary>
        ///     Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && components != null) components.Dispose();
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///     Required method for Designer support - do not modify
        ///     the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.EditBox = new System.Windows.Forms.RichTextBox();
            this.SuspendLayout();
            // 
            // EditBox
            // 
            this.EditBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.EditBox.DetectUrls = false;
            this.EditBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.EditBox.Location = new System.Drawing.Point(0, 0);
            this.EditBox.Name = "EditBox";
            this.EditBox.ShowSelectionMargin = true;
            this.EditBox.Size = new System.Drawing.Size(800, 450);
            this.EditBox.TabIndex = 0;
            this.EditBox.Text = "";
            this.EditBox.WordWrap = false;
            this.EditBox.TextChanged += new System.EventHandler(this.Main_TextChanged);
            // 
            // Main
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.EditBox);
            this.Name = "Main";
            this.Text = "EBNF Syntax Highlighter (Ctrl-V Paste)";
            this.ResumeLayout(false);
        }

        #endregion
    }
}
//*** SourceCombiner -> original file Newt.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Newt.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtLib.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtLib.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtLL1.cs ***
#pragma warning disable VSTHRD010
#pragma warning restore VSTHRD010
//*** SourceCombiner -> original file NewtRT.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtRT.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtVS.cs ***

//*** SourceCombiner -> original file OrderedCollectionEqualityComparer.cs ***

//*** SourceCombiner -> original file ParseContext.cs ***
namespace Grimoire
{
    #region ExpectingException

    #endregion ExpectingException

    #region ParseContext

    #endregion ParseContext
}

//*** SourceCombiner -> original file ParseNode.cs ***

//*** SourceCombiner -> original file ParserUtility.cs ***
//*** SourceCombiner -> original file Perf.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Perf.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Program.cs ***
//#define REGEN

//*** SourceCombiner -> original file Program.cs ***
namespace HighlighterDemo
{
    internal static class Program
    {
        /// <summary>
        ///     The main entry point for the application.
        /// </summary>
        [STAThread]
        private static void _Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Main());
        }
    }
}

//*** SourceCombiner -> original file Program.cs ***
namespace Newt
{
    internal class Program
    {
        private static int _Main(string[] args)
        {
            var mode = 0;
            string infile = null;
            string file2 = null; // sometimes outfile, sometimes input document
            var al = -1;
            var ns = "";
            for (var i = 0; i < args.Length; i++)
            {
                string s = null;
                if (args[i].StartsWith("/"))
                {
                    s = args[i].Substring(1);
                    if (0 > al)
                        al = i;
                }
                else if (args[i].StartsWith("--"))
                {
                    s = args[i].Substring(2);
                    if (0 > al)
                        al = i;
                }

                if (null != s)
                    switch (s.ToLowerInvariant())
                    {
                        case "namespace":
                            ++i; // steal the next value
                            if (i < args.Length)
                                ns = args[i];
                            break;
                        case "parse":
                            mode = 1;
                            break;
                    }
            }

            if (0 > al) al = args.Length;
            switch (al)
            {
                case 0:
                    break;
                case 2:
                    file2 = args[1];
                    goto case 1;
                case 1:
                    infile = args[0];
                    break;
                default:
                    PrintUsage();
                    return 1;
            }

            if ("" == infile) infile = null;
            if ("" == file2) file2 = null;
            EbnfDocument doc = null;
            if (mode == 1) // parse 
                return DoParse(infile, file2);
            var msgs = new List<object>();
            using (var sw = null == file2 ? Console.Out : new StreamWriter(File.OpenWrite(file2)))
            {
                var sww = sw as StreamWriter;
                if (null != sww)
                    sww.BaseStream.SetLength(0L);
                using (var sr = null == infile ? Console.In : new StreamReader(infile))
                {
                    try
                    {
                        doc = EbnfDocument.ReadFrom(sr);
                    }
                    catch (ExpectingException ex)
                    {
                        var em = string.Concat("Error parsing grammar: ", ex.Message);
                        msgs.Add(em);
                        Console.Error.WriteLine(em);
                        WriteHeader(sw, infile, msgs);
                        return 2;
                    }
                }

                var hasErrors = false;
                foreach (var m in doc.Prepare(false))
                {
                    msgs.Add(m);
                    Console.Error.WriteLine(m);
                    if (EbnfErrorLevel.Error == m.ErrorLevel)
                        hasErrors = true;
                }

                if (hasErrors)
                {
                    // make sure to dump the messages
                    WriteHeader(sw, infile, msgs);
                    return 3;
                }

                var name = file2 != null ? Path.GetFileNameWithoutExtension(file2) : doc.StartProduction + "Parser";
                var cfg = doc.ToCfg();
                foreach (var m in cfg.PrepareLL1(false))
                {
                    msgs.Add(m);
                    Console.Error.WriteLine(m);
                    if (CfgErrorLevel.Error == m.ErrorLevel)
                        hasErrors = true;
                }

                if (hasErrors)
                {
                    WriteHeader(sw, infile, msgs);
                    return 4;
                }

                Console.Error.WriteLine();
                Console.Error.WriteLine("Final grammar:");
                Console.Error.WriteLine();
                Console.Error.WriteLine(cfg);
                Console.Error.WriteLine();
                Console.Error.WriteLine("{0} Terminals, {1} NonTerminals, {2} Total Symbols", cfg.Terminals.Count,
                    cfg.NonTerminals.Count, cfg.Symbols.Count);
                var lexer = doc.ToLexer(cfg);
                WriteHeader(sw, infile, msgs);
                var hasNS = !string.IsNullOrEmpty(ns);
                if (hasNS)
                    sw.WriteLine(string.Concat("namespace ", ns, " {"));
                cfg.WriteCSharpTableDrivenLL1ParserClassTo(sw, name, null, lexer);
                if (hasNS)
                    sw.WriteLine("}");
            }

            return 0;
        }

        public static void PrintUsage()
        {
            Console.Error.WriteLine("Usage: newt [<grammarfile> [<outputfile>]] [/namespace <nsname>]");
            Console.Error.WriteLine("Generates code for an LL(1) parser in C# based on an EBNF grammar.");
            Console.Error.WriteLine();
            Console.Error.WriteLine(
                "\t<grammarfile>: The input grammar to create a parser for, or unspecified for <stdin>");
            Console.Error.WriteLine();
            Console.Error.WriteLine(
                "\t<outputfile>: The new C# class file to generate a parser to, or unspecified for <stdout>");
            Console.Error.WriteLine();
            Console.Error.WriteLine("\t<nsname>: The namespace under which to generate the specified class.");
            Console.Error.WriteLine();
            Console.Error.WriteLine(
                "If <outputfile> is specified, the name of the class will be the name of the file withough the path or extension");
            Console.Error.WriteLine(
                "If <outputfile> is not specified, the name of the class will be the name of start symbol with \"Parser\" appended.");
        }

        public static void WriteHeader(TextWriter writer, string infile, IEnumerable<object> msgs)
        {
            if (null != infile)
                writer.WriteLine(string.Concat("#line 1 \"", Path.GetFullPath(infile).Replace("\"", "\"\""), "\""));
            foreach (var m in msgs)
            {
                var em = m as EbnfMessage;
                if (null != em)
                {
                    if (EbnfErrorLevel.Warning == em.ErrorLevel)
                        writer.Write("#warning ");
                    else if (EbnfErrorLevel.Error == em.ErrorLevel)
                        writer.Write("#error ");
                    else if (EbnfErrorLevel.Message == em.ErrorLevel)
                        writer.Write("// Generator ");
                    else
                        continue;
                    writer.WriteLine(em.ToString());
                }
                else
                {
                    var cm = m as CfgMessage;
                    if (null != cm)
                    {
                        if (CfgErrorLevel.Warning == cm.ErrorLevel)
                            writer.Write("#warning ");
                        else if (CfgErrorLevel.Error == cm.ErrorLevel)
                            writer.Write("#error ");
                        else if (CfgErrorLevel.Message == cm.ErrorLevel)
                            writer.Write("// Generator ");
                        else
                            continue;
                        writer.WriteLine(cm.ToString());
                    }
                    else
                    {
                        writer.WriteLine(string.Concat("#error ", m));
                    }
                }
            }
        }

        private static int DoParse(string grammarfile, string inputFile)
        {
            throw new NotImplementedException();
        }
    }
}

//*** SourceCombiner -> original file Program.cs ***
namespace Perf
{
    internal class Program
    {
        private static void _Main(string[] args)
        {
            var file = @"..\..\..\ebnf.ebnf";
            var doc = EbnfDocument.ReadFrom(file);
            doc.Prepare();
            var cfg = doc.ToCfg();
            cfg.PrepareLL1();
            var lexer = doc.ToLexer(cfg);
            string filestring;
            using (var sr = File.OpenText(file))
            {
                filestring = sr.ReadToEnd();
            }

            LLParser parser = cfg.ToLL1Parser(lexer);
            parser.Restart(ParseContext.Create(filestring));
            Console.WriteLine(parser.ParseSubtree());
            var sw = new Stopwatch();
            sw.Restart();
            for (var i = 0; i < 100; ++i)
            {
                parser.Restart(ParseContext.Create(filestring));
                while (parser.Read()) ;
            }

            sw.Stop();
            Console.WriteLine("Runtime Parser: {0}", sw.Elapsed.TotalMilliseconds / 100);
            parser = new EbnfParser();
            sw.Restart();
            for (var i = 0; i < 100; ++i)
            {
                parser.Restart(ParseContext.Create(filestring));
                while (parser.Read()) ;
            }

            sw.Stop();
            Console.WriteLine("Generated Parser: {0}", sw.Elapsed.TotalMilliseconds / 100);
        }
    }
}

//*** SourceCombiner -> original file Resources.Designer.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

//*** SourceCombiner -> original file RtfUtility.cs ***

//*** SourceCombiner -> original file Settings.Designer.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

//*** SourceCombiner -> original file TableDrivenLL1Parser.cs ***