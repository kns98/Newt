/*
 * File generated by SourceCombiner.exe using 76 source files.
 * Created On: 7/29/2022 11:27:09 PM
*/
using CS = Grimoire.CSharpUtility;
using Grimoire;
using IEnumerable = System.Collections.IEnumerable;
using IEnumerator = System.Collections.IEnumerator;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Classification;
using Microsoft.VisualStudio.Utilities;
using Microsoft.Win32;
using System;
using System.CodeDom;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Composition;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Windows.Media;
using Task = System.Threading.Tasks.Task;
using Color=System.Drawing.Color;

//*** SourceCombiner -> original file AssemblyInfo.cs ***
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]

//*** SourceCombiner -> original file Attributes.cs ***
namespace Grimoire
{
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
	public sealed class CodeGeneratorRegistrationAttribute : RegistrationAttribute
	{
		private string _contextGuid;
		private Type _generatorType;
		private Guid _generatorGuid;
		private string _generatorName;
		private string _generatorRegKeyName;
		private bool _generatesDesignTimeSource = false;
		private bool _generatesSharedDesignTimeSource = false;
		public CodeGeneratorRegistrationAttribute(Type generatorType, string generatorName, string contextGuid)
		{
			if (generatorType == null)
				throw new ArgumentNullException("generatorType");
			if (generatorName == null)
				throw new ArgumentNullException("generatorName");
			if (contextGuid == null)
				throw new ArgumentNullException("contextGuid");
			_contextGuid = contextGuid;
			_generatorType = generatorType;
			_generatorName = generatorName;
			_generatorRegKeyName = generatorType.Name;
			_generatorGuid = generatorType.GUID;
		}
		/// <summary> 
		/// Get the generator Type 
		/// </summary> 
		public Type GeneratorType {
			get { return _generatorType; }
		}
		/// <summary> 
		/// Get the Guid representing the project type 
		/// </summary> 
		public string ContextGuid {
			get { return _contextGuid; }
		}
		/// <summary> 
		/// Get the Guid representing the generator type 
		/// </summary> 
		public Guid GeneratorGuid {
			get { return _generatorGuid; }
		}
		/// <summary> 
		/// Get or Set the GeneratesDesignTimeSource value 
		/// </summary> 
		public bool GeneratesDesignTimeSource {
			get { return _generatesDesignTimeSource; }
			set { _generatesDesignTimeSource = value; }
		}
		/// <summary> 
		/// Get or Set the GeneratesSharedDesignTimeSource value 
		/// </summary> 
		public bool GeneratesSharedDesignTimeSource {
			get { return _generatesSharedDesignTimeSource; }
			set { _generatesSharedDesignTimeSource = value; }
		}
		/// <summary> 
		/// Gets the Generator name  
		/// </summary> 
		public string GeneratorName {
			get { return _generatorName; }
		}
		/// <summary> 
		/// Gets the Generator reg key name under  
		/// </summary> 
		public string GeneratorRegKeyName {
			get { return _generatorRegKeyName; }
			set { _generatorRegKeyName = value; }
		}
		/// <summary> 
		/// Property that gets the generator base key name 
		/// </summary> 
		private string GeneratorRegKey {
			get { return string.Format(CultureInfo.InvariantCulture, @"Generators\{0}\{1}", ContextGuid, GeneratorRegKeyName); }
		}
		/// <summary> 
		///     Called to register this attribute with the given context.  The context 
		///     contains the location where the registration inforomation should be placed. 
		///     It also contains other information such as the type being registered and path information. 
		/// </summary> 
		public override void Register(RegistrationContext context)
		{
			using (Key childKey = context.CreateKey(GeneratorRegKey))
			{
				childKey.SetValue(string.Empty, GeneratorName);
				childKey.SetValue("CLSID", GeneratorGuid.ToString("B"));
				if (GeneratesDesignTimeSource)
					childKey.SetValue("GeneratesDesignTimeSource", 1);
				if (GeneratesSharedDesignTimeSource)
					childKey.SetValue("GeneratesSharedDesignTimeSource", 1);
			}
		}
		/// <summary> 
		/// Unregister this file extension. 
		/// </summary> 
		/// <param name="context"></param> 
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveKey(GeneratorRegKey);
		}
	}
}
//*** SourceCombiner -> original file Cfg.cs ***
namespace Grimoire
{
	/// <summary>
	/// Represents a Context-Free Grammar, or CFG, which is a series of rules.
	/// </summary>
	/// <remarks>This class implements value semantics</remarks>

	partial class Cfg : IEquatable<Cfg>, ICloneable, ISymbolResolver
	{
		/// <summary>
		/// Indicates sets of attributes by non-terminal that may further specify or otherwise modify parsing
		/// </summary>
		public IDictionary<string, IDictionary<string, object>> AttributeSets { get; } = new Dictionary<string, IDictionary<string, object>>();
		/// <summary>
		/// The rules that make up the grammar
		/// </summary>
		public IList<CfgRule> Rules { get; } = new List<CfgRule>();
		/// <summary>
		/// Gets or sets the starting non-terminal of the grammar
		/// </summary>
		/// <remarks>This property employs the "start" grammar attribute.</remarks>
		public string StartSymbol {
			get {
				foreach (var attrs in AttributeSets)
				{
					object b;
					if (attrs.Value.TryGetValue("start", out b) && b is bool && (bool)b)
						return attrs.Key;
				}
				if (0 < Rules.Count)
					return Rules[0].Left;
				return null;
			}
			set {
				if (!IsNonTerminal(value))
					throw new ArgumentException("The value must be a non-terminal and present in the grammar.");
				foreach (var a in AttributeSets)
					a.Value.Remove("start");
				IDictionary<string, object> attrs;
				if (!AttributeSets.TryGetValue(value, out attrs))
				{
					attrs = new Dictionary<string, object>();
					AttributeSets.Add(value, attrs);
				}
				attrs.Add("start", true);
			}
		}
		/// <summary>
		/// Returns a string representation of the grammar.
		/// </summary>
		/// <returns>A string containing a series of rules of the form A -> b C</returns>
		/// <remarks>This string is not suitable for comparison. It does not contain the grammar attributes.</remarks>
		public override string ToString()
		{
			var sb = new StringBuilder();
			var ic = Rules.Count;
			for (var i = 0; i < ic; ++i)
				sb.AppendLine(Rules[i].ToString());
			return sb.ToString();
		}
		// retrieves a unique symbol id that can represent 
		// a transformed symbol. does not alter the grammar
		public string GetTransformId(string symbol)
		{
			var names = new HashSet<string>(_EnumSymbols());
			var s = string.Concat(symbol, "`");
			if (!names.Contains(s))
				return s;
			var i = 2;
			s = string.Concat(symbol, "`", i);
			while (names.Contains(s))
			{
				++i;
				s = string.Concat(symbol, "`", i);
			}
			return s;
		}
		public string GetUniqueId(string id)
		{
			var names = new HashSet<string>(_EnumSymbols());
			var s = id;
			if (!names.Contains(s))
				return s;
			var i = 2;
			s = string.Concat(id, i.ToString());
			while (names.Contains(s))
			{
				++i;
				s = string.Concat(id, i.ToString());
			}
			return s;
		}
		IEnumerable<string> _EnumNonTerminals()
		{
			var visited = new HashSet<string>();
			var ic = Rules.Count;
			for (var i = 0; i < ic; ++i)
			{
				var left = Rules[i].Left;
				if (visited.Add(left))
					yield return left;
			}
			visited.Clear();
		}
		IEnumerable<string> _EnumTerminals()
		{
			var visited = new HashSet<string>();
			var ic = Rules.Count;
			for (var i = 0; i < ic; ++i)
			{
				var left = Rules[i].Left;
				visited.Add(left);
			}
			for (var i = 0; i < ic; ++i)
			{
				var rule = Rules[i];
				var jc = rule.Right.Count;
				for (var j = 0; j < jc; ++j)
				{
					var s = rule.Right[j];
					if (visited.Add(s))
						yield return s;
				}
			}
			// some terminals won't be listed in the rules.
			// hidden terminals aren't listed in the grammar.
			// what we do is go through the attribute sets and
			// yield any that are not in the rules. The rationale
			// is that the non-terminals must have appeared on the left
			// at some point so these attributes must be assigned to 
			// terminals. It's not exactly straightforward, but it works
			foreach (var sattrs in AttributeSets)
			{
				if (visited.Add(sattrs.Key))
					yield return sattrs.Key;
			}
			yield return "#EOS";
			yield return "#ERROR";
			visited.Clear();
		}
		IEnumerable<string> _EnumSymbols()
		{
			// we always return nonterminals first
			return _EnumNonTerminals().Concat(_EnumTerminals());
		}
		/// <summary>
		/// Provides a read-only list of all non-terminals in the grammar.
		/// </summary>
		public IList<string> NonTerminals { get { return _EnumNonTerminals().AsList(); } }
		/// <summary>
		/// Provides a read-only list of all terminals in the grammar.
		/// </summary>
		public IList<string> Terminals { get { return _EnumNonTerminals().AsList(); } }
		/// <summary>
		/// Provides a read-only list of all symbols in the grammar.
		/// </summary>
		public IList<string> Symbols { get { return _EnumSymbols().AsList(); } }
		public bool IsNonTerminal(string symbol)
		{
			if (string.IsNullOrEmpty(symbol))
				return false;
			return _EnumNonTerminals().Contains(symbol);
		}
		public IDictionary<string, ICollection<string>> FillFirsts(IDictionary<string, ICollection<string>> result = null)
		{
			if (null == result)
				result = new Dictionary<string, ICollection<string>>();
			foreach (var t in _EnumTerminals())
				if (!Equals("#ERROR", t))
					result.Add(t, new HashSet<string>(new string[] { t }));
			var ic = Rules.Count;
			ICollection<string> col;
			for (var i = 0; i < ic; ++i)
			{
				var rule = Rules[i];
				if (!result.TryGetValue(rule.Left, out col))
				{
					col = new HashSet<string>();
					result.Add(rule.Left, col);
				}
				if (rule.IsNil)
				{
					if (!col.Contains(null))
						col.Add(null);
				}
				else if (!col.Contains(rule.Right[0]))
					col.Add(rule.Right[0]);
			}
			var done = false;
			while (!done)
			{
				done = true;
				foreach (var first in result)
				{
					foreach (var s in new List<string>(first.Value))
					{
						if (IsNonTerminal(s))
						{
							done = false;
							first.Value.Remove(s);
							foreach (var f in result[s])
								if (!first.Value.Contains(f))
									first.Value.Add(f);
						}
					}
				}
			}
			return result;
		}
		public IDictionary<CfgRule, ICollection<string>> FillPredict(IDictionary<string, ICollection<string>> firsts = null, IDictionary<string, ICollection<string>> follows = null, IDictionary<CfgRule, ICollection<string>> result = null)
		{
			if (null == result)
				result = new Dictionary<CfgRule, ICollection<string>>();
			if (null == firsts)
				firsts = FillFirsts();
			if (null == follows)
				follows = FillFollows();
			var ic = Rules.Count;
			for (var i = 0; i < ic; ++i)
			{
				var rule = Rules[i];
				var col = new HashSet<string>();
				if (!rule.IsNil)
				{
					var s = rule.Right[0];
					foreach (var first in firsts[s])
						col.Add(first);
				} else
				{
					foreach (var follow in follows[rule.Left])
						col.Add(follow);
				}
				if (0 < col.Count)
					result.Add(rule, col);
			}
			return result;
		}
		public IDictionary<CfgRule, ICollection<CfgRule>> FillFirstFirstConflicts(IDictionary<string, ICollection<string>> firsts=null, IDictionary<CfgRule, ICollection<CfgRule>> result = null)
		{
			if (null == result)
				result = new Dictionary<CfgRule, ICollection<CfgRule>>();
			if (null == firsts)
				firsts = FillFirsts();
			foreach (var nt in _EnumNonTerminals())
			{
				var rules = FillNonTerminalRules(nt);
				foreach (var rule in rules)
				{
					if (!rule.IsNil)
					{
						foreach (var rule2 in rules)
						{
							if (!ReferenceEquals(rule,rule2) && !rule2.IsNil)
							{
								foreach(var x in firsts[rule2.Right[0]])
								{
									if (null != x)
									{
										if(firsts[rule.Right[0]].Contains(x))
										{
											ICollection<CfgRule> col;
											if (result.TryGetValue(rule2, out col) && col.Contains(rule))
												continue;
											if (!result.TryGetValue(rule,out col))
											{
												col = new HashSet<CfgRule>();
												result.Add(rule, col);
											}
											col.Add(rule2);
											break;
										}
									}
								}
							}
						}
					}
				}
			}
			return result;
		}
		public IDictionary<string, ICollection<CfgRule>> FillFirstFollowsConflicts(IDictionary<string, ICollection<string>> firsts = null, IDictionary<string, ICollection<string>> follows = null,IDictionary<string, ICollection<CfgRule>> result = null)
		{
			if (null == result)
				result = new Dictionary<string, ICollection<CfgRule>>();
			if (null == firsts)
				firsts = FillFirsts();
			if (null == follows)
				follows = FillFollows(firsts);
			var predict = FillPredict(firsts, follows);
			foreach (var nt in _EnumNonTerminals())
			{
				ICollection<string> col;
				if(follows.TryGetValue(nt,out col))
				{
					if(IsNillable(nt))
					{
						foreach(var p in predict)
						{
							if (!p.Key.IsNil)
							{
								if (Equals(p.Key.Left, nt))
								{
									foreach (var ff in p.Value)
									{
										if(col.Contains(ff))
										{
											ICollection<CfgRule> ccol;
											if(!result.TryGetValue(nt,out ccol))
											{
												ccol = new HashSet<CfgRule>();
												result.Add(nt, ccol);
											}
											ccol.Add(p.Key);
											break;
										}
									}
								}
							}
						}
					}
				}
			}
			return result;
		}
		public IList<CfgMessage> EliminateFirstFirstConflicts()
		{
			var result = new List<CfgMessage>();
			foreach (var nt in new List<string>(_EnumNonTerminals()))
			{
				var rules = FillNonTerminalRules(nt);
				var rights = new List<IList<string>>();
				foreach (var rule in rules)
					rights.Add(rule.Right);
				while (true)
				{
					var pfx = rights.GetLongestCommonPrefix();
					if (pfx.IsNullOrEmpty())
						break;
					// obv first first conflict
					var nnt = GetTransformId(nt);
					var suffixes = new List<IList<string>>();
					foreach (var rule in rules)
					{
						if (rule.Right.StartsWith(pfx))
						{
							rights.Remove(rule.Right);
							suffixes.Add(new List<string>(rule.Right.SubRange(pfx.Count)));
							result.Add(new CfgMessage(CfgErrorLevel.Message, -1, string.Format("Removing rule {0} because it is part of a first-first conflict.", rule)));
							Rules.Remove(rule);
						}
					}
					var newRule = new CfgRule(nt);
					newRule.Right.AddRange(pfx);
					newRule.Right.Add(nnt);
					result.Add(new CfgMessage(CfgErrorLevel.Message, -1, string.Format("Adding rule {0} to resolve first-first conflict.", newRule)));
					if (!Rules.Contains(newRule))
						Rules.Add(newRule);
					foreach (var suffix in suffixes)
					{
						newRule = new CfgRule(nnt);
						newRule.Right.AddRange(suffix);
						result.Add(new CfgMessage(CfgErrorLevel.Message, -1, string.Format("Adding rule {0} to resolve first-first conflict.", newRule)));
						if (!Rules.Contains(newRule))
							Rules.Add(newRule);
					}
					var attrs = new Dictionary<string, object>();
					attrs.Add("collapse", true);
					AttributeSets.Add(nnt, attrs);
				}
			}
			return result;
		}
		public IList<CfgMessage> EliminateFirstFollowsConflicts()
		{
			var result = new List<CfgMessage>();
			var firsts = FillFirsts();
			var follows = FillFollows();
			foreach(var nt in _EnumNonTerminals())
			{
				var x = firsts[nt];
				ICollection<string> y;
				if(follows.TryGetValue(nt, out y))
				{
					if (IsNillable(nt))
					{
						foreach (var yy in y)
						{
							if (x.Contains(yy))
							{
								break;
							}
						}
					}
				}
			}
			return result;
		}
		public IList<CfgMessage> EliminateLeftRecursion()
		{
			var result = new List<CfgMessage>();
			var ic = Rules.Count;
			for (var i = 0; i < ic; ++i)
			{
				var rule = Rules[i];
				if (rule.IsDirectlyLeftRecursive)
				{
					result.Add(new CfgMessage(CfgErrorLevel.Message, -1, string.Format("Removing rule {0} because it is directly left recursive.", rule)));
					Rules.Remove(rule);
					var newId = GetTransformId(rule.Left);
					var col = new List<string>();
					var c = rule.Right.Count;
					for (var j = 1; j < c; ++j)
						col.Add(rule.Right[j]);
					col.Add(newId);
					var d = new Dictionary<string, object>();
					AttributeSets.Add(newId, d);
					d.Add("collapse", true);
					var newRule = new CfgRule(newId);
					newRule.Right.AddRange(col);
					result.Add(new CfgMessage(CfgErrorLevel.Message, -1, string.Format("Adding rule {1} to replace rule {0}", rule,newRule)));
					if (!Rules.Contains(newRule))
						Rules.Add(newRule);
					var rr = new CfgRule(newId);
					result.Add(new CfgMessage(CfgErrorLevel.Message, -1, string.Format("Adding rule {1} to replace rule {0}", rule, rr)));
					if (!Rules.Contains(rr))
						Rules.Add(rr);
					foreach (var r in Rules)
					{
						if (Equals(r.Left, rule.Left))
						{
							if (!r.IsDirectlyLeftRecursive)
							{
								r.Right.Add(newId);
							}
						}
					}
				}
			}
			return result;
		}
		public IList<CfgMessage> PrepareLL1(bool throwIfErrors=true)
		{
			var result = new List<CfgMessage>();
			Cfg old = this;
			// if 10 times doesn't sort out this grammar it's not LL(1)
			// the math is such that we don't know unless we try
			// and the tries can go on forever.
			for (int i = 0; i < 10; ++i)
			{
				var fcc = FillFirstFollowsConflicts();
				if (0 < fcc.Count)
					result.AddRange(EliminateFirstFollowsConflicts());
				if (IsDirectlyLeftRecursive)
					result.AddRange(EliminateLeftRecursion());
				var cc = FillFirstFirstConflicts();
				if (0 < cc.Count)
					result.AddRange(EliminateFirstFirstConflicts());
				//result.AddRange(EliminateUnderivableRules());
				fcc = FillFirstFollowsConflicts();
				cc = FillFirstFirstConflicts();
				if (0 == cc.Count && 0 == fcc.Count && !IsDirectlyLeftRecursive)
					break;
				if (old.Equals(this))
					break;
				old = Clone();
			}
			if (IsDirectlyLeftRecursive)
				result.Add(new CfgMessage(CfgErrorLevel.Error, 9, "Grammar is unresolvably and directly left recursive and cannot be parsed with an LL parser."));
			else if (IsLeftRecursive())
				result.Add(new CfgMessage(CfgErrorLevel.Error, 10, "Grammar is unresolvably and indirectly left recursive and cannot be parsed with an LL parser."));
			var fc = FillFirstFollowsConflicts();
			foreach (var f in fc)
				result.Add(new CfgMessage(CfgErrorLevel.Error, 11, string.Concat("Grammar has an unresolvable first-follows conflict on ", f.Key)));
			var c = FillFirstFirstConflicts();
			foreach (var f in c)
				foreach (var ff in f.Value)
					result.Add(new CfgMessage(CfgErrorLevel.Error, 12, string.Concat("Grammar has an unresolvable first-first conflict between ", f.Key, " and ", ff)));
			if (throwIfErrors)
			{
				foreach (var m in result)
					if (CfgErrorLevel.Error == m.ErrorLevel)
						throw new CfgException(result);
			}
			return result;
		}
		public bool IsNillable(string nonTerminal)
		{
			foreach (var rule in FillNonTerminalRules(nonTerminal))
				if (rule.IsNil)
					return true;
			return false;
		}
		public IList<CfgRule> FillNonTerminalRules(string nonTerminal, IList<CfgRule> result = null)
		{
			if (null == result) result = new List<CfgRule>();
			var ic = Rules.Count;
			for (var i = 0; i < ic; ++i)
			{
				var rule = Rules[i];
				if (Equals(rule.Left, nonTerminal))
					result.Add(rule);
			}
			return result;
		}
		/// <summary>
		/// Retrieves an integer identifier for a symbol suitable for use by parse tables and parsers.
		/// </summary>
		/// <param name="symbol">The symbol to retrieve the identifier for.</param>
		/// <returns>An integer that can be used to refer to the symbol, or less than zero to indicate the symbol was not present in the CFG.</returns>
		public int GetSymbolId(string symbol)
		{
			return _EnumSymbols().IndexOf(symbol);
		}
		/// <summary>
		/// Computes the FOLLOWS sets for the grammar
		/// </summary>
		/// <param name="firsts">The precomputed firsts sets. These will be computed if this is null.</param>
		/// <param name="result">The result to fill. If null, a new dictionary will be created.</param>
		/// <returns>The result, filled with FOLLOWS sets grouped by non-terminal</returns>
		public IDictionary<string,ICollection<string>> FillFollows(IDictionary<string,ICollection<string>> firsts=null,IDictionary<string,ICollection<string>> result = null)
		{
			if (null == result)
				result = new Dictionary<string, ICollection<string>>();
			var done = false;
			if(null==firsts)
				firsts = FillFirsts();
			var ss = StartSymbol;
			// augment the grammar S' -> S #EOS
			CfgRule start = new CfgRule(GetTransformId(ss),ss, "#EOS");
			foreach(var rule in new CfgRule[] {start}.Concat(Rules))
			{
				if (rule.IsNil)
				{
					ICollection<string> col;
					if (!result.TryGetValue(rule.Left, out col))
					{
						col = new HashSet<string>();
						result.Add(rule.Left, col);
					}
					if (!col.Contains(rule.Left))
						col.Add(rule.Left);
				}
				else
				{
					var ic = rule.Right.Count;
					for (var i = 1; i < ic; ++i)
					{
						var prev = rule.Right[i - 1];
						var sym = rule.Right[i];
						if (IsNonTerminal(prev))
						{
							ICollection<string> col;
							if (!result.TryGetValue(prev, out col))
							{
								col = new HashSet<string>();
								result.Add(prev, col);
							}
							foreach (var s in firsts[sym])
							{
								// we'll need the following symbol's follows
								if (null == s)
								{
									if (!col.Contains(sym))
										col.Add(sym);
								}
								else if (!col.Contains(s))
									col.Add(s);
							}
						}
					}
					var last = rule.Right[ic - 1];
					if (IsNonTerminal(last))
					{
						ICollection<string> col;
						if (!result.TryGetValue(last, out col))
						{
							col = new HashSet<string>();
							result.Add(last, col);
						}
						if (!col.Contains(rule.Left))
							col.Add(rule.Left);
					}
				}
			}
			done = false;
			const int LIMIT = 10000;
			var il = 0;
			while (!done)
			{
				done = true;
				foreach (var kvp in result)
				{
					foreach (var s in new List<string>(kvp.Value))
					{
						if (IsNonTerminal(s))
						{
							kvp.Value.Remove(s);
							ICollection<string> col;
							if (result.TryGetValue(s, out col))
							{
								foreach (var sss in col)
									if (!kvp.Value.Contains(sss))
									{
										if (sss != s)
										{
											kvp.Value.Add(sss);
											done = false;
										}
									}
							}
						}
					}
				}
				++il;
				if (LIMIT<il)
					throw new CfgException("Loop detected in follows computation - follows limit exceeded.",16);
			}
			return result;
		}
		public bool IsDirectlyLeftRecursive {
			get {
				var ic = Rules.Count;
				for(var i = 0;i<ic;++i)
					if (Rules[i].IsDirectlyLeftRecursive)
						return true;
				return false;
			}
		}
		ICollection<string> _FillLeftClosure(string nonTerminal, ICollection<string> result = null)
		{
			if (null == result) result = new HashSet<string>();
			if (result.Contains(nonTerminal)) return result;
			result.Add(nonTerminal);
			foreach(var rule in FillNonTerminalRules(nonTerminal))
				if(!rule.IsNil)
					_FillLeftClosure(rule.Right[0], result);
			return result;
		}
		ICollection<string> _FillLeftDescendants(string nonTerminal, ICollection<string> result = null)
		{
			if (null == result) result = new HashSet<string>();
			foreach (var rule in FillNonTerminalRules(nonTerminal))
				if (!rule.IsNil)
					_FillLeftClosure(rule.Right[0], result);
			return result;
		}
		public bool IsLeftRecursive()
		{
			foreach (var nt in _EnumNonTerminals())
				if (_FillLeftDescendants(nt).Contains(nt))
					return true;
			return false;
		}
		public bool IsLeftRecursive(string nonTerminal)
		{
			if (_FillLeftDescendants(nonTerminal).Contains(nonTerminal))
				return true;
			return false;
		}
		/// <summary>
		/// Reports whether the specified non-terminal symbol is nillable
		/// </summary>
		/// <param name="symbol">The non-terminal to check</param>
		/// <returns>True if the symbol is a non-terminal and if it has a rule that takes the form of A -> ε, otherwise false.</returns>
		public bool IsNillable(object symbol)
		{
			var ic = Rules.Count;
			for(var i = 0;i<ic;++i)
			{
				var rule = Rules[i];
				if (Equals(symbol, rule.Left) && rule.IsNil)
					return true;
			}
			return false;
		}
		/// <summary>
		/// Builds a table an LL(1) parser can use to parse input.
		/// </summary>
		/// <param name="predict">The computed prediction table, or null to compute it.</param>
		/// <returns>An array based parse table suitable for use by an LL(1) parser.</returns>
		public (int Left, int[] Right)[][] ToLL1ParseTable(IDictionary<CfgRule, ICollection<string>> predict = null)
		{
			var nts = new List<string>(_EnumNonTerminals());
			var ts = new List<string>(_EnumTerminals());
			ts.Remove("#ERROR");
			var result = new (int Left, int[] Right)[nts.Count][];
			if (null == predict) predict = FillPredict();
			foreach (var nt in nts)
			{
				var arr = new (int Left, int[] Right)[ts.Count];
				for (var i = 0; i < arr.Length; i++)
					arr[i] = (-1, null);
				foreach (var pre in predict)
				{
					if (Equals(nt, pre.Key.Left))
					{
						foreach (var s in pre.Value)
						{
							if (null != s)
							{
								var right = new int[pre.Key.Right.Count];
								for (var i = 0; i < right.Length; i++)
									right[i] = GetSymbolId(pre.Key.Right[i]);
								(int Left, int[] Right) ir = (GetSymbolId(pre.Key.Left), right);
								var sid = GetSymbolId(s);
								arr[sid - nts.Count] = (-1, null);
								(int Left, int[] Right) ir2;
								if (null != (ir2 = arr[sid - nts.Count]).Right)
									throw new Exception(string.Format("Conflict between {0} and {1}", _ToStringIntRule(ir2), _ToStringIntRule(ir)));
								else
									arr[sid - nts.Count] = ir;
							}
						}
					}
				}
				result[GetSymbolId(nt)] = arr;
			}
			return result;
		}
		public TableDrivenLL1Parser ToLL1Parser(FA lexer,ParseContext parseContext = null)
		{
			var parseTable = ToLL1ParseTable();
			var startSymbol = StartSymbol;
			(int SymbolId, bool IsNonTerminal, int NonTerminalCount) startingConfiguration =
				(GetSymbolId(startSymbol), IsNonTerminal(startSymbol), _EnumNonTerminals().Count());
			var lexTable = lexer.ToDfaTable2<int>();
			var symbols = _EnumSymbols().ToArray();
			var substitutionsAndHiddenTerminals = new int[symbols.Length];
			for(var i = 0;i<substitutionsAndHiddenTerminals.Length;i++)
			{
				substitutionsAndHiddenTerminals[i] = GetSymbolId(symbols[i]);
				var d= AttributeSets.TryGetValue(symbols[i], null);
				if(null!=d)
				{
					object o;
					if (!IsNonTerminal(symbols[i]) && d.TryGetValue("hidden", out o) && o is bool && (bool)o)
						substitutionsAndHiddenTerminals[i] = -3;
					else
					{
						var s = d.TryGetValue("substitute", null) as string;
						if (null != s)
							substitutionsAndHiddenTerminals[i] = GetSymbolId(s);
					}
				}
			}
			var blockEnds = new string[symbols.Length];
			for(var i = 0;i<blockEnds.Length;i++)
			{
				blockEnds[i] = null;
				var d = AttributeSets.TryGetValue(symbols[i], null);
				if(null!=d)
				{
					blockEnds[i]= d.TryGetValue("blockEnd", null) as string;
				}
			}
			var collapsedNonTerminals = new int[symbols.Length];
			for (var i = 0; i < collapsedNonTerminals.Length; i++)
			{
				collapsedNonTerminals[i] = -1;
				var d = AttributeSets.TryGetValue(symbols[i], null);
				if (null != d)
				{
					object o;
					if (d.TryGetValue("collapse", out o) && o is bool && (bool)o)
						collapsedNonTerminals[i] = -3;
				}
			}
			var terminalTypes = new Type[symbols.Length];
			for (var i = 0; i < terminalTypes.Length; i++)
			{
				terminalTypes[i] = null;
				var d = AttributeSets.TryGetValue(symbols[i], null);
				if (null != d)
				{
					var s = d.TryGetValue("type", null) as string;
					if (null != s)
					{
						terminalTypes[i] = ParserUtility.ResolveType(s);
					}
				}
			}
			return new TableDrivenLL1Parser(
				parseTable,
				startingConfiguration,
				lexTable,
				symbols,
				substitutionsAndHiddenTerminals,
				blockEnds,
				collapsedNonTerminals,
				terminalTypes,
				parseContext
				);
		}
		string _ToStringIntRule((int Left, int[] Right) rule)
		{
			var sb = new StringBuilder();
			sb.Append(GetSymbolById(rule.Left));
			sb.Append(" ->");
			for(var i = 0;i<rule.Right.Length;i++)
			{
				sb.Append(" ");
				sb.Append(GetSymbolById(rule.Right[i]));
			}
			return sb.ToString();
		}
		public string GetSymbolById(int symbolId)
		{
			if(-1<symbolId && symbolId<_EnumSymbols().Count())
				return _EnumSymbols().GetAt(symbolId);
			return null;
		}
		static string _MakeSafeCsv(string field)
		{
			if(-1<field.IndexOfAny(new char[] { ',', '\"', '\n', '\r' }))
				return string.Concat("\"", field.Replace("\"", "\"\""), "\"");
			return field;
		}
		public string ToLL1Csv((int Left, int[] Right)[][] parseTable=null)
		{
			if (null == parseTable)
				parseTable = ToLL1ParseTable();
			var sb = new StringBuilder();
			sb.Append("LL(1) Parse Table");
			foreach(var t in _EnumTerminals())
			{
				if(!Equals("#ERROR",t))
				{
					sb.Append(",");
					sb.Append(_MakeSafeCsv(t));
				}
			}
			sb.AppendLine();
			foreach(var nt in _EnumNonTerminals())
			{
				sb.Append(_MakeSafeCsv(nt));
				foreach(var t in _EnumTerminals())
				{
					if (!Equals("#ERROR", t))
					{
						sb.Append(",");
						IDictionary<int, (int Left, int[] Right)> d;
						(int Left, int[] Right) ir;
						if (null!=(ir=parseTable[GetSymbolId(nt)][GetSymbolId(t)]).Right)
						{
							sb.Append(_MakeSafeCsv(GetSymbolById(ir.Left)));
							sb.Append(" ->");
							for (var i = 0; i < ir.Right.Length; i++)
							{
								sb.Append(" ");
								sb.Append(_MakeSafeCsv(GetSymbolById(ir.Right[i])));
							}
						}
					}
				}
				sb.AppendLine();
			}
			return sb.ToString();
		}
		#region Value Semantics
		/// <summary>
		/// Indicates whether the CFG is exactly equivelant to the specified CFG
		/// </summary>
		/// <param name="rhs">The CFG to compare</param>
		/// <returns>True if the CFGs are equal, otherwise false.</returns>
		public bool Equals(Cfg rhs)
		{
			if (!CollectionUtility.Equals(this.Rules, rhs.Rules))
				return false;
			if (AttributeSets.Count != rhs.AttributeSets.Count)
				return false;
			foreach(var attrs in AttributeSets)
			{
				IDictionary<string, object> d;
				if(!rhs.AttributeSets.TryGetValue(attrs.Key,out d))
				{
					if (d.Count != attrs.Value.Count)
						return false;
					foreach(var attr in attrs.Value)
					{
						object o;
						if(!d.TryGetValue(attr.Key, out o) || !Equals(o,attr.Value))
							return false;
					}
				}
			}
			return true;
		}
		/// <summary>
		/// Indicates whether the CFG is exactly equivelant to the specified CFG
		/// </summary>
		/// <param name="obj">The CFG to compare</param>
		/// <returns>True if the CFGs are equal, otherwise false.</returns>
		public override bool Equals(object obj)
		{
			return Equals(obj as Cfg);
		}
		/// <summary>
		/// Gets a hashcode that represents this CFG
		/// </summary>
		/// <returns>A hashcode that represents this CFG</returns>
		public override int GetHashCode()
		{
			var result = CollectionUtility.GetHashCode(Rules);
			foreach (var attrs in AttributeSets)
			{
				result ^= attrs.Key.GetHashCode();
				foreach(var attr in attrs.Value)
				{
					result ^= attr.Key.GetHashCode();
					if (null != attr.Value)
						result ^= attr.Value.GetHashCode();
				}
			}
			return result;
		}
		/// <summary>
		/// Indicates whether the two CFGs are exactly equivelent
		/// </summary>
		/// <param name="lhs">The first CFG to compare</param>
		/// <param name="rhs">The second CFG to compare</param>
		/// <returns>True if the CFGs are equal, otherwise false</returns>
		public static bool operator==(Cfg lhs,Cfg rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs,null)) return false;
			return lhs.Equals(rhs);
		}
		/// <summary>
		/// Indicates whether the two CFGs are not equal
		/// </summary>
		/// <param name="lhs">The first CFG to compare</param>
		/// <param name="rhs">The second CFG to compare</param>
		/// <returns>True if the CFGs are not equal, or false if they are equal</returns>
		public static bool operator !=(Cfg lhs, Cfg rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		/// <summary>
		/// Performs a deep clone of the CFG
		/// </summary>
		/// <returns>A new CFG equal to this CFG</returns>
		public Cfg Clone()
		{
			var result = new Cfg();
			var ic = Rules.Count;
			for(var i = 0;i<ic;++i)
				result.Rules.Add(Rules[i].Clone());
			foreach(var attrs in AttributeSets)
			{
				var d = new Dictionary<string, object>();
				result.AttributeSets.Add(attrs.Key, d);
				foreach(var attr in attrs.Value)
					d.Add(attr.Key, attr.Value);
			}
			return result;
		}
		object ICloneable.Clone() { return Clone();  }
		#endregion
	}
}
//*** SourceCombiner -> original file Cfg.CSharpCodeGenerator.cs ***
namespace Grimoire
{
	partial class Cfg
	{
		static bool _IsValidIdentifier(string identifier)
		{
			if (string.IsNullOrEmpty(identifier)) return false;
			if (!char.IsLetter(identifier[0]) && '_' != identifier[0])
				return false;
			for (var i = 1; i < identifier.Length; i++)
			{
				char ch = identifier[i];
				if (!char.IsLetterOrDigit(ch) && '_' != ch && '-' != ch)
					return false;
			}
			return true;
		}
		static string _GetUniqueName(ICollection<string> names,string name)
		{
			var i = 2;
			var s = name;
			while (names.Contains(s))
			{
				s = string.Concat(name, i.ToString());
				++i;
			}
			return s;
		}
		public void WriteCSharpSymbolConstantsTo(TextWriter writer, string modifiers)
		{
			if (null == modifiers)
				modifiers = "";
			var names = new HashSet<string>();
			writer.WriteLine(string.Concat("\t", modifiers, " const int EOS=", GetSymbolId("#EOS").ToString(), ";"));
			names.Add("EOS");
			writer.WriteLine(string.Concat("\t",modifiers," const int ERROR=",GetSymbolId("#ERROR").ToString(),";"));
			names.Add("ERROR");
			foreach (var sym in _EnumSymbols())
			{
				IDictionary<string, object> d;
				object o;
				if (AttributeSets.TryGetValue(sym, out d) && d.TryGetValue("hidden", out o) && o is bool && (bool)o)
					continue;
				if (AttributeSets.TryGetValue(sym, out d) && d.TryGetValue("collapse", out o) && o is bool && (bool)o)
					continue;
				var sid = Convert.ToString(sym);
				if (_IsValidIdentifier(sid))
				{
					string s;
					if (!string.IsNullOrEmpty(modifiers))
						s = string.Concat("\t", modifiers, " const int ");
					else
						s = string.Concat("\t", modifiers, "const int ");
					var id = GetSymbolId(sym);
					s = string.Concat(s, CS.CreateEscapedIdentifier(sid.Replace('-', '_')), " = ");
					s = _GetUniqueName(names, s);
					names.Add(s);
					s = string.Concat(s, id.ToString(), ";");
					writer.WriteLine(s);
				}
			}
		}
		public void WriteCSharpLL1ParseTableCreateExpressionTo(TextWriter writer, (int Left, int[] Right)[][] parseTable = null)
		{
			if (null == parseTable)
				parseTable = ToLL1ParseTable();
			var ntc = _EnumNonTerminals().Count();
			writer.WriteLine("new (int Left, int[] Right)[][] {");
			for(var i =0;i<ntc;++i)
			{
				writer.Write("\t");
				if (0 != i) writer.Write(",");
				var d = parseTable[i];
				writer.WriteLine("new (int Left, int[] Right)[] {");
				var j = 0;
				foreach (var t in _EnumTerminals())
				{
					if (Equals(t, "#ERROR"))
						continue;
					writer.Write("\t\t");
					if (0 != j) writer.Write(",");
					(int Left, int[] Right) ir;
					if (null!=(ir=d[j]).Right)
					{
						writer.Write("(");
						CS.WriteCSharpLiteralTo(writer, ir.Left);
						writer.Write(", ");
						CS.WriteCSharpLiteralTo(writer, ir.Right);
						writer.WriteLine(")");
					}
					else
						writer.WriteLine("(-1,null)");
					++j;
				}
				writer.WriteLine("\t\t}");
			}
			writer.Write("}");
		}
		public void WriteCSharpTableDrivenLL1ParserClassTo(TextWriter writer, string name, string modifiers = null, FA lexer = null, (int Left, int[] Right)[][] parseTable = null)
		{
			if (string.IsNullOrEmpty(name))
				name = "Parser";
			if (!string.IsNullOrEmpty(modifiers))
				writer.Write(string.Concat(modifiers, " "));
			writer.Write(string.Concat("partial class ", name, " : Grimoire.TableDrivenLL1Parser"));
			writer.WriteLine(" {");
			writer.WriteLine(string.Concat("\tpublic ", name, "(Grimoire.ParseContext parseContext=null) : base(_ParseTable,_StartingConfiguration,_LexTable,_Symbols,_SubstitutionsAndHiddenTerminals,_BlockEnds,_CollapsedNonTerminals,_Types,parseContext) { }"));
			WriteCSharpSymbolConstantsTo(writer, "public");
			writer.Write("\tstatic readonly string[] _Symbols = {");
			var delim = "";
			foreach (var sym in _EnumSymbols())
			{
				writer.Write(delim);
				CS.WriteCSharpLiteralTo(writer, sym);
				delim = ", ";
			}
			writer.WriteLine(" };");
			writer.Write("\tstatic readonly (int Left, int[] Right)[][] _ParseTable = ");
			WriteCSharpLL1ParseTableCreateExpressionTo(writer, parseTable);
			writer.WriteLine(";");
			writer.WriteLine();
			writer.Write("\tstatic readonly int[] _SubstitutionsAndHiddenTerminals = new int[] { ");
			delim = "";
			foreach (var sym in _EnumSymbols())
			{
				IDictionary<string, object> attrs;
				if (AttributeSets.TryGetValue(sym, out attrs))
				{
					if ((bool)attrs.TryGetValue("hidden", false))
						writer.Write("-2");
					else
					{
						object sub = attrs.TryGetValue("substitute", null);
						if (null != sub)
							writer.Write(GetSymbolId(sub as string));
						else
							writer.Write(GetSymbolId(sym));
					}
				}
				else
					writer.Write(GetSymbolId(sym));
				writer.Write(", ");
			}
			writer.WriteLine("-1 };");
			writer.Write("\tstatic readonly (int SymbolId,bool IsNonTerminal,int NonTerminalCount) _StartingConfiguration = (");
			var ss = StartSymbol;
			var startId = GetSymbolId(ss);
			var isNonTerminal = IsNonTerminal(ss);
			writer.Write(string.Concat(startId, ", "));
			CS.WriteCSharpLiteralTo(writer, isNonTerminal);
			writer.Write(", ");
			CS.WriteCSharpLiteralTo(writer, _EnumNonTerminals().Count());
			writer.WriteLine(");");
			writer.WriteLine("\tstatic readonly string[] _BlockEnds = new string[] { ");
			delim = "\t";
			foreach (var sym in _EnumSymbols())
			{
				writer.Write(delim);
				IDictionary<string, object> attrs;
				if (AttributeSets.TryGetValue(sym, out attrs))
				{
					var be = attrs.TryGetValue("blockEnd", null) as string;
					CS.WriteCSharpLiteralTo(writer, be);
					writer.WriteLine();
				}
				else
					writer.WriteLine("null");
				delim = "\t,";
			}
			writer.WriteLine("};");
			writer.WriteLine("\tstatic readonly System.Type[] _Types = new System.Type[] { ");
			delim = "\t";
			foreach (var sym in _EnumSymbols())
			{
				writer.Write(delim);
				IDictionary<string, object> attrs;
				if (AttributeSets.TryGetValue(sym, out attrs))
				{
					object o;
					if (attrs.TryGetValue("type", out o) && !string.IsNullOrEmpty(o as string) && !IsNonTerminal(sym))
					{
						var id = GetSymbolId(sym);
						Type t = null;
						var s = o as string;
						if (!string.IsNullOrEmpty(s))
							t = ParserUtility.ResolveType(s);
						else
							t = o as Type;
						if (null == t)
							throw new InvalidOperationException(string.Concat("Invalid type \"", o, "\"."));
						writer.Write("typeof(");
						writer.Write(t.FullName);
						writer.WriteLine(")");
					}
					else
						writer.Write("null");
					writer.WriteLine();
				}
				else
					writer.WriteLine("null");
				delim = "\t,";
			}
			writer.WriteLine("};");
			writer.WriteLine("\tstatic readonly int[] _CollapsedNonTerminals = new int[] { ");
			delim = "";
			foreach (var sym in _EnumSymbols())
			{
				writer.Write(delim);
				IDictionary<string, object> attrs;
				if (AttributeSets.TryGetValue(sym, out attrs))
				{
					object be;
					if (attrs.TryGetValue("collapse", out be) && (be is bool) && (bool)be)
						writer.Write(-3);
					else
						writer.Write(-1);
				}
				else
					writer.Write("-1");
				delim = ",";
			}
			writer.WriteLine("};");
			if (null != lexer)
			{
				writer.Write("\tstatic readonly (int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] _LexTable = ");
				FA.WriteCSharpDfaTable2CreationExpressionTo(writer, lexer.ToDfaTable2<int>());
				writer.WriteLine(";");
			}
			writer.WriteLine("}");
		}
	}
}
//*** SourceCombiner -> original file CfgException.cs ***
namespace Grimoire
{

	sealed class CfgException : Exception
	{
		public IList<CfgMessage> Messages { get; }
		public CfgException(string message, int errorCode = -1) :
			this(new CfgMessage[] { new CfgMessage(CfgErrorLevel.Error, errorCode, message) })
		{ }
		static string _FindMessage(IEnumerable<CfgMessage> messages)
		{
			var l = new List<CfgMessage>(messages);
			if (null == messages) return "";
			int c = 0;
			foreach (var m in l)
			{
				if (CfgErrorLevel.Error == m.ErrorLevel)
				{
					if (1 == l.Count)
						return m.ToString();
					return string.Concat(m, " (multiple messages)");
				}
				++c;
			}
			foreach (var m in messages)
				return m.ToString();
			return "";
		}
		public CfgException(IEnumerable<CfgMessage> messages) : base(_FindMessage(messages))
		{
			Messages = new List<CfgMessage>(messages);
		}
		public static void ThrowIfErrors(IEnumerable<CfgMessage> messages)
		{
			if (null == messages) return;
			foreach (var m in messages)
				if (CfgErrorLevel.Error == m.ErrorLevel)
					throw new CfgException(messages);
		}
	}
}
//*** SourceCombiner -> original file CfgMessage.cs ***
namespace Grimoire
{

	enum CfgErrorLevel
	{
		Message = 0,
		Warning = 1,
		Error = 2
	}

	sealed class CfgMessage
	{
		public CfgMessage(CfgErrorLevel errorLevel, int errorCode, string message)
		{
			ErrorLevel = errorLevel;
			ErrorCode = errorCode;
			Message = message;
		}
		public CfgErrorLevel ErrorLevel { get; private set; }
		public int ErrorCode { get; private set; }
		public string Message { get; private set; }
		public override string ToString()
		{
			if (-1 != ErrorCode)
				return string.Format("{0}: {1} code {2}",
					ErrorLevel, Message, ErrorCode);
			return string.Format("{0}: {1}",
					ErrorLevel, Message);
		}
	}
}
//*** SourceCombiner -> original file CfgRule.cs ***
namespace Grimoire
{
	/// <summary>
	/// Represents a rule in a context-free grammar
	/// </summary>
	/// <remarks>This class has value semantics</remarks>

	class CfgRule : IEquatable<CfgRule>, ICloneable
	{
		/// <summary>
		/// Constructs an empty rule
		/// </summary>
		public CfgRule() { }
		/// <summary>
		/// Constructs the rule
		/// </summary>
		/// <param name="left">The left hand side of the rule.</param>
		/// <param name="right">The right hand symbols for the rule</param>
		public CfgRule(string left, params string[] right) { Left = left; Right.AddRange(right); }
		/// <summary>
		/// Constructs the rule
		/// </summary>
		/// <param name="left">The left hand side of the rule.</param>
		/// <param name="right">The right hand symbols for the rule</param>
		public CfgRule(string left, IEnumerable<string> right) { Left = left; Right.AddRange(right); }
		/// <summary>
		/// Indicates the left hand side of the rule
		/// </summary>
		/// <remarks>Any symbol appearing on the left hand side of any rule is considered non-terminal.</remarks>
		public string Left { get; set; } = null;
		/// <summary>
		/// Indicates the right hand side of the rule
		/// </summary>
		public IList<string> Right { get; } = new List<string>();
		/// <summary>
		/// Indicates whether the rule is of the form A -> ε
		/// </summary>
		public bool IsNil { get { return 0==Right.Count; } }
		/// <summary>
		/// Provides a string representation of the rule.
		/// </summary>
		/// <returns>A string of the form A -> b C representing the rule.</returns>
		public override string ToString()
		{
			var sb = new StringBuilder();
			sb.Append(Left);
			sb.Append(" ->");
			foreach (var s in Right)
			{
				sb.Append(" ");
				sb.Append(s);
			}
			return sb.ToString();
		}
		/// <summary>
		/// Indicates if the rule takes the form of A -> A ...
		/// </summary>
		public bool IsDirectlyLeftRecursive { get { return !IsNil && Equals(Left, Right[0]); } }
		#region Value Semantics
		/// <summary>
		/// Indicates whether two rules are exactly equivelant.
		/// </summary>
		/// <param name="rhs">The rule to compare this rule to.</param>
		/// <returns>True if the rules are equal, otherwise false.</returns>
		public bool Equals(CfgRule rhs)
		{
			if (!Equals(rhs.Left, Left)) return false;
			var ic = Right.Count;
			if (ic != rhs.Right.Count) return false;
			for(var i = 0;i<ic;++i)
				if (!Equals(Right[i], rhs.Right[i]))
					return false;
			return true;
		}
		/// <summary>
		/// Indicates whether two rules are exactly equivelant.
		/// </summary>
		/// <param name="obj">The rule to compare this rule to.</param>
		/// <returns>True if the rules are equal, otherwise false.</returns>
		public override bool Equals(object obj)
		{
			return Equals(obj as CfgRule);
		}
		/// <summary>
		/// Gets a hashcode for the rule
		/// </summary>
		/// <returns>A hashcode representing this rule</returns>
		public override int GetHashCode()
		{
			var result = 0;
			if (null != Left)
				result = Left.GetHashCode();
			result ^= CollectionUtility.GetHashCode(Right);
			return result;
		}
		/// <summary>
		/// Indicates if the rules are equal
		/// </summary>
		/// <param name="lhs">A rule to compare</param>
		/// <param name="rhs">A rule to compare</param>
		/// <returns>True if the rules are equal, false if they are not equal</returns>
		public static bool operator==(CfgRule lhs,CfgRule rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		/// <summary>
		/// Indicates if the rules are not equal
		/// </summary>
		/// <param name="lhs">A rule to compare</param>
		/// <param name="rhs">A rule to compare</param>
		/// <returns>True if the rules are not equal, false if they are equal</returns>
		public static bool operator !=(CfgRule lhs, CfgRule rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		/// <summary>
		/// Performs a deep clone of the rule
		/// </summary>
		/// <returns>A copy of the rule</returns>
		public CfgRule Clone()
		{
			return new CfgRule(Left,Right);
		}
		object ICloneable.Clone() => Clone();
		#endregion
	}
}
//*** SourceCombiner -> original file CollectionUtility.cs ***
namespace Grimoire
{
#if GRIMOIRELIB
	public
#else
	internal
#endif
	static partial class CollectionUtility
	{
		#region ListDictionary
		/// <summary>
		/// Represents an ordered, unindexed dictionary over a list.
		/// </summary>
		public sealed class ListDictionary<TKey,TValue> : IDictionary<TKey,TValue>,IList<KeyValuePair<TKey,TValue>>
		{
			IList<KeyValuePair<TKey, TValue>> _inner = new List<KeyValuePair<TKey,TValue>>();
			public KeyValuePair<TKey, TValue> this[int index] { get => _inner[index]; set => _inner[index] = value; }
			public TValue this[TKey key] {
				get {
					int c = _inner.Count;
					for(int i =0;i<c;++i)
					{
						var kvp = _inner[i];
						if (kvp.Key.Equals(key))
							return kvp.Value;
					}
					throw new KeyNotFoundException();
				}
				set {
					int c = _inner.Count;
					for (int i = 0; i < c; ++i)
					{
						var kvp = _inner[i];
						if (kvp.Key.Equals(key))
						{
							_inner[i] = new KeyValuePair<TKey, TValue>(key, value);
							break;
						}
					}
					throw new KeyNotFoundException();
				}
			}
			private static void _ThrowReadOnly() { throw new InvalidOperationException("The list is read-only"); }
			public int Count => _inner.Count;
			public bool IsReadOnly => _inner.IsReadOnly;
			public ICollection<TKey> Keys {
				get {
					return _EnumKeys().AsCollection();
				}
			}
			private IEnumerable<TKey> _EnumKeys()
			{
				int c = _inner.Count;
				for(int i =0;i<c;++i)
					yield return _inner[i].Key;
			}
			public ICollection<TValue> Values 
			{
				get {
					return _EnumValues().AsCollection();
				}
			}
			private IEnumerable<TValue> _EnumValues()
			{
				int c = _inner.Count;
				for (int i = 0; i < c; ++i)
					yield return _inner[i].Value;
			}
			public void Add(KeyValuePair<TKey, TValue> item)
			{
				_inner.Add(item);
			}
			public void Add(TKey key, TValue value)
			{
				Add(new KeyValuePair<TKey, TValue>(key, value));
			}
			public void Clear()
			{
				_inner.Clear();
			}
			public bool Contains(KeyValuePair<TKey, TValue> item)
			{
				return _inner.Contains(item);
			}
			public bool ContainsKey(TKey key)
			{
				int c = _inner.Count;
				for (int i = 0; i < c; ++i)
				{
					var kvp = _inner[i];
					if (kvp.Key.Equals(key))
						return true;
				}
				return false;
			}
			public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
			{
				_inner.CopyTo(array, arrayIndex);
			}
			public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			public int IndexOf(KeyValuePair<TKey, TValue> item)
			{
				return _inner.IndexOf(item);
			}
			public void Insert(int index, KeyValuePair<TKey, TValue> item)
			{
				_inner.Insert(index, item);
			}
			public bool Remove(KeyValuePair<TKey, TValue> item)
			{
				return _inner.Remove(item);
			}
			public bool Remove(TKey key)
			{
				int c = _inner.Count;
				for (int i = 0; i < c; ++i)
				{
					var kvp = _inner[i];
					if (kvp.Key.Equals(key))
					{
						_inner.RemoveAt(i);
						return true;
					}
				}
				return false;
			}
			public void RemoveAt(int index)
			{
				_inner.RemoveAt(index);
			}
			public bool TryGetValue(TKey key, out TValue value)
			{
				int c = _inner.Count;
				for (int i = 0; i < c; ++i)
				{
					var kvp = _inner[i];
					if (kvp.Key.Equals(key))
					{
						value = kvp.Value;
						return true;
					}
				}
				value = default(TValue);
				return false;
			}
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		#endregion ListDictionary
		#region CollectionAdapter
		internal sealed class CollectionAdapter : ICollection
		{
			internal CollectionAdapter(IEnumerable inner)
			{
				_inner = inner;
			}
			readonly IEnumerable _inner;
			public int Count { get { return Count(_inner); } }
			public bool IsSynchronized { get { return false; } }
			object ICollection.SyncRoot { get { return this; } }
			public void CopyTo(Array array, int index)
			{
				CollectionUtility.CopyTo(_inner,array, index);
			}
			public IEnumerator GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		internal sealed class CollectionAdapter<T> : ICollection<T>
		{
			internal CollectionAdapter(IEnumerable<T> inner)
			{
				_inner = inner;
			}
			readonly IEnumerable<T> _inner;
			public int Count { get { return Count(_inner); } }
			public bool IsReadOnly { get { return true; } }
			public void CopyTo(T[] array, int index)
			{
				CollectionUtility.CopyTo(_inner, array, index);
			}
			public IEnumerator<T> GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			void ICollection<T>.Add(T item)
			{
				throw new NotSupportedException("The collection is read-only.");
			}
			bool ICollection<T>.Remove(T item)
			{
				throw new NotSupportedException("The collection is read-only.");
			}
			void ICollection<T>.Clear()
			{
				throw new NotSupportedException("The collection is read-only.");
			}
			public bool Contains(T item)
			{
				return Contains<T>(_inner, item);
			}
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		#endregion CollectionAdapter
		#region ListAdapter
		sealed class ListAdapter : IList
		{
			readonly IEnumerable _inner;
			internal ListAdapter(IEnumerable inner)
			{
				_inner = inner;
			}
			static void _ThrowReadOnly()
			{
				throw new NotSupportedException("The list is read only.");
			}
			public object this[int index] { get { return GetAt(_inner, index); } set { _ThrowReadOnly(); } }
			bool IList.IsFixedSize { get { return true; } }
			bool IList.IsReadOnly { get { return true; } }
			public int Count { get { return Count(_inner); } }
			bool ICollection.IsSynchronized { get { return false; } }
			object ICollection.SyncRoot { get { return this; } }
			int IList.Add(object value)
			{
				_ThrowReadOnly();
				return -1;
			}
			void IList.Clear()
			{
				_ThrowReadOnly();
			}
			public bool Contains(object value)
			{
				return _inner.Contains(value);
			}
			public void CopyTo(Array array, int index)
			{
				_inner.CopyTo(array, index);
			}
			public IEnumerator GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			public int IndexOf(object value)
			{
				return _inner.IndexOf(value);
			}
			void IList.Insert(int index, object value)
			{
				_ThrowReadOnly();
			}
			void IList.Remove(object value)
			{
				_ThrowReadOnly();
			}
			void IList.RemoveAt(int index)
			{
				_ThrowReadOnly();
			}
		}
		sealed class ListAdapter<T> : IList<T>
		{
			IEnumerable<T> _inner;
			internal ListAdapter(IEnumerable<T> inner)
			{
				_inner = inner;
			}
			static void _ThrowReadOnly()
			{
				throw new NotSupportedException("The list is read only.");
			}
			public T this[int index] { get { return GetAt(_inner, index); } set { _ThrowReadOnly(); } }
			public int Count { get { return Count(_inner); } }
			bool ICollection<T>.IsReadOnly { get { return true; } }
			void ICollection<T>.Add(T item)
			{
				_ThrowReadOnly();
			}
			void ICollection<T>.Clear()
			{
				_ThrowReadOnly();
			}
			public bool Contains(T item)
			{
				return _inner.Contains(item);
			}
			public void CopyTo(T[] array, int arrayIndex)
			{
				_inner.CopyTo(array, arrayIndex);
			}
			public IEnumerator<T> GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			public int IndexOf(T item)
			{
				return _inner.IndexOf(item);
			}
			void IList<T>.Insert(int index, T item)
			{
				_ThrowReadOnly();
			}
			bool ICollection<T>.Remove(T item)
			{
				_ThrowReadOnly();
				return false;
			}
			void IList<T>.RemoveAt(int index)
			{
				_ThrowReadOnly();
			}
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		#endregion ListAdapter
		#region ReadOnlyAdapter 
		sealed class ReadOnlyCollectionAdapter : ICollection
		{
			internal ReadOnlyCollectionAdapter(ICollection inner)
			{
				_inner = inner;
			}
			readonly ICollection _inner;
			public int Count { get { return _inner.Count; } }
			bool ICollection.IsSynchronized { get { return false; } }
			object ICollection.SyncRoot { get { return this; } }
			public void CopyTo(Array array, int index)
			{
				_inner.CopyTo(array, index);
			}
			public IEnumerator GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		sealed class ReadOnlyCollectionAdapter<T> : ICollection<T>
		{
			static void _ThrowReadOnly()
			{
				throw new NotSupportedException("The collection is read-only.");
			}
			internal ReadOnlyCollectionAdapter(ICollection<T> inner)
			{
				_inner = inner;
			}
			readonly ICollection<T> _inner;
			public int Count { get { return _inner.Count; } }
			public bool IsReadOnly { get { return true; } }
			void ICollection<T>.Add(T item)
			{
				_ThrowReadOnly();
			}
			public void Clear()
			{
				_ThrowReadOnly();
			}
			public bool Contains(T item)
			{
				return _inner.Contains(item);
			}
			public void CopyTo(T[] array, int arrayIndex)
			{
				_inner.CopyTo(array, arrayIndex);
			}
			bool ICollection<T>.Remove(T item)
			{
				_ThrowReadOnly();
				return false;
			}
			public IEnumerator<T> GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		sealed class ReadOnlyListAdapter : IList
		{
			static void _ThrowReadOnly()
			{
				throw new NotSupportedException("The collection is read-only.");
			}
			internal ReadOnlyListAdapter(IList inner)
			{
				_inner = inner;
			}
			readonly IList _inner;
			public object this[int index] { get { return _inner[index]; } set { _ThrowReadOnly(); } }
			public bool IsFixedSize { get { return true; } }
			public bool IsReadOnly { get { return true; } }
			public int Count { get { return _inner.Count; } }
			bool ICollection.IsSynchronized { get { return false; } }
			object ICollection.SyncRoot { get { return this; } }
			int IList.Add(object value)
			{
				_ThrowReadOnly();
				return -1;
			}
			void IList.Clear()
			{
				_ThrowReadOnly();
			}
			public bool Contains(object value)
			{
				return _inner.Contains(value);
			}
			public void CopyTo(Array array, int index)
			{
				_inner.CopyTo(array, index);
			}
			public IEnumerator GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			public int IndexOf(object value)
			{
				return _inner.IndexOf(value);
			}
			void IList.Insert(int index, object value)
			{
				_ThrowReadOnly();
			}
			void IList.Remove(object value)
			{
				_ThrowReadOnly();
			}
			void IList.RemoveAt(int index)
			{
				_ThrowReadOnly();
			}
		}
		sealed class ReadOnlyListAdapter<T> : IList<T>
		{
			static void _ThrowReadOnly()
			{
				throw new NotSupportedException("The collection is read-only.");
			}
			internal ReadOnlyListAdapter(IList<T> inner)
			{
				_inner = inner;
			}
			readonly IList<T> _inner;
			public T this[int index] { get { return _inner[index]; } set { _ThrowReadOnly(); } }
			public int Count { get { return _inner.Count; } }
			public bool IsReadOnly { get { return true; } }
			void ICollection<T>.Add(T item)
			{
				_ThrowReadOnly();
			}
			void ICollection<T>.Clear()
			{
				_ThrowReadOnly();
			}
			public bool Contains(T item)
			{
				return _inner.Contains(item);
			}
			public void CopyTo(T[] array, int arrayIndex)
			{
				_inner.CopyTo(array, arrayIndex);
			}
			public IEnumerator<T> GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
			public int IndexOf(T item)
			{
				return _inner.IndexOf(item);
			}
			void IList<T>.Insert(int index, T item)
			{
				_ThrowReadOnly();
			}
			bool ICollection<T>.Remove(T item)
			{
				_ThrowReadOnly();
				return false;
			}
			void IList<T>.RemoveAt(int index)
			{
				_ThrowReadOnly();
			}
			IEnumerator IEnumerable.GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		#endregion ReadOnlyAdapter
		public static ICollection AsCollection(this IEnumerable collection)
		{
			var result = collection as ICollection;
			if (null != result) return result;
			result = new CollectionAdapter(collection);
			return result;
		}
		public static ICollection<T> AsCollection<T>(this IEnumerable<T> collection)
		{
			var result = collection as ICollection<T>;
			if (null != result) return result;
			result = new CollectionAdapter<T>(collection);
			return result;
		}
		public static IList AsList(this IEnumerable collection)
		{
			var result = collection as IList;
			if (null != result) return result;
			result = new ListAdapter(collection);
			return result;
		}
		public static IList<T> AsList<T>(this IEnumerable<T> collection)
		{
			var result = collection as IList<T>;
			if (null != result) return result;
			result = new ListAdapter<T>(collection);
			return result;
		}
		public static IList AsReadOnly(IList list) { return list.IsReadOnly?list:new ReadOnlyListAdapter(list); }
		public static ICollection AsReadOnly(ICollection collection) { return new ReadOnlyCollectionAdapter(collection); }
		public static IList<T> AsReadOnly<T>(IList<T> list) { return list.IsReadOnly ? list : new ReadOnlyListAdapter<T>(list); }
		public static ICollection<T> AsReadOnly<T>(ICollection<T> collection) { return collection.IsReadOnly? collection:new ReadOnlyCollectionAdapter<T>(collection); }
		/// <summary>
		/// Tests whether the enumeration is null or empty.
		/// </summary>
		/// <param name="collection">The enumeration to test</param>
		/// <returns>True if the enumeration is null, or if enumerating ends before the first element. Otherwise, this method returns true.</returns>
		/// <remarks>For actual collections, testing the "Count" property should be slightly faster.</remarks>
		public static bool IsNullOrEmpty(this IEnumerable collection)
		{
			if (null == collection) return true;
			var e = collection.GetEnumerator();
			try
			{
				return !e.MoveNext();
			}
			finally
			{
				var d = e as IDisposable;
				if (null != d)
				{
					d.Dispose();
					d = null;
				}
				e = null;
			}
		}
		public static object First(this IEnumerable collection)
		{
			var e = collection.GetEnumerator();
			try
			{
				if (e.MoveNext())
					return e.Current;
				else
					throw new ArgumentException("The collection was empty.", "collection");
			}
			finally
			{
				var d = e as IDisposable;
				if (null != d)
				{
					d.Dispose();
					d = null;
				}
				e = null;
			}
		}
		public static bool TryFirst(this IEnumerable collection,out object first)
		{
			var e = collection.GetEnumerator();
			try
			{
				if (e.MoveNext())
				{
					first = e.Current;
					return true;
				}
				first = null;
				return false;
			}
			finally
			{
				var d = e as IDisposable;
				if (null != d)
				{
					d.Dispose();
					d = null;
				}
				e = null;
			}
		}
		public static T First<T>(this IEnumerable<T> collection)
		{
			using (var e = collection.GetEnumerator())
				if (e.MoveNext())
					return e.Current;
				else
					throw new ArgumentException("The collection was empty.", "collection");
		}
		public static bool TryFirst<T>(this IEnumerable<T> collection,out T first)
		{
			using (var e = collection.GetEnumerator())
				if (e.MoveNext())
				{
					first = e.Current;
					return true;
				}
				else
				{
					first = default(T);
					return false;
				}
		}
		public static bool HasSingleItem(this IEnumerable collection)
		{
			var e = collection.GetEnumerator();
			try
			{
				return e.MoveNext() && !e.MoveNext();
			}
			finally
			{
				var d = e as IDisposable;
				if (null != d)
					d.Dispose();
			}
		}
		public static IEnumerable<T> SubRange<T>(this IEnumerable<T> collection,int start=0,int count = 0)
		{
			var i = 0;
			var c = 0;
			foreach (var item in collection)
			{
				if (i >= start)
				{
					yield return item;
					++c;
				}
				if (0 < count && c == count)
					break;
				++i;
			}
			if (i < start)
				throw new ArgumentOutOfRangeException("start");
			if (0 < count && c < count)
				throw new ArgumentOutOfRangeException("count");
		}
		public static bool StartsWith<T>(this IEnumerable<T> collection,IEnumerable<T> values,IEqualityComparer<T> equalityComparer=null)
		{
			if (null == equalityComparer)
				equalityComparer = EqualityComparer<T>.Default;
			using(var x = collection.GetEnumerator())
			{
				using(var y = values.GetEnumerator())
				{
					while(y.MoveNext())
					{
						if (!x.MoveNext())
							return false;
						if (!equalityComparer.Equals(x.Current, y.Current))
							return false;
					}
				}
			}
			return true;
		}
		public static IList<T> GetLongestCommonPrefix<T>(this IEnumerable<IList<T>> ss)
		{
			IList<T> result = null;
			foreach(var list in ss)
			{
				foreach(var list2 in ss)
				{
					if (!ReferenceEquals(list, list2))
					{
						var pfx = GetCommonPrefix<T>(new IList<T>[] { list, list2 });
						if (null == result || (null != pfx && pfx.Count > result.Count))
							result = pfx;
					}
				}
			}
			if (null == result) return new T[0];
			return result;
		}
		public static IList<T> GetCommonPrefix<T>(this IEnumerable<IList<T>> ss)
		{
			// adaptation of solution found here: https://stackoverflow.com/questions/33709165/get-common-prefix-of-two-string
			if (ss.IsNullOrEmpty())
				return new T[0];
			var first = ss.First();
			if (ss.HasSingleItem())
				return first;
			int prefixLength = 0;
			foreach (object item in ss.First())
			{
				foreach (IList<T> s in ss)
				{
					if (s.Count <= prefixLength || !Equals(s[prefixLength], item))
					{
						var result = new T[prefixLength];
						for (var i = 0; i < result.Length; i++)
							result[i] = first[i];
						return result;
					}
				}
				++prefixLength;
			}
			return first; // all strings identical up to length of ss[0]
		}
		/// <summary>
		/// Attempts to add a unique item to a collection.
		/// </summary>
		/// <typeparam name="T">The element type of the collection and type of the item to add</typeparam>
		/// <param name="collection">The collection to add the item to</param>
		/// <param name="item">The item to add to the collection</param>
		/// <returns>True if the item was added, false if it already exists.</returns>
		public static bool TryAddUnique<T>(this ICollection<T> collection, T item)
		{
			if (null == collection)
				throw new ArgumentNullException("collection");
			if (!collection.Contains(item))
			{
				collection.Add(item);
				return true;
			}
			return false;
		}
		public static void AddRange<T>(this ICollection<T> collection,IEnumerable<T> values)
		{
			foreach (var item in values)
				collection.Add(item);
		}
		/// <summary>
		/// Creates an array of element type T from the items in the specified source collection, also of type T
		/// </summary>
		/// <typeparam name="T">The element type of the array and the collection</typeparam>
		/// <param name="source">The source collection</param>
		/// <returns>A new array with the values copied from the source.</returns>
		public static T[] ToArray<T>(this ICollection<T> source) {
			var arr = source as T[];
			if (null != arr) return arr;
			var result = new T[source.Count];
			source.CopyTo(result, 0);
			return result;
		}
		/// <summary>
		/// Creates an array of element type T from the items in the specified source enumeration, also of type T
		/// </summary>
		/// <typeparam name="T">The element type of the array and the enumeration</typeparam>
		/// <param name="source">The source enumeration</param>
		/// <returns>A new array with the values copied from the source.</returns>
		public static T[] ToArray<T>(this IEnumerable<T> source)
		{
			var arr = source as T[];
			if (null != arr) return arr;
			var result = new List<T>(source);
			return result.ToArray();
		}
		public static Array ToArray(this ICollection source,Type elementType)
		{
			var al = new ArrayList(source);
			return al.ToArray(elementType);
		}
		public static object[] ToArray(this ICollection source)
		{
			var al = new ArrayList(source);
			return al.ToArray();
		}
		public static Array ToArray(this IEnumerable source, Type elementType)
		{
			var al = new ArrayList();
			foreach(object o in source)
				al.Add(o);
			return al.ToArray(elementType);
		}
		public static object[] ToArray(this IEnumerable source)
		{
			var al = new ArrayList();
			foreach (object o in source)
				al.Add(o);
			return al.ToArray();
		}
		/// <summary>
		/// Copies an enumeration of type T to the specified array of type T, starting at the specified start index.
		/// </summary>
		/// <typeparam name="T">The element type of the array and enumeration</typeparam>
		/// <param name="source">The enumeration to copy from</param>
		/// <param name="destination">The array to copy to</param>
		/// <param name="destinationStartIndex">The start index at which copying begins</param>
		/// <returns>The count of items copied. This will be the same as the number of items in the enumeration.</returns>
		public static int CopyTo<T>(this IEnumerable<T> source,T[] destination,int destinationStartIndex)
		{
			if (null == source)
				throw new ArgumentNullException("value");
			if (null == destination)
				throw new ArgumentNullException("array");
			if (destinationStartIndex < destination.GetLowerBound(0) || destinationStartIndex > destination.GetUpperBound(0))
				throw new ArgumentOutOfRangeException("startIndex");
			int i = destinationStartIndex;
			foreach(T v in source)
			{
				destination[i] = v;
				++i;
			}
			return i;
		}
		/// <summary>
		/// Copies an enumeration to the specified array, starting at the specified start index.
		/// </summary>
		/// <param name="source">The enumeration to copy from</param>
		/// <param name="destination">The array to copy to</param>
		/// <param name="destinationStartIndex">The start index at which copying begins</param>
		/// <returns>The count of items copied. This will be the same as the number of items in the enumeration.</returns>
		public static int CopyTo(this IEnumerable source, Array destination, int destinationStartIndex)
		{
			if (null == source)
				throw new ArgumentNullException("value");
			if (null == destination)
				throw new ArgumentNullException("array");
			if (destinationStartIndex < destination.GetLowerBound(0) || destinationStartIndex > destination.GetUpperBound(0))
				throw new ArgumentOutOfRangeException("startIndex");
			int i = destinationStartIndex;
			foreach (object v in source)
			{
				destination.SetValue(v, i);
				++i;
			}
			return i;
		}
		public static IEnumerable<T> Cast<T>(this IEnumerable collection)
		{
			foreach(object o in collection)
			{
				yield return (T)o;
			}
		}
		public static IEnumerable<T> Convert<T>(this IEnumerable collection)
		{
			Type t = typeof(T);
			foreach (object o in collection)
			{
				yield return (T)System.Convert.ChangeType(o, t);
			}
		}
		public static int IndexOf(this IEnumerable collection, object item)
		{
			int result = 0;
			foreach (object cmp in collection)
			{
				if (Equals(item, cmp))
					return result;
				++result;
			}
			return -1;
		}
		public static int IndexOf(this IEnumerable collection, object item,IEqualityComparer comparer)
		{
			if (null == comparer)
				return IndexOf(collection, item);
			int result = 0;
			foreach (object cmp in collection)
			{
				if (comparer.Equals(item, cmp))
					return result;
				++result;
			}
			return -1;
		}
		public static int IndexOf<T>(this IEnumerable<T> collection, T item)
		{
			int result = 0;
			foreach(T cmp in collection)
			{
				if (Equals(item, cmp))
					return result;
				++result;
			}
			return -1;
		}
		public static int IndexOf<T>(this IEnumerable<T> collection, T item,IEqualityComparer<T> comparer)
		{
			if (null == comparer)
				return IndexOf(collection, item);
			int result = 0;
			foreach (T cmp in collection)
			{
				if (comparer.Equals(item, cmp))
					return result;
				++result;
			}
			return -1;
		}
		public static IEnumerable<TOutput> ForEach<TInput, TOutput>(this IEnumerable<TInput> collection, Func<TInput, TOutput> @do)
		{
			foreach (var item in collection)
				yield return @do(item);
		}
		public static IEnumerable<T> ForEach<T>(this IEnumerable<T> collection, Func<T, T> @do)
		{
			foreach (var item in collection)
				yield return @do(item);
		}
		public static IEnumerable<TOut> ForEachTransform<TIn,TOut>(this IEnumerable<TIn> collection, Func<TIn, TOut> @do)
		{
			foreach (var item in collection)
				yield return @do(item);
		}
		public static IEnumerable<T> Select<T>(this IEnumerable<T> axis, Func<T,bool> predicate)
		{
			foreach (var item in axis)
				if (predicate(item))
					yield return item;
		}
		public static IEnumerable<T> Unique<T>(this IEnumerable<T> collection)
		{
			var seen = new HashSet<T>();
			foreach(var item in collection)
				if (seen.Add(item))
					yield return item;
			seen.Clear();
		}
		public static bool Contains(this IEnumerable collection, object item)
		{
			foreach (object cmp in collection)
				if (Equals(item, cmp))
					return true;
			return false;
		}
		public static bool Contains(this IEnumerable collection, object item,IEqualityComparer comparer)
		{
			if (null == comparer)
				return Contains(collection, item);
			foreach (object cmp in collection)
				if (comparer.Equals(item, cmp))
					return true;
			return false;
		}
		public static bool Contains<T>(this IEnumerable<T> collection, T item)
		{
			foreach (T cmp in collection)
				if (Equals(item, cmp))
					return true;
			return false;
		}
		public static bool Contains<T>(this IEnumerable<T> collection, T item,IEqualityComparer<T> comparer)
		{
			if (null == comparer)
				return Contains(collection, item);
			foreach (T cmp in collection)
				if (comparer.Equals(item,cmp))
					return true;
			return false;
		}
		public static int Count(this IEnumerable collection)
		{
			IEnumerator e = collection.GetEnumerator();
			try
			{
				int result = 0;
				while (e.MoveNext())
					++result;
				return result;
			}
			finally
			{
				var d = e as IDisposable;
				if (null != d)
				{
					d.Dispose();
					d = null;
				}
				e = null;
			}
		}
		public static int MoveNext(this IEnumerator enumerator, int count)
		{
			try
			{
				int result = 0;
				while (result<count && enumerator.MoveNext())
					++result;
				return result;
			}
			finally
			{
				var d = enumerator as IDisposable;
				if (null != d)
				{
					d.Dispose();
					d = null;
				}
				enumerator = null;
			}
		}
		public static object GetAt(this IEnumerable collection, int index)
		{
			var e = collection.GetEnumerator();
			try
			{
				int i = -1;
				while (i < index && e.MoveNext())
					++i;
				if(i<index)
					throw new ArgumentOutOfRangeException("index");
				return e.Current;
			}
			finally
			{
				var d = e as IDisposable;
				if (null != d)
				{
					d.Dispose();
					d = null;
				}
				e = null;
			}
		}
		public static T GetAt<T>(this IEnumerable<T> collection, int index)
		{
			using (var e = collection.GetEnumerator())
			{
				int i = -1;
				while (i < index && e.MoveNext())
					++i;
				if(i<index)
					throw new ArgumentOutOfRangeException("index");
				return e.Current;
			}		
		}
		public static IEnumerable GetKeys(this IEnumerable collection)
		{
			foreach (DictionaryEntry de in collection)
				yield return de.Key;
		}
		public static IEnumerable GetValues(this IEnumerable collection)
		{
			foreach (DictionaryEntry de in collection)
				yield return de.Value;
		}
		public static IEnumerable<TKey> GetKeys<TKey,TValue>(this IEnumerable<KeyValuePair<TKey,TValue>> collection)
		{
			foreach (var kvp in collection)
				yield return kvp.Key;
		}
		public static IEnumerable<TValue> GetValues<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> collection)
		{
			foreach (var kvp in collection)
				yield return kvp.Value;
		}
		public static IEnumerable<T> NonNulls<T>(this IEnumerable<T> collection)
		{
			foreach (var item in collection)
				if (null != item)
					yield return item;
		}
		public static IEnumerable NonNulls(this IEnumerable collection)
		{
			foreach (var item in collection)
				if (null != item)
					yield return item;
		}
		public static IEnumerable<Type> GetTypes(this IEnumerable collection)
		{
			foreach (var item in collection)
				if (null != item)
					yield return item.GetType();
				else
					yield return null;
		}
		public static Type InferElementType(this IEnumerable items)
		{
			Type result = _GetCommonType(NonNulls(GetTypes(items)));
			if(typeof(object)!=result && Contains(items,null))
			{
				if (result.IsValueType)
					result = typeof(object);
			}
			return result;
		}
		static Type _GetCommonType(IEnumerable<Type> types)
		{
			// based on a solution @ https://stackoverflow.com/questions/353430/easiest-way-to-get-a-common-base-class-from-a-collection-of-types
			List<Type> temp = new List<Type>(types);
			if (0==temp.Count)
				return (typeof(object));
			else if (1==temp.Count)
				return (temp[0]);
			bool checkPass = false;
			Type tested = null;
			while (!checkPass)
			{
				tested = temp[0];
				checkPass = true;
				for (int i = 1; i < temp.Count; i++)
				{
					if (tested.Equals(temp[i]))
						continue;
					else
					{
						// If the tested common basetype (current) is the indexed type's base type
						// then we can continue with the test by making the indexed type to be its base type
						if (tested.Equals(temp[i].BaseType))
						{
							temp[i] = temp[i].BaseType;
							continue;
						}
						// If the tested type is the indexed type's base type, then we need to change all indexed types
						// before the current type (which are all identical) to be that base type and restart this loop
						else if (tested.BaseType.Equals(temp[i]))
						{
							for (int j = 0; j <= i - 1; j++)
							{
								temp[j] = temp[j].BaseType;
							}
							checkPass = false;
							break;
						}
						// The indexed type and the tested type are not related
						// So make everything from index 0 up to and including the current indexed type to be their base type
						// because the common base type must be further back
						else
						{
							for (int j = 0; j <= i; j++)
							{
								temp[j] = temp[j].BaseType;
							}
							checkPass = false;
							break;
						}
					}
				}
				// If execution has reached here and checkPass is true, we have found our common base type, 
				// if checkPass is false, the process starts over with the modified types
			}
			// There's always at least object
			return tested;
		}
		public static bool Equals<T>(this IList<T> lhs,IList<T> rhs)
		{
			if (object.ReferenceEquals(lhs, rhs))
				return true;
			else if (object.ReferenceEquals(null, lhs) || object.ReferenceEquals(null,rhs))
				return false;
			int c = lhs.Count;
			if (c != rhs.Count) return false;
			for(int i = 0;i<c;++i)
				if (!object.Equals(lhs[i] , rhs[i]))
					return false;
			return true;
		}
		public static bool Equals<T>(this ICollection<T> lhs, ICollection<T> rhs)
		{
			if (ReferenceEquals(lhs, rhs))
				return true;
			else if (ReferenceEquals(null, lhs) || ReferenceEquals(null, rhs))
				return false;
			if (lhs.Count != rhs.Count)
				return false;
			using (var xe = lhs.GetEnumerator())
			using (var ye = rhs.GetEnumerator())
				while (xe.MoveNext() && ye.MoveNext())
					if (!rhs.Contains(xe.Current) || !lhs.Contains(ye.Current))
						return false;
			return true;
		}
		public static bool Equals<TKey,TValue>(this ICollection<KeyValuePair<TKey, TValue>> lhs, ICollection<KeyValuePair<TKey, TValue>> rhs)
		{
			if (ReferenceEquals(lhs, rhs))
				return true;
			else if (ReferenceEquals(null, lhs) || ReferenceEquals(null, rhs))
				return false;
			if (lhs.Count != rhs.Count)
				return false;
			using (var xe = lhs.GetEnumerator())
			using (var ye = rhs.GetEnumerator())
				while (xe.MoveNext() && ye.MoveNext())
					if (!rhs.Contains(xe.Current) || !lhs.Contains(ye.Current))
						return false;
			return true;
		}
		public static int GetHashCode<T>(this IEnumerable<T> collection)
		{
			int result = 0;
			if (!ReferenceEquals(null, collection))
			{
				foreach (T o in collection)
				{
					if (!ReferenceEquals(null, o))
					{
						result ^= o.GetHashCode();
					}
				}
			}
			return result;
		}
		public static int GetHashCode<T>(this IList<T> lhs)
		{
			if (object.ReferenceEquals(null,lhs))
				return int.MinValue;
			int result = 0;
			int c = lhs.Count;
			for (int i = 0; i < c; ++i)
				if (!object.ReferenceEquals(null, lhs[i]))
					result ^= lhs[i].GetHashCode();
			return result;
		}
		public static IEnumerable Concat(this IEnumerable lhs, IEnumerable rhs)
		{
			foreach (var v in lhs)
				yield return v;
			foreach (var v in rhs)
				yield return v;
		}
		public static IEnumerable<T> Concat<T>(this IEnumerable<T> lhs, IEnumerable<T> rhs)
		{
			foreach (var v in lhs)
				yield return v;
			foreach (var v in rhs)
				yield return v;
		}
		public static IEnumerable<T> Union<T>(this IEnumerable<T> lhs,IEnumerable<T> rhs)
		{
			return Unique(Concat(lhs, rhs));
		}
		public static TValue TryGetValue<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, TValue @default=default(TValue))
		{
			TValue result;
			if (dictionary.TryGetValue(key, out result))
				return result;
			return @default;
		}
		public static string ToString(this IEnumerable e)
		{
			var sb = new StringBuilder();
			sb.Append("{ ");
			var d = "";
			bool appended = false;
			foreach(var i in e)
			{
				sb.Append(d);
				sb.Append(i);
				d = ", ";
				appended = true;
			}
			if (appended)
				sb.Append(" }");
			else
				sb.Append("}");
			return sb.ToString();
		} 
		public static IEnumerable<IList<T>> Split<T>(this IEnumerable<T> collection,T delim,IEqualityComparer<T> equalityComparer = null)
		{
			if (null == equalityComparer)
				equalityComparer = EqualityComparer<T>.Default;
			if (collection.IsNullOrEmpty())
				yield break;
			var l = new List<T>();
			foreach (var item in collection)
			{
				if(!equalityComparer.Equals(item,delim))
				{
					l.Add(item);
				} else
				{
					yield return l;
					l = new List<T>();
				}
			}
			yield return l;
		}
		public static IEnumerable<T> Join<T>(this IEnumerable<IList<T>> segments, IEnumerable<T> delim)
		{
			if (IsNullOrEmpty(delim))
			{
				foreach (var l in segments)
				{
					var ic = l.Count;
					for (var i = 0; i < ic; ++i)
						yield return l[i];
				}
				yield break;
			}
			var first = true;
			foreach(var l in segments)
			{
				if (first)
					first = false;
				else
					foreach (var i in delim)
						yield return i;
				var ic = l.Count;
				for (var i = 0; i < ic; ++i)
					yield return l[i];
			}
		}
		public static IEnumerable<T> Replace<T>(this IEnumerable<T> collection,T oldValue, IEnumerable<T> newValues, IEqualityComparer<T> equalityComparer = null)
		{
			return Join(Split(collection, oldValue,equalityComparer), newValues);
		}
	}
}
//*** SourceCombiner -> original file CSharpUtility.cs ***
namespace Grimoire
{
	// TODO: Test unicode support - easiest to test using Regex codegen + "." regex
	static partial class CSharpUtility
	{
		public static void WriteCSharpLiteralTo(TextWriter writer, object val)
		{
			if (null == val)
			{
				writer.Write("null");
				return;
			}
			if (val is bool)
			{
				writer.Write(((bool)val) ? "true" : "false");
				return;
			}
			if (val is string)
			{
				WriteCSharpStringTo(writer, (string)val);
				return;
			}
			if (val is Array && 1 == ((Array)val).Rank && 0 == ((Array)val).GetLowerBound(0))
			{
				WriteCSharpArrayTo(writer, (Array)val);
				return;
			}
			if (val is char)
			{
				WriteCSharpCharTo(writer, (char)val);
				return;
			}
			if (val is short || val is ushort || val is int || val is uint || val is ulong || val is long || val is byte || val is sbyte || val is float || val is double || val is decimal)
			{
				writer.Write(val);
				return;
			}
			var conv = TypeDescriptor.GetConverter(val);
			if(null!=conv)
			{
				if(conv.CanConvertTo(typeof(InstanceDescriptor)))
				{
					var desc = conv.ConvertTo(val, typeof(InstanceDescriptor)) as InstanceDescriptor;
					if (!desc.IsComplete)
						throw new NotSupportedException(string.Format("The type \"{0}\" could not be serialized.", val.GetType().FullName));
					var ctor = desc.MemberInfo as ConstructorInfo;
					if (null != ctor)
					{
						writer.Write(string.Concat("new ", ctor.DeclaringType.FullName, "("));
						var delim = "";
						foreach (var arg in desc.Arguments)
						{
							writer.Write(delim);
							WriteCSharpLiteralTo(writer, arg);
							delim = ", ";
						}
						writer.Write(")");
					}
					else
						throw new NotSupportedException(string.Format("The instance descriptor for type \"{0}\" is not supported.", val.GetType().FullName));
				} else
					throw new NotSupportedException(string.Format("The type \"{0}\" could not be serialized.", val.GetType().FullName));
			} else
				throw new NotSupportedException(string.Format("The type \"{0}\" could not be serialized.", val.GetType().FullName));
		}
		public static void WriteCSharpStringTo(TextWriter writer, string str)
		{
			writer.Write("\"");
			for (int i = 0; i < str.Length; ++i)
				_WriteCSharpCharPartTo(writer, str[i]);
			writer.Write("\"");
		}
		public static void WriteCSharpCharTo(TextWriter writer, char ch)
		{
			writer.Write("\'");
			_WriteCSharpCharPartTo(writer, ch);
			writer.Write("\'");
		}
		public static void WriteCSharpArrayTo(TextWriter writer, Array arr)
		{
			if (1 == arr.Rank && 0 == arr.GetLowerBound(0))
			{
				writer.Write(string.Concat("new ", arr.GetType().GetElementType().FullName, "[] {"));
				var delim = " ";
				var i = 0;
				foreach (var elem in arr)
				{
					writer.Write(delim);
					WriteCSharpLiteralTo(writer, elem);
					if(50==i)
					{
						i = 0;
						writer.WriteLine();
						writer.Write("\t");
					}
					delim = ", ";
					++i;
				}
				writer.Write(" }");
				return;
			}
			throw new NotSupportedException("Only SZArrays can be serialized to code.");
		}
		static void _WriteCSharpCharPartTo(TextWriter writer, char ch)
		{
			switch (ch)
			{
				case '\'':
				case '\"':
				case '\\':
					writer.Write('\\');
					writer.Write(ch);
					return;
				case '\t':
					writer.Write("\\t");
					return;
				case '\n':
					writer.Write("\\n");
					return;
				case '\r':
					writer.Write("\\r");
					return;
				case '\0':
					writer.Write("\\0");
					return;
				case '\f':
					writer.Write("\\f");
					return;
				case '\v':
					writer.Write("\\v");
					return;
				case '\b':
					writer.Write("\\b");
					return;
				case '\a':
					writer.Write("\\a");
					return;
				case '\u2028':
				case '\u2029':
				case '\u0084':
				case '\u0085':
					writer.Write("\\u");
					writer.Write(unchecked((ushort)ch).ToString("x4"));
					break;
				default:
					if (char.IsControl(ch) || char.IsSurrogate(ch) || char.IsWhiteSpace(ch))
					{
						if (ch <= byte.MaxValue)
						{
							writer.Write("\\x");
							writer.Write(unchecked((byte)ch).ToString("x2"));
						}
						else
						{
							writer.Write("\\u");
							writer.Write(unchecked((ushort)ch).ToString("x4"));
						}
					}
					else
						writer.Write(ch);
					break;
			}
		}
		public static bool IsKeyword(string value)
		{
			return _FixedStringLookup(keywords, value);
		}
		public static string CreateEscapedIdentifier(string identifier)
		{
			if (IsKeyword(identifier) || _IsPrefixTwoUnderscore(identifier))
			{
				return "@" + identifier;
			}
			return identifier;
		}
		static bool _IsPrefixTwoUnderscore(string value)
		{
			if (value.Length < 3)
			{
				return false;
			}
			else
			{
				return ((value[0] == '_') && (value[1] == '_') && (value[2] != '_'));
			}
		}
		#region Lookup Tables
		// from microsoft's reference implementation of the c# code dom provider
		// This routine finds a hit within a single sorted array, with the assumption that the
		// value and all the strings are of the same length.
		private static bool _FixedStringLookupContains(string[] array, string value)
		{
			int min = 0;
			int max = array.Length;
			int pos = 0;
			char searchChar;
			while (pos < value.Length)
			{
				searchChar = value[pos];
				if ((max - min) <= 1)
				{
					// we are down to a single item, so we can stay on this row until the end.
					if (searchChar != array[min][pos])
					{
						return false;
					}
					pos++;
					continue;
				}
				// There are multiple items to search, use binary search to find one of the hits
				if (!_FindCharacter(array, searchChar, pos, ref min, ref max))
				{
					return false;
				}
				// and move to next char
				pos++;
			}
			return true;
		}
		// Do a binary search on the character array at the specific position and constrict the ranges appropriately.
		static bool _FindCharacter(string[] array, char value, int pos, ref int min, ref int max)
		{
			int index = min;
			while (min < max)
			{
				index = (min + max) / 2;
				char comp = array[index][pos];
				if (value == comp)
				{
					// We have a match. Now adjust to any adjacent matches
					int newMin = index;
					while (newMin > min && array[newMin - 1][pos] == value)
					{
						newMin--;
					}
					min = newMin;
					int newMax = index + 1;
					while (newMax < max && array[newMax][pos] == value)
					{
						newMax++;
					}
					max = newMax;
					return true;
				}
				if (value < comp)
				{
					max = index;
				}
				else
				{
					min = index + 1;
				}
			}
			return false;
		}
		internal static bool _FixedStringLookup(string[][] lookupTable, string value)
		{
			int length = value.Length;
			if (length <= 0 || length - 1 >= lookupTable.Length)
			{
				return false;
			}
			string[] subArray = lookupTable[length - 1];
			if (subArray == null)
			{
				return false;
			}
			return _FixedStringLookupContains(subArray, value);
		}
		static readonly string[][] keywords = new string[][] {
			null,           // 1 character
            new string[] {  // 2 characters
                "as",
				"do",
				"if",
				"in",
				"is",
			},
			new string[] {  // 3 characters
                "for",
				"int",
				"new",
				"out",
				"ref",
				"try",
			},
			new string[] {  // 4 characters
                "base",
				"bool",
				"byte",
				"case",
				"char",
				"else",
				"enum",
				"goto",
				"lock",
				"long",
				"null",
				"this",
				"true",
				"uint",
				"void",
			},
			new string[] {  // 5 characters
                "break",
				"catch",
				"class",
				"const",
				"event",
				"false",
				"fixed",
				"float",
				"sbyte",
				"short",
				"throw",
				"ulong",
				"using",
				"while",
			},
			new string[] {  // 6 characters
                "double",
				"extern",
				"object",
				"params",
				"public",
				"return",
				"sealed",
				"sizeof",
				"static",
				"string",
				"struct",
				"switch",
				"typeof",
				"unsafe",
				"ushort",
			},
			new string[] {  // 7 characters
                "checked",
				"decimal",
				"default",
				"finally",
				"foreach",
				"private",
				"virtual",
			},
			new string[] {  // 8 characters
                "abstract",
				"continue",
				"delegate",
				"explicit",
				"implicit",
				"internal",
				"operator",
				"override",
				"readonly",
				"volatile",
			},
			new string[] {  // 9 characters
                "__arglist",
				"__makeref",
				"__reftype",
				"interface",
				"namespace",
				"protected",
				"unchecked",
			},
			new string[] {  // 10 characters
                "__refvalue",
				"stackalloc",
			},
		};
		#endregion
	}
}
//*** SourceCombiner -> original file EbnfBinaryExpression.cs ***
namespace Grimoire
{

	abstract class EbnfBinaryExpression :EbnfExpression
	{
		public EbnfExpression Left { get; set; } = null;
		public EbnfExpression Right { get; set; } = null;
	}
}
//*** SourceCombiner -> original file EbnfClassifier.cs ***
namespace Grimoire
{
	/// <summary>
	/// Classifier that classifies all text as an instance of the "EbnfClassifier" classification type.
	/// </summary>
	internal class EbnfClassifier : IClassifier
	{
		/// <summary>
		/// Classification type.
		/// </summary>
		private readonly IClassificationType classificationType;
		/// <summary>
		/// Initializes a new instance of the <see cref="EbnfClassifier"/> class.
		/// </summary>
		/// <param name="registry">Classification registry.</param>
		internal EbnfClassifier(IClassificationTypeRegistryService registry)
		{
			this.classificationType = registry.GetClassificationType("EbnfClassifier");
		}
		#region IClassifier
#pragma warning disable 67
		/// <summary>
		/// An event that occurs when the classification of a span of text has changed.
		/// </summary>
		/// <remarks>
		/// This event gets raised if a non-text change would affect the classification in some way,
		/// for example typing /* would cause the classification to change in C# without directly
		/// affecting the span.
		/// </remarks>
		public event EventHandler<ClassificationChangedEventArgs> ClassificationChanged;
#pragma warning restore 67
		/// <summary>
		/// Gets all the <see cref="ClassificationSpan"/> objects that intersect with the given range of text.
		/// </summary>
		/// <remarks>
		/// This method scans the given SnapshotSpan for potential matches for this classification.
		/// In this instance, it classifies everything and returns each span as a new ClassificationSpan.
		/// </remarks>
		/// <param name="span">The span currently being classified.</param>
		/// <returns>A list of ClassificationSpans that represent spans identified to be of this classification.</returns>
		public IList<ClassificationSpan> GetClassificationSpans(SnapshotSpan span)
		{
			var result = new List<ClassificationSpan>()
			{
				new ClassificationSpan(new SnapshotSpan(span.Snapshot, new Span(span.Start, span.Length)), this.classificationType)
			};
			return result;
		}
		#endregion
	}
}
//*** SourceCombiner -> original file EbnfClassifierClassificationDefinition.cs ***
namespace Grimoire
{
	/// <summary>
	/// Classification type definition export for EbnfClassifier
	/// </summary>
	internal static class EbnfClassifierClassificationDefinition
	{
		// This disables "The field is never used" compiler's warning. Justification: the field is used by MEF.
#pragma warning disable 169
		/// <summary>
		/// Defines the "EbnfClassifier" classification type.
		/// </summary>
		[Export(typeof(ClassificationTypeDefinition))]
		[Name("EbnfClassifier")]
		private static ClassificationTypeDefinition typeDefinition;
		#region Constants
		/// <summary>
		/// The name of the content type for the "Colorful" language.
		/// </summary>
		internal const string ContentType = "Newt.Ebnf";
		/// <summary>
		/// The file extension for files containing the "Colorful" language.
		/// </summary>
		internal const string FileExtension = ".ebnf";
		#endregion // Constants
		#region Managed Extensibility Framework (MEF) Fields
		/// <summary>
		/// The content type definition for the "Colorful" language, which is based on
		/// the pre-defined Visual Studio content type "code".
		/// </summary>
		[Export]
		[Name(ContentType)]
		[BaseDefinition("code")]
		internal static ContentTypeDefinition ContentTypeDefinition = null;
		/// <summary>
		/// The mapping of the ".ebnf" file extension to the content type definition for the "EBNF" language.
		/// </summary>
		[Export]
		[Name(ContentType + nameof(FileExtensionToContentTypeDefinition))]
		[ContentType(ContentType)]
		[FileExtension(FileExtension)]
		internal static FileExtensionToContentTypeDefinition FileExtensionToContentTypeDefinition = null;
		#endregion // Managed Extensibility Framework (MEF) Fields
#pragma warning restore 169
	}
}
//*** SourceCombiner -> original file EbnfClassifierFormat.cs ***
namespace Grimoire
{
	/// <summary>
	/// Defines an editor format for the EbnfClassifier type that has a purple background
	/// and is underlined.
	/// </summary>
	[Export(typeof(EditorFormatDefinition))]
	[ClassificationType(ClassificationTypeNames = "EbnfClassifier")]
	[Name("EbnfClassifier")]
	[UserVisible(true)] // This should be visible to the end user
	[Order(Before = Priority.Default)] // Set the priority to be after the default classifiers
	internal sealed class EbnfClassifierFormat : ClassificationFormatDefinition
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="EbnfClassifierFormat"/> class.
		/// </summary>
		public EbnfClassifierFormat()
		{
			this.DisplayName = "EbnfClassifier"; // Human readable version of the name
			this.BackgroundColor = Colors.BlueViolet;
			this.TextDecorations = System.Windows.TextDecorations.Underline;
		}
	}
}
//*** SourceCombiner -> original file EbnfClassifierProvider.cs ***
namespace Grimoire
{
	/// <summary>
	/// Classifier provider. It adds the classifier to the set of classifiers.
	/// </summary>
	[Export(typeof(IClassifierProvider))]
	[ContentType("text")] // This classifier applies to all text files.
	internal class EbnfClassifierProvider : IClassifierProvider
	{
		// Disable "Field is never assigned to..." compiler's warning. Justification: the field is assigned by MEF.
#pragma warning disable 649
		/// <summary>
		/// Classification registry to be used for getting a reference
		/// to the custom classification type later.
		/// </summary>
		[Import]
		private IClassificationTypeRegistryService classificationRegistry;
#pragma warning restore 649
		#region IClassifierProvider
		/// <summary>
		/// Gets a classifier for the given text buffer.
		/// </summary>
		/// <param name="buffer">The <see cref="ITextBuffer"/> to classify.</param>
		/// <returns>A classifier for the text buffer, or null if the provider cannot do so in its current state.</returns>
		public IClassifier GetClassifier(ITextBuffer buffer)
		{
			return buffer.Properties.GetOrCreateSingletonProperty<EbnfClassifier>(creator: () => new EbnfClassifier(this.classificationRegistry));
		}
		#endregion
	}
}
//*** SourceCombiner -> original file EbnfConcatExpression.cs ***
namespace Grimoire
{

	class EbnfConcatExpression : EbnfBinaryExpression,IEquatable<EbnfConcatExpression>, ICloneable
	{
		public EbnfConcatExpression(EbnfExpression left,params EbnfExpression[] right)
		{
			if (null == right) right = new EbnfExpression[] { null };
			Left = left;
			for(var i = 0;i<right.Length;++i)
			{
				if (Right == null)
					Right = right[i];
				else
					Right = new EbnfConcatExpression(Right, right[i]);
			}
		}
		public EbnfConcatExpression() { }
		public override bool IsTerminal => false;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			var l = new List<IList<string>>();
			if(null==Right)
			{
				if (null == Left) return l;
				foreach(var ll in Left.ToDisjunctions(parent,cfg))
					l.Add(new List<string>(ll));
				return l;
			} else if(null==Left)
			{
				foreach (var ll in Right.ToDisjunctions(parent,cfg))
					l.Add(new List<string>(ll));
				return l;
			}
			foreach(var ll in Left.ToDisjunctions(parent,cfg)) { 
				foreach(var ll2 in Right.ToDisjunctions(parent,cfg))
				{
					var ll3 = new List<string>();
					ll3.AddRange(ll);
					ll3.AddRange(ll2);
					if (!l.Contains(ll3, OrderedCollectionEqualityComparer<string>.Default))
						l.Add(ll3);
				}
			}
			return l;
		}
		public EbnfConcatExpression Clone()
		{
			var result = new EbnfConcatExpression(null != Left ? ((ICloneable)Left).Clone() as EbnfExpression : null, null != Right ? ((ICloneable)Right).Clone() as EbnfExpression : null);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfConcatExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Left, rhs.Left) && Equals(Right,rhs.Right);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfConcatExpression);
		public override int GetHashCode()
		{
			var result = 0;
			if (null != Left) result =Left.GetHashCode();
			if (null != Right) result ^= Right.GetHashCode();
			return result;
		}
		public static bool operator ==(EbnfConcatExpression lhs, EbnfConcatExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfConcatExpression lhs, EbnfConcatExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			if (null == Left) return (null != Right) ? Right.ToString() : "";
			if (null == Right) return Left.ToString();
			string l, r;
			var o = Left as EbnfOrExpression;
			if (null != o)
				l = string.Concat("( ", o.ToString(), " )");
			else
				l = Left.ToString();
			o = Right as EbnfOrExpression;
			if (null != o)
				r = string.Concat("( ", o.ToString(), " )");
			else
				r = Right.ToString();
			return string.Concat(l, " ", r);
		}
	}
}
//*** SourceCombiner -> original file EbnfDocument.cs ***
//#define PARSER
namespace Grimoire
{
	/// <summary>
	/// Represents an EBNF grammar document
	/// </summary>
	/// <remarks>This class implements value semantics.</remarks>

	class EbnfDocument : IEquatable<EbnfDocument>,ICloneable
	{
		/// <summary>
		/// Indicates the productions in the EBNF grammar document
		/// </summary>
		public IDictionary<string, EbnfProduction> Productions { get; } = new ListDictionary<string, EbnfProduction>();
		/// <summary>
		/// Gets or sets the starting production of the grammar document
		/// </summary>
		/// <remarks>This property employs the "start" grammar attribute.</remarks>
		public string StartProduction {
			get {
				foreach(var prod in Productions)
				{
					object b;
					if (prod.Value.Attributes.TryGetValue("start", out b) && b is bool && (bool)b)
						return prod.Key;
				}
				return Productions.First().Key;
			}
			set {
				if(!Productions.ContainsKey(value))
					throw new ArgumentException("The value must be a non-terminal and present in the grammar.");
				foreach (var prod in Productions)
					if (Equals(value, prod.Key))
						prod.Value.Attributes["start"] = true;
					else
						prod.Value.Attributes.Remove("start");
			}
		}
		public bool Equals(EbnfDocument rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(null, rhs)) return false;
			if (rhs.Productions.Count == Productions.Count) return false;
			using(var e = Productions.GetEnumerator())
			{
				using(var e2=rhs.Productions.GetEnumerator())
				{
					while (e.MoveNext())
					{
						if (!e2.MoveNext())
							return false;
						var x = e.Current;
						var y = e2.Current;
						if (!Equals(x.Key, y.Key))
							return false;
						if (!Equals(x.Value, y.Value))
							return false;
					}
					if (e2.MoveNext())
						return false;
				}
			}
			return true;
		}
		public override bool Equals(object obj) => Equals(obj as EbnfDocument);
		public override int GetHashCode()
		{
			var result = 0;
			using (var e = Productions.GetEnumerator())
			{
				while (e.MoveNext())
				{
					if (null != e.Current.Key)
						result ^= e.Current.Key.GetHashCode();
					if (null != e.Current.Value)
						result ^= e.Current.Value.GetHashCode();
				}
			}
			return result;
		}
		public static bool operator==(EbnfDocument lhs,EbnfDocument rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfDocument lhs, EbnfDocument rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public EbnfDocument Clone()
		{
			var result = new EbnfDocument();
			foreach (var prod in Productions)
				result.Productions.Add(prod.Key, prod.Value.Clone());
			return result;
		}
		object ICloneable.Clone() => Clone();
		void _VisitFetchTerminals(EbnfExpression expr, HashSet<EbnfExpression> terms)
		{
			var l = expr as EbnfLiteralExpression;
			if (null != l)
			{
				terms.Add(l);
				return;
			}
			var r = expr as EbnfRegexExpression;
			if (null != r)
			{
				terms.Add(r);
				return;
			}
			var u = expr as EbnfUnaryExpression;
			if (null != u)
			{
				_VisitFetchTerminals(u.Expression, terms);
				return;
			}
			var b = expr as EbnfBinaryExpression;
			if(null!=b)
			{
				_VisitFetchTerminals(b.Left, terms);
				_VisitFetchTerminals(b.Right, terms);
				return;
			}
		}
		public IList<EbnfMessage> DeclareImplicitTerminals()
		{
			var result = new List<EbnfMessage>();
			var terms = new HashSet<EbnfExpression>();
			var done = new HashSet<EbnfExpression>();
			foreach (var prod in Productions)
			{
				_VisitFetchTerminals(prod.Value.Expression, terms);
				if (prod.Value.Expression.IsTerminal)
					done.Add(prod.Value.Expression);
			}
			foreach(var term in terms)
			{
				if(!done.Contains(term))
				{
					var prod = new EbnfProduction();
					prod.Expression = ((ICloneable)term).Clone() as EbnfExpression;
					var newId = _GetImplicitTermId();
					Productions.Add(newId, prod);
					result.Add(new EbnfMessage(EbnfErrorLevel.Message, -1, "Terminal was implicitly declared.", term.Line, term.Column, term.Position));
				}
			}
			return result;
		}
		public string GetIdForExpression(EbnfExpression expression)
		{
			foreach (var prod in Productions)
				if (Equals(prod.Value.Expression, expression))
					return prod.Key;
			return null;
		}
		void _ValidateExpression(EbnfExpression expr, IDictionary<string, int> refCounts, IList<EbnfMessage> messages)
		{
			var l = expr as EbnfLiteralExpression;
			if (null != l)
			{
				var i = GetIdForExpression(l);
				// don't count itself. only things just like itself
				if (null != i && !ReferenceEquals(Productions[i].Expression, l))
					refCounts[i] += 1;
			}
			var rx = expr as EbnfRegexExpression;
			if (null != rx)
			{
				try
				{
					FA.Parse(rx.Value);
				}
				catch(ExpectingException)
				{
					messages.Add(
						new EbnfMessage(
							EbnfErrorLevel.Error, 12,
							"Invalid regular expression",
							expr.Line, expr.Column, expr.Position));
				}
				var i = GetIdForExpression(rx);
				if (null != i && !ReferenceEquals(Productions[i].Expression, l))
					refCounts[i] += 1;
			}
			var r = expr as EbnfRefExpression;
			if (null != r)
			{
				int rc;
				if (null == r.Symbol)
				{
					messages.Add(
						new EbnfMessage(
							EbnfErrorLevel.Error, 4,
							"Null reference expression",
							expr.Line, expr.Column, expr.Position));
					return;
				}
				if (!refCounts.TryGetValue(r.Symbol, out rc))
				{
					messages.Add(
						new EbnfMessage(
							EbnfErrorLevel.Error, 1,
							string.Concat(
								"Reference to undefined symbol \"",
								r.Symbol,
								"\""),
							expr.Line, expr.Column, expr.Position));
					return;
				}
				refCounts[r.Symbol] = rc + 1;
				return;
			}
			var b = expr as EbnfBinaryExpression;
			if (null != b)
			{
				if (null == b.Left && null == b.Right)
				{
					messages.Add(
						new EbnfMessage(
							EbnfErrorLevel.Warning, 3,
								"Nil expression",
							expr.Line, expr.Column, expr.Position));
					return;
				}
				_ValidateExpression(b.Left, refCounts, messages);
				_ValidateExpression(b.Right, refCounts, messages);
				return;
			}
			var u = expr as EbnfUnaryExpression;
			if (null != u)
			{
				if (null == u.Expression)
				{
					messages.Add(
						new EbnfMessage(
							EbnfErrorLevel.Warning, 3,
								"Nil expression",
							expr.Line, expr.Column, expr.Position));
					return;
				}
				_ValidateExpression(u.Expression, refCounts, messages);
			}
		}
		public IList<EbnfMessage> Validate(bool throwIfErrors = false)
		{
			var result = new List<EbnfMessage>();
			var refCounts = new Dictionary<string, int>(EqualityComparer<string>.Default);
			foreach (var prod in Productions)
				refCounts.Add(prod.Key, 0);
			foreach (var prod in Productions)
			{
				_ValidateExpression(prod.Value.Expression, refCounts, result);
			}
			foreach (var rc in refCounts)
			{
				if (0 == rc.Value)
				{
					var prod = Productions[rc.Key];
					object o;
					var isHidden = prod.Attributes.TryGetValue("hidden", out o) && o is bool && (bool)o;
					if(!isHidden && !Equals(rc.Key,StartProduction))
						result.Add(new EbnfMessage(EbnfErrorLevel.Warning, 2, string.Concat("Unreferenced production \"", rc.Key, "\""),
							prod.Line, prod.Column, prod.Position));
				}
			}
			if (throwIfErrors)
				EbnfException.ThrowIfErrors(result);
			return result;
		}
		public IList<EbnfMessage> Prepare(bool throwIfErrors=true)
		{
			var result = new List<EbnfMessage>();
			var msgs = Validate(false);
			result.AddRange(msgs);
			var hasError = false;
			foreach(var msg in msgs) 
				if(EbnfErrorLevel.Error==msg.ErrorLevel)
				{
					hasError = true;
					break;
				}
			if(!hasError)
				result.AddRange(DeclareImplicitTerminals());
			if (throwIfErrors)
				EbnfException.ThrowIfErrors(result);
			return result;
		}
		string _GetImplicitTermId()
		{
			var result = "implicit";
			var i = 2;
			while (Productions.ContainsKey(result))
			{
				result = string.Concat("implicit", i.ToString());
				++i;
			}
			return result;
		}
		public FA ToLexer(ISymbolResolver resolver)
		{
			var fas = new List<FA>();
			foreach(var prod in Productions)
			{
				var exp = prod.Value.Expression;
				FA fa = null;
				if (exp.IsTerminal)
				{
					var l = exp as EbnfLiteralExpression;
					if(null!=l)
						fa = FA.Literal(l.Value, resolver.GetSymbolId(prod.Key));
					var r = exp as EbnfRegexExpression;
					if(null!=r)
						fa = FA.Parse(r.Value, resolver.GetSymbolId(prod.Key));
					System.Diagnostics.Debug.Assert(null != fa, "Unsupported terminal expression type.");
					fas.Add(fa);
				}
			}
			return FA.Lexer(fas);
		}
		public Cfg ToCfg()
		{
			var result = new Cfg();
			foreach(var prod in Productions)
			{
				if(!prod.Value.Expression.IsTerminal)
				{
					var ll = prod.Value.Expression.ToDisjunctions(this,result);
					foreach(var l in ll)
						result.Rules.Add(new CfgRule(prod.Key, l));
				}
				IDictionary<string, object> attrs = null;
				if (0 < prod.Value.Attributes.Count)
				{
					attrs = new Dictionary<string, object>();
					result.AttributeSets.Add(prod.Key, attrs);
					foreach (var attr in prod.Value.Attributes)
						attrs.Add(attr.Key, attr.Value);
				}
			}
			return result;
		}
		public override string ToString()
		{
			var sb = new StringBuilder();
			foreach(var prod in Productions)
			{
				sb.Append(prod.Key);
				sb.AppendLine(prod.Value.ToString());
			}
			return sb.ToString();
		}
		public static EbnfDocument ReadFrom(string filename)
		{
			using (var pc = ParseContext.CreateFromFile(filename))
				return Parse(pc);
		}
		public static EbnfDocument ReadFrom(TextReader reader) => Parse(ParseContext.Create(reader));
		public static EbnfDocument Parse(IEnumerable<char> @string) => Parse(ParseContext.Create(@string));
		public static EbnfDocument Parse2(ParseContext pc)
		{
			var doc = new EbnfDocument();
			var parser = new EbnfParser(pc);
			while(parser.Read())
			{
				if(EbnfParser.production==parser.SymbolId)
				{
					_ReadProduction(doc,parser);
				}
			}
			return doc;
		}
		static void _ReadProduction(EbnfDocument doc,EbnfParser parser)
		{
			parser.Read();
			var id = parser.Value;
			var prod = new EbnfProduction();
			parser.Read();
			if (EbnfParser.lt == parser.SymbolId)
			{
				parser.Read();
				_ReadAttributes(prod.Attributes,parser);
				parser.Read();
			}
			parser.Read();
			prod.Expression = _ReadExpressions(parser);
		}
		static EbnfExpression _ReadExpressions(EbnfParser parser)
		{
			EbnfExpression result = null;
			throw new NotImplementedException();
			return result;
		}
		static void _ReadAttributes(IDictionary<string,object> attrs,EbnfParser parser)
		{
			parser.Read();
			while(EbnfParser.attribute==parser.SymbolId)
			{
				parser.Read();
				var id = parser.Value;
				parser.Read();
				object val = true;
				if(EbnfParser.eq==parser.SymbolId)
				{
					parser.Read();
					parser.Read();
					switch(parser.SymbolId)
					{
						case EbnfParser.identifier:
							if ("null" == parser.Value)
								val = null;
							else if ("true" == parser.Value)
								val = true;
							else if ("false" == parser.Value)
								val = false;
							else
								throw new ExpectingException("Expecting true, false, or null.");
							break;
						case EbnfParser.integer:
							val = int.Parse(parser.Value);
							break;
						case EbnfParser.literal:
							val = ParseContext.Create(parser.Value).ParseJsonString();
							break;
					}
					parser.Read();
				}
				attrs.Add(id, val);
				if (EbnfParser.comma == parser.SymbolId)
					parser.Read();
			}
		}
		public static EbnfDocument Parse(ParseContext pc)
		{
			var doc = new EbnfDocument();
			while (-1 != pc.Current)
			{
				_ParseProduction(doc, pc);
				pc.TrySkipCCommentsAndWhiteSpace();
			}
			return doc;
		}
		static void _ParseProduction(EbnfDocument doc, ParseContext pc)
		{
			pc.TrySkipCCommentsAndWhiteSpace();
			var line = pc.Line;
			var column = pc.Column;
			var position = pc.Position;
			var id = _ParseIdentifier(pc);
			pc.TrySkipCCommentsAndWhiteSpace();
			var prod = doc.Productions.TryGetValue(id, null);
			if(null==prod)
			{
				prod = new EbnfProduction();
				doc.Productions.Add(id, prod);
			}
			if ('<' == pc.Current)
			{
				_ParseAttributes(doc, id, prod,pc);
				pc.TrySkipCCommentsAndWhiteSpace();
			}
			pc.Expecting('=');
			pc.Advance();
			pc.Expecting();
			var expr = _ParseExpression(doc, pc);
			pc.TrySkipCCommentsAndWhiteSpace();
			pc.Expecting(';');
			pc.Advance();
			pc.TrySkipCCommentsAndWhiteSpace();
			// transform this into an OrExpression with the previous
			if (null!=prod.Expression)
				prod.Expression = new EbnfOrExpression(prod.Expression, expr);
			else
				prod.Expression= expr;
			prod.SetPositionInfo(line, column, position);
		}
		static EbnfExpression _ParseExpression(EbnfDocument doc, ParseContext pc)
		{
			EbnfExpression current = null;
			EbnfExpression e;
			long position;
			int line;
			int column;
			pc.TrySkipCCommentsAndWhiteSpace();
			position = pc.Position; line = pc.Line; column = pc.Column;
			while (-1 != pc.Current && ']' != pc.Current && ')' != pc.Current && '}' != pc.Current && ';' != pc.Current)
			{
				pc.TrySkipCCommentsAndWhiteSpace();
				position = pc.Position; line = pc.Line; column = pc.Column;
				switch (pc.Current)
				{
					case '|':
						pc.Advance();
						current = new EbnfOrExpression(current, _ParseExpression(doc, pc));
						current.SetPositionInfo(line, column, position);
						break;
					case '(':
						pc.Advance();
						e = _ParseExpression(doc, pc);
						current.SetPositionInfo(line, column, position);
						pc.Expecting(')');
						pc.Advance();
						e.SetPositionInfo(line, column, position);
						if (null == current)
							current = e;
						else
							current = new EbnfConcatExpression(current, e);
						break;
					case '[':
						pc.Advance();
						e = new EbnfOptionalExpression(_ParseExpression(doc, pc));
						e.SetPositionInfo(line, column, position);
						pc.TrySkipCCommentsAndWhiteSpace();
						pc.Expecting(']');
						pc.Advance();
						if (null == current)
							current = e;
						else
							current = new EbnfConcatExpression(current, e);
						break;
					case '{':
						pc.Advance();
						e = new EbnfRepeatExpression(_ParseExpression(doc, pc));
						e.SetPositionInfo(line, column, position);
						pc.TrySkipCCommentsAndWhiteSpace();
						pc.Expecting('}');
						pc.Advance();
						if (null == current)
							current = e;
						else
							current = new EbnfConcatExpression(current, e);
						break;
					case '\"':
						e = new EbnfLiteralExpression(pc.ParseJsonString());
						if (null == current)
							current = e;
						else
							current = new EbnfConcatExpression(current, e);
						e.SetPositionInfo(line, column, position);
						break;
					case '\'':
						pc.Advance();
						pc.ClearCapture();
						pc.TryReadUntil('\'', '\\', false);
						pc.Expecting('\'');
						pc.Advance();
						e = new EbnfRegexExpression(pc.Capture);
						if (null == current)
							current = e;
						else
							current = new EbnfConcatExpression(current, e);
						e.SetPositionInfo(line, column, position);
						break;
					case ';':
					case ']':
					case ')':
					case '}':
						return current;
					default:
						e = new EbnfRefExpression(_ParseIdentifier(pc));
						if (null == current)
							current = e;
						else
							current = new EbnfConcatExpression(current, e);
						e.SetPositionInfo(line, column, position);
						break;
				}
			}
			pc.TrySkipCCommentsAndWhiteSpace();
			return current;
		}
		static void _ParseAttribute(EbnfDocument doc, string id, EbnfProduction prod,ParseContext pc)
		{
			pc.TrySkipCCommentsAndWhiteSpace();
			var attrid = _ParseIdentifier(pc);
			pc.TrySkipCCommentsAndWhiteSpace();
			pc.Expecting('=', '>', ',');
			object val = true;
			if ('=' == pc.Current)
			{
				pc.Advance();
				val = pc.ParseJsonValue();
			}
			pc.Expecting(',', '>');
			prod.Attributes[attrid] = val;
			pc.TrySkipCCommentsAndWhiteSpace();
		}
		static void _ParseAttributes(EbnfDocument doc, string id,EbnfProduction prod, ParseContext pc)
		{
			pc.TrySkipCCommentsAndWhiteSpace();
			pc.Expecting('<');
			pc.Advance();
			while (-1 != pc.Current && '>' != pc.Current)
			{
				_ParseAttribute(doc, id, prod,pc);
				pc.TrySkipCCommentsAndWhiteSpace();
				pc.Expecting(',', '>');
				if (',' == pc.Current)
					pc.Advance();
			}
			pc.Expecting('>');
			pc.Advance();
			pc.TrySkipCCommentsAndWhiteSpace();
		}
		static string _ParseIdentifier(ParseContext pc)
		{
			pc.TrySkipCCommentsAndWhiteSpace();
			if (-1 == pc.Current)
			{
				pc.Expecting();
				return null;
			}
			var l = pc.CaptureBuffer.Length;
			if ('_' != pc.Current && !char.IsLetter((char)pc.Current))
				pc.Expecting("ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".ToCharArray().Convert<int>().ToArray());
			pc.CaptureCurrent();
			while (-1 != pc.Advance() && ('_' == pc.Current || '-' == pc.Current || char.IsLetterOrDigit((char)pc.Current)))
				pc.CaptureCurrent();
			pc.TrySkipCCommentsAndWhiteSpace();
			return pc.GetCapture(l);
		}
	}
}
//*** SourceCombiner -> original file EbnfException.cs ***
namespace Grimoire
{

	sealed class EbnfException : Exception
	{
		public IList<EbnfMessage> Messages { get; }
		public EbnfException(string message, int errorCode = -1, int line = 0, int column = 0, long position = -1) :
			this(new EbnfMessage[] { new EbnfMessage(EbnfErrorLevel.Error, errorCode, message, line, column, position) })
		{ }
		static string _FindMessage(IEnumerable<EbnfMessage> messages)
		{
			var l = new List<EbnfMessage>(messages);
			if (null == messages) return "";
			int c = 0;
			foreach (var m in l)
			{
				if (EbnfErrorLevel.Error == m.ErrorLevel)
				{
					if (1 == l.Count)
						return m.ToString();
					return string.Concat(m, " (multiple messages)");
				}
				++c;
			}
			foreach (var m in messages)
				return m.ToString();
			return "";
		}
		public EbnfException(IEnumerable<EbnfMessage> messages) : base(_FindMessage(messages))
		{
			Messages = new List<EbnfMessage>(messages);
		}
		public static void ThrowIfErrors(IEnumerable<EbnfMessage> messages)
		{
			if (null == messages) return;
			foreach (var m in messages)
				if (EbnfErrorLevel.Error == m.ErrorLevel)
					throw new EbnfException(messages);
		}
	}
}
//*** SourceCombiner -> original file EbnfExpression.cs ***
namespace Grimoire
{
	/// <summary>
	/// Represents the base class for all EBNF expressions
	/// </summary>
	/// <remarks>Make sure derived classes implement <see cref="ICloneable"/> and value semantics</remarks>

	abstract class EbnfExpression 
	{
		public abstract IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg);
		/// <summary>
		/// Indicates whether or not the expression represents a terminal
		/// </summary>
		public abstract bool IsTerminal {get; }
		public static implicit operator EbnfExpression(string rhs)
		{
			return new EbnfRefExpression(rhs);
		}
		public void SetPositionInfo(int line, int column, long position)
		{
			Line = line;
			Column = column;
			Position = position;
		}
		public int Line { get; private set; }
		public int Column { get; private set; }
		public long Position { get; private set; }
	}
}
//*** SourceCombiner -> original file EbnfLiteralExpression.cs ***
namespace Grimoire
{

	class EbnfLiteralExpression : EbnfExpression, IEquatable<EbnfLiteralExpression>, ICloneable
	{
		public EbnfLiteralExpression() { }
		public EbnfLiteralExpression(string value) { Value = value; }
		public string Value { get; set; } = null;
		public override bool IsTerminal => true;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			foreach(var prod in parent.Productions)
			{
				if(Equals(prod.Value.Expression,this))
				{
					var l = new List<IList<string>>();
					var ll = new List<string>();
					l.Add(ll);
					ll.Add(prod.Key);
					return l;
				}
			}
			throw new InvalidOperationException("The terminal was not declared.");
		}
		public EbnfLiteralExpression Clone()
		{
			var result = new EbnfLiteralExpression(Value);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfLiteralExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Value, rhs.Value);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfLiteralExpression);
		public override int GetHashCode()
		{
			if (null != Value) return Value.GetHashCode();
			return 0;
		}
		public static bool operator ==(EbnfLiteralExpression lhs, EbnfLiteralExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfLiteralExpression lhs, EbnfLiteralExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			return string.Concat("\"", Value.Replace("\"", "\\\""), "\"");
		}
	}
}
//*** SourceCombiner -> original file EbnfMessage.cs ***
namespace Grimoire
{

	enum EbnfErrorLevel
	{
		Message = 0,
		Warning = 1,
		Error = 2
	}

	sealed class EbnfMessage
	{
		public EbnfMessage(EbnfErrorLevel errorLevel, int errorCode, string message, int line, int column, long position)
		{
			ErrorLevel = errorLevel;
			ErrorCode = errorCode;
			Message = message;
			Line = line;
			Column = column;
			Position = position;
		}
		public EbnfErrorLevel ErrorLevel { get; private set; }
		public int ErrorCode { get; private set; }
		public string Message { get; private set; }
		public int Line { get; private set; }
		public int Column { get; private set; }
		public long Position { get; private set; }
		public override string ToString()
		{
			if (-1 == Position)
			{
				if (-1 != ErrorCode)
					return string.Format("{0}: {1} code {2}",
						ErrorLevel, Message, ErrorCode);
				return string.Format("{0}: {1}",
						ErrorLevel, Message);
			}
			else
			{
				if(-1!=ErrorCode)
					return string.Format("{0}: {1} code {2} at line {3}, column {4}, position {5}",
						ErrorLevel, Message, ErrorCode, Line, Column, Position);
				return string.Format("{0}: {1} at line {2}, column {3}, position {4}",
						ErrorLevel, Message, Line, Column, Position);
			}
		}
	}
}
//*** SourceCombiner -> original file EbnfOptionalExpression.cs ***
namespace Grimoire
{

	class EbnfOptionalExpression : EbnfUnaryExpression, IEquatable<EbnfOptionalExpression>, ICloneable
	{
		public EbnfOptionalExpression(EbnfExpression expression) { Expression = expression; }
		public EbnfOptionalExpression() { }
		public override bool IsTerminal => false;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			var l = new List<IList<string>>();
			if (null != Expression) {
				l.AddRange(Expression.ToDisjunctions(parent,cfg));
				var ll = new List<string>();
				if (!l.Contains(ll, OrderedCollectionEqualityComparer<string>.Default))
					l.Add(ll);
			}
			return l;
		}
		public EbnfOptionalExpression Clone() {
			var result = new EbnfOptionalExpression(Expression);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfOptionalExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Expression, rhs.Expression);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfOptionalExpression);
		public override int GetHashCode()
		{
			if (null != Expression) return Expression.GetHashCode();
			return 0;
		}
		public static bool operator ==(EbnfOptionalExpression lhs, EbnfOptionalExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfOptionalExpression lhs, EbnfOptionalExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			if (null == Expression) return "[ ]";
			return string.Concat("[ ", Expression.ToString(), " ]");
		} 
	}
}
//*** SourceCombiner -> original file EbnfOrExpression.cs ***
namespace Grimoire
{

	class EbnfOrExpression : EbnfBinaryExpression,IEquatable<EbnfOrExpression>, ICloneable
	{
		public EbnfOrExpression(EbnfExpression left, params EbnfExpression[] right)
		{
			if (null == right) right = new EbnfExpression[] { null };
			Left = left;
			for (var i = 0; i < right.Length; ++i)
			{
				if (Right == null)
					Right = right[i];
				else
					Right = new EbnfOrExpression(Right, right[i]);
			}
		}
		public EbnfOrExpression() { }
		public override bool IsTerminal => false;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			var l = new List<IList<string>>();
			if(null==Left)
				l.Add(new List<string>());
			else
				foreach(var ll in Left.ToDisjunctions(parent,cfg))
					if (!l.Contains(ll, OrderedCollectionEqualityComparer<string>.Default))
						l.Add(ll);
			if (null == Right)
			{
				var ll = new List<string>();
				if (!l.Contains(ll, OrderedCollectionEqualityComparer<string>.Default)) 
					l.Add(ll);
			} 
			else
				foreach (var ll in Right.ToDisjunctions(parent,cfg))
					if (!l.Contains(ll, OrderedCollectionEqualityComparer<string>.Default))
						l.Add(ll);
			return l;
		}
		public EbnfOrExpression Clone()
		{
			var result = new EbnfOrExpression(null != Left ? ((ICloneable)Left).Clone() as EbnfExpression : null, null != Right ? ((ICloneable)Right).Clone() as EbnfExpression : null);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfOrExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Left, rhs.Left) && Equals(Right, rhs.Right) ||
				Equals(Left, rhs.Right) && Equals(Right, rhs.Left);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfOrExpression);
		public override int GetHashCode()
		{
			var result = 0;
			if (null != Left) result = Left.GetHashCode();
			if (null != Right) result ^= Right.GetHashCode();
			return result;
		}
		public static bool operator ==(EbnfOrExpression lhs, EbnfOrExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfOrExpression lhs, EbnfOrExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			return string.Concat(Left, " | ", Right);
		}
	}
}
//*** SourceCombiner -> original file EbnfParser.cs ***
#line 1 "C:\dev\Newt\HighlighterDemo\Ebnf.ebnf"
// Generator Message: Removing rule implicitlist -> production implicitlist because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist -> production because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist -> production implicitlist` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> implicitlist to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> to resolve first-first conflict.
// Generator Message: Removing rule production -> identifier lt attributes gt eq expressions semi because it is part of a first-first conflict.
// Generator Message: Removing rule production -> identifier eq expressions semi because it is part of a first-first conflict.
// Generator Message: Adding rule production -> identifier production` to resolve first-first conflict.
// Generator Message: Adding rule production` -> lt attributes gt eq expressions semi to resolve first-first conflict.
// Generator Message: Adding rule production` -> eq expressions semi to resolve first-first conflict.
// Generator Message: Removing rule expressions -> expression or expressions because it is part of a first-first conflict.
// Generator Message: Removing rule expressions -> expression because it is part of a first-first conflict.
// Generator Message: Adding rule expressions -> expression expressions` to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> or expressions to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol implicitlist2 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist2 -> symbol implicitlist2` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> implicitlist2 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute implicitlist3 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist3 -> comma attribute implicitlist3` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> implicitlist3 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> to resolve first-first conflict.
// Generator Message: Removing rule attribute -> identifier eq attrvalue because it is part of a first-first conflict.
// Generator Message: Removing rule attribute -> identifier because it is part of a first-first conflict.
// Generator Message: Adding rule attribute -> identifier attribute` to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> eq attrvalue to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> to resolve first-first conflict.
//*** SourceCombiner -> original file EbnfParser.cs ***
#line 1 "C:\dev\Newt\HighlighterDemo\Ebnf.ebnf"
// Generator Message: Removing rule implicitlist -> production implicitlist because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist -> production because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist -> production implicitlist` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> implicitlist to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> to resolve first-first conflict.
// Generator Message: Removing rule production -> identifier lt attributes gt eq expressions semi because it is part of a first-first conflict.
// Generator Message: Removing rule production -> identifier eq expressions semi because it is part of a first-first conflict.
// Generator Message: Adding rule production -> identifier production` to resolve first-first conflict.
// Generator Message: Adding rule production` -> lt attributes gt eq expressions semi to resolve first-first conflict.
// Generator Message: Adding rule production` -> eq expressions semi to resolve first-first conflict.
// Generator Message: Removing rule expressions -> expression or expressions because it is part of a first-first conflict.
// Generator Message: Removing rule expressions -> expression because it is part of a first-first conflict.
// Generator Message: Adding rule expressions -> expression expressions` to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> or expressions to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol implicitlist2 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist2 -> symbol implicitlist2` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> implicitlist2 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute implicitlist3 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist3 -> comma attribute implicitlist3` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> implicitlist3 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> to resolve first-first conflict.
// Generator Message: Removing rule attribute -> identifier eq attrvalue because it is part of a first-first conflict.
// Generator Message: Removing rule attribute -> identifier because it is part of a first-first conflict.
// Generator Message: Adding rule attribute -> identifier attribute` to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> eq attrvalue to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> to resolve first-first conflict.
namespace Grimoire
{
}
//*** SourceCombiner -> original file EbnfParser.cs ***
#line 1 "C:\dev\Newt\Perf\ebnf.ebnf"
// Generator Message: Removing rule implicitlist -> production implicitlist because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist -> production because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist -> production implicitlist` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> implicitlist to resolve first-first conflict.
// Generator Message: Adding rule implicitlist` -> to resolve first-first conflict.
// Generator Message: Removing rule production -> identifier lt attributes gt eq expressions semi because it is part of a first-first conflict.
// Generator Message: Removing rule production -> identifier eq expressions semi because it is part of a first-first conflict.
// Generator Message: Adding rule production -> identifier production` to resolve first-first conflict.
// Generator Message: Adding rule production` -> lt attributes gt eq expressions semi to resolve first-first conflict.
// Generator Message: Adding rule production` -> eq expressions semi to resolve first-first conflict.
// Generator Message: Removing rule expressions -> expression or expressions because it is part of a first-first conflict.
// Generator Message: Removing rule expressions -> expression because it is part of a first-first conflict.
// Generator Message: Adding rule expressions -> expression expressions` to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> or expressions to resolve first-first conflict.
// Generator Message: Adding rule expressions` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol implicitlist2 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist2 -> symbol because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist2 -> symbol implicitlist2` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> implicitlist2 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist2` -> to resolve first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute implicitlist3 because it is part of a first-first conflict.
// Generator Message: Removing rule implicitlist3 -> comma attribute because it is part of a first-first conflict.
// Generator Message: Adding rule implicitlist3 -> comma attribute implicitlist3` to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> implicitlist3 to resolve first-first conflict.
// Generator Message: Adding rule implicitlist3` -> to resolve first-first conflict.
// Generator Message: Removing rule attribute -> identifier eq attrvalue because it is part of a first-first conflict.
// Generator Message: Removing rule attribute -> identifier because it is part of a first-first conflict.
// Generator Message: Adding rule attribute -> identifier attribute` to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> eq attrvalue to resolve first-first conflict.
// Generator Message: Adding rule attribute` -> to resolve first-first conflict.
//*** SourceCombiner -> original file EbnfProduction.cs ***
namespace Grimoire
{
	/// <summary>
	/// Represents a grammar production
	/// </summary>
	/// <remarks>This class implements value semantics</remarks>

	class EbnfProduction : IEquatable<EbnfProduction>, ICloneable
	{
		public EbnfProduction(EbnfExpression expression) { Expression = expression; }
		public EbnfProduction() { }
		/// <summary>
		/// Indicates the grammar attributes for the production
		/// </summary>
		public IDictionary<string, object> Attributes { get; } = new Dictionary<string, object>();
		/// <summary>
		/// Indicates the root expression for the production
		/// </summary>
		public EbnfExpression Expression { get; set; } = null;
		public void SetPositionInfo(int line, int column, long position)
		{
			Line = line;
			Column = column;
			Position = position;
		}
		public int Line { get; private set; }
		public int Column { get; private set; }
		public long Position { get; private set; }
		public EbnfProduction Clone()
		{
			var prod = new EbnfProduction();
			foreach(var attr in Attributes)
				prod.Attributes.Add(attr.Key, attr.Value);
			prod.Expression = ((ICloneable)Expression).Clone() as EbnfExpression;
			prod.SetPositionInfo(Line, Column, Position);
			return prod;
		}
		object ICloneable.Clone() => Clone();
		public override string ToString()
		{
			var sb = new StringBuilder();
			if(0<Attributes.Count)
			{
				var delim = "<";
				foreach(var attr in Attributes)
				{
					sb.Append(delim);
					sb.Append(attr.Key);
					_AppendAttrVal(attr.Value, sb);
					delim = ",";
				}
				sb.Append(">");
			}
			sb.Append("= ");
			sb.Append(null != Expression ? Expression.ToString() : "");
			sb.Append(";");
			return sb.ToString();
		}
		void _AppendAttrVal(object value, StringBuilder sb)
		{
			if (value is bool)
			{
				if (!(bool)value)
				{
					sb.Append("=false");
				}
			}
			else if (value is string)
			{
				sb.Append("=\"");
				sb.Append(((string)value).Replace("\"", "\\\""));
				sb.Append('\"');
			}
			else if (value is char)
			{
				sb.Append("=\"");
				sb.Append(Convert.ToString(value).Replace("\"", "\\\""));
				sb.Append('\"');
			}
			else
			{
				sb.Append('=');
				sb.Append(value);
			}
		}
		public bool Equals(EbnfProduction rhs)
		{
			if (ReferenceEquals(this, rhs)) return true;
			if (ReferenceEquals(null, rhs)) return false;
			if (rhs.Attributes.Count != Attributes.Count) return false;
			if (!Equals(rhs.Expression, Expression)) return false;
			foreach (var attr in Attributes)
			{
				object o;
				if (!rhs.Attributes.TryGetValue(attr.Key, out o) || !Equals(o, attr.Value))
					return false;
			}
			return true;
		}
		public override bool Equals(object obj) => Equals(obj as EbnfProduction);
		public override int GetHashCode()
		{
			var result = 0;
			if (null != Expression)
				result ^= Expression.GetHashCode();
			foreach(var attr in Attributes)
			{
				result ^= attr.Key.GetHashCode();
				if (null != attr.Value)
					result ^= attr.Value.GetHashCode();
			}
			return result;
		}
		public static bool operator==(EbnfProduction lhs,EbnfProduction rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfProduction lhs, EbnfProduction rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
	}
}
//*** SourceCombiner -> original file EbnfRefExpression.cs ***
namespace Grimoire
{

	class EbnfRefExpression : EbnfExpression, IEquatable<EbnfRefExpression>, ICloneable
	{
		public EbnfRefExpression(string symbol) { Symbol = symbol; }
		public EbnfRefExpression() { }
		public override bool IsTerminal => false;
		/// <summary>
		/// Indicates the referenced symbol
		/// </summary>
		public string Symbol { get; set; } = null;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			if (string.IsNullOrEmpty(Symbol))
				throw new InvalidOperationException("The ref expression was nil.");
			var l = new List<IList<string>>();
			var ll = new List<string>();
			l.Add(ll);
			ll.Add(Symbol);
			return l;
		}
		public EbnfRefExpression Clone() {
			var result = new EbnfRefExpression(Symbol);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfRefExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Symbol, rhs.Symbol);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfRefExpression);
		public override int GetHashCode()
		{
			if (null != Symbol) return Symbol.GetHashCode();
			return 0;
		}
		public static bool operator ==(EbnfRefExpression lhs, EbnfRefExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfRefExpression lhs, EbnfRefExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			return null != Symbol ? Symbol : "";
		}
	}
}
//*** SourceCombiner -> original file EbnfRegexExpression.cs ***
namespace Grimoire
{

	class EbnfRegexExpression : EbnfExpression,IEquatable<EbnfRegexExpression>, ICloneable
	{
		public EbnfRegexExpression() { }
		public EbnfRegexExpression(string value) { Value = value; }
		public override bool IsTerminal => true;
		public string Value { get; set; } = null;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			foreach (var prod in parent.Productions)
			{
				if (Equals(prod.Value.Expression, this))
				{
					var l = new List<IList<string>>();
					var ll = new List<string>();
					l.Add(ll);
					ll.Add(prod.Key);
					return l;
				}
			}
			throw new InvalidOperationException("The terminal was not declared.");
		}
		public EbnfRegexExpression Clone() {
			var result = new EbnfRegexExpression(Value);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfRegexExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Value, rhs.Value);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfRegexExpression);
		public override int GetHashCode()
		{
			if (null != Value) return Value.GetHashCode();
			return 0;
		}
		public static bool operator ==(EbnfRegexExpression lhs, EbnfRegexExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfRegexExpression lhs, EbnfRegexExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			return string.Concat("\'",Value.Replace("\'","\\\'"), "\'");
		}
	}
}
//*** SourceCombiner -> original file EbnfRepeatExpression.cs ***
namespace Grimoire
{

	class EbnfRepeatExpression :EbnfUnaryExpression, IEquatable<EbnfRepeatExpression>,ICloneable
	{
		public EbnfRepeatExpression(EbnfExpression expression) { Expression = expression; }
		public EbnfRepeatExpression() { }
		public override bool IsTerminal => false;
		public override IList<IList<string>> ToDisjunctions(EbnfDocument parent,Cfg cfg)
		{
			var _listId = cfg.GetUniqueId("implicitlist");
			IDictionary<string, object> attrs = new Dictionary<string, object>();
			attrs.Add("collapse", true);
			cfg.AttributeSets.Add(_listId, attrs);
			var expr = new EbnfOrExpression(new EbnfOrExpression(new EbnfConcatExpression(Expression,new EbnfRefExpression(_listId)), Expression), null);
			foreach (var nt in expr.ToDisjunctions(parent, cfg))
			{
				CfgRule r = new CfgRule();
				r.Left = _listId;
				foreach (var s in nt)
				{
					if (1 < r.Right.Count && null == s)
						continue;
					r.Right.Add(s);
				}
				if (!cfg.Rules.Contains(r))
					cfg.Rules.Add(r);
			}
			return new List<IList<string>>(new IList<string>[] { new List<string>(new string[] { _listId }) });
		}
		public EbnfRepeatExpression Clone() {
			var result = new EbnfRepeatExpression(Expression);
			result.SetPositionInfo(Line, Column, Position);
			return result;
		}
		object ICloneable.Clone() => Clone();
		public bool Equals(EbnfRepeatExpression rhs)
		{
			if (ReferenceEquals(rhs, this)) return true;
			if (ReferenceEquals(rhs, null)) return false;
			return Equals(Expression, rhs.Expression);
		}
		public override bool Equals(object obj) => Equals(obj as EbnfRepeatExpression);
		public override int GetHashCode()
		{
			if (null != Expression) return Expression.GetHashCode();
			return 0;
		}
		public static bool operator ==(EbnfRepeatExpression lhs, EbnfRepeatExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return true;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return false;
			return lhs.Equals(rhs);
		}
		public static bool operator !=(EbnfRepeatExpression lhs, EbnfRepeatExpression rhs)
		{
			if (ReferenceEquals(lhs, rhs)) return false;
			if (ReferenceEquals(lhs, null) || ReferenceEquals(rhs, null)) return true;
			return !lhs.Equals(rhs);
		}
		public override string ToString()
		{
			if (null == Expression) return "{ }";
			return string.Concat("{ ", Expression.ToString(), " }");
		}
	}
}
//*** SourceCombiner -> original file EbnfUnaryExpression.cs ***
namespace Grimoire
{

	abstract class EbnfUnaryExpression : EbnfExpression
	{
		public EbnfExpression Expression { get; set; } = null;
	}
}
//*** SourceCombiner -> original file Eval.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Eval.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file ExprParser.cs ***
#line 1 "C:\dev\Newt\Eval\Expr.ebnf"
// Generator Message: Removing rule expr -> expr add term because it is directly left recursive.
// Generator Message: Adding rule expr` -> add term expr` to replace rule expr -> expr add term
// Generator Message: Adding rule expr` -> to replace rule expr -> expr add term
// Generator Message: Removing rule term -> term mul factor because it is directly left recursive.
// Generator Message: Adding rule term` -> mul factor term` to replace rule term -> term mul factor
// Generator Message: Adding rule term` -> to replace rule term -> term mul factor
partial class ExprParser : Grimoire.TableDrivenLL1Parser {
	public ExprParser(Grimoire.ParseContext parseContext=null) : base(_ParseTable,_StartingConfiguration,_LexTable,_Symbols,_SubstitutionsAndHiddenTerminals,_BlockEnds,_CollapsedNonTerminals,_Types,parseContext) { }
	public const int EOS=11;
	public const int ERROR=12;
	public const int expr = 0;
	public const int term = 1;
	public const int factor = 2;
	public const int lparen = 5;
	public const int rparen = 6;
	public const int @int = 7;
	public const int add = 8;
	public const int mul = 9;
	static readonly string[] _Symbols = {"expr", "term", "factor", "expr`", "term`", "lparen", "rparen", "int", "add", "mul", "whitespace", "#EOS", "#ERROR" };
	static readonly (int Left, int[] Right)[][] _ParseTable = new (int Left, int[] Right)[][] {
	new (int Left, int[] Right)[] {
		(0, new System.Int32[] { 1, 3 })
		,(-1,null)
		,(0, new System.Int32[] { 1, 3 })
		,(-1,null)
		,(-1,null)
		,(-1,null)
		,(-1,null)
		}
	,new (int Left, int[] Right)[] {
		(1, new System.Int32[] { 2, 4 })
		,(-1,null)
		,(1, new System.Int32[] { 2, 4 })
		,(-1,null)
		,(-1,null)
		,(-1,null)
		,(-1,null)
		}
	,new (int Left, int[] Right)[] {
		(2, new System.Int32[] { 5, 0, 6 })
		,(-1,null)
		,(2, new System.Int32[] { 7 })
		,(-1,null)
		,(-1,null)
		,(-1,null)
		,(-1,null)
		}
	,new (int Left, int[] Right)[] {
		(-1,null)
		,(3, new System.Int32[] { })
		,(-1,null)
		,(3, new System.Int32[] { 8, 1, 3 })
		,(-1,null)
		,(-1,null)
		,(3, new System.Int32[] { })
		}
	,new (int Left, int[] Right)[] {
		(-1,null)
		,(4, new System.Int32[] { })
		,(-1,null)
		,(4, new System.Int32[] { })
		,(4, new System.Int32[] { 9, 2, 4 })
		,(-1,null)
		,(4, new System.Int32[] { })
		}
};
	static readonly int[] _SubstitutionsAndHiddenTerminals = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -2, 11, 12, -1 };
	static readonly (int SymbolId,bool IsNonTerminal,int NonTerminalCount) _StartingConfiguration = (0, true, 5);
	static readonly string[] _BlockEnds = new string[] { 
	null
	,null
	,null
	,null
	,null
	,null
	,null
	,null
	,null
	,null
	,null
	,null
	,null
};
	static readonly System.Type[] _Types = new System.Type[] { 
	null
	,null
	,null
	,null
	,null
	,null
	,null
	,typeof(System.Int32)
	,null
	,null
	,null
	,null
	,null
};
	static readonly int[] _CollapsedNonTerminals = new int[] { 
-1,-1,-1,-3,-3,-1,-1,-1,-1,-1,-1,-1,-1};
	static readonly (int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] _LexTable = new (System.Int32 Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, System.Int32[] PossibleAccepts)[] {
	(-1, new ((char First, char Last)[] Ranges, int Destination)[] {
		(new (char First,char Last)[] {
			((char)43,(char)43)
			,((char)45,(char)45)
},1)		,(new (char First,char Last)[] {
			((char)42,(char)42)
			,((char)47,(char)47)
},2)		,(new (char First,char Last)[] {
			((char)40,(char)40)
},3)		,(new (char First,char Last)[] {
			((char)41,(char)41)
},4)		,(new (char First,char Last)[] {
			((char)48,(char)57)
},5)		,(new (char First,char Last)[] {
			((char)9,(char)10)
			,((char)13,(char)13)
			,((char)32,(char)32)
},6)}, new int[] { 8, 9, 5, 6, 7, 10 })
	,(8, new ((char First, char Last)[] Ranges, int Destination)[] {
}, new int[] { 8 })
	,(9, new ((char First, char Last)[] Ranges, int Destination)[] {
}, new int[] { 9 })
	,(5, new ((char First, char Last)[] Ranges, int Destination)[] {
}, new int[] { 5 })
	,(6, new ((char First, char Last)[] Ranges, int Destination)[] {
}, new int[] { 6 })
	,(7, new ((char First, char Last)[] Ranges, int Destination)[] {
		(new (char First,char Last)[] {
			((char)48,(char)57)
},5)}, new int[] { 7 })
	,(10, new ((char First, char Last)[] Ranges, int Destination)[] {
		(new (char First,char Last)[] {
			((char)9,(char)10)
			,((char)13,(char)13)
			,((char)32,(char)32)
},6)}, new int[] { 10 })
}
;
}
//*** SourceCombiner -> original file FA.cs ***
// by codewitch honey crisis
// article https://www.codeproject.com/Articles/1280690/A-Regular-Expression-Engine-in-Csharp
// CODEDOM option - Include System.CodeDom code generation support
// comment the below to disable CodeDom support 
// if enabled under .NET Core this requires the 
// System.CodeDom nuget package 
//#define CODEDOM
namespace Grimoire
{
#if CODEDOM
#endif
	/// <summary>
	/// Represents a state in a finite state machine.
	/// </summary>	
	/// <remarks>This class is essentially a regular expression engine and code generator.</remarks>

	sealed partial class FA : ICloneable
	{
		/// <summary>
		/// The Accepting Symbol. If this null, the state does not accept.
		/// </summary>
		/// <remarks>For code to be generated from this, it must be an intrinsic type.</remarks>
		public object AcceptingSymbol { get; set; } = null;
		/// <summary>
		/// An arbitrary value associated with this state
		/// </summary>
		/// <remarks>No code is generated for this.</remarks>
		public object Tag { get; set; } = null;
		/// <summary>
		/// The input transitions.
		/// </summary>
		public IDictionary<char, FA> Transitions { get; } = new _TrnsDic();
		/// <summary>
		/// The transitions on epsilon.
		/// </summary>
		public IList<FA> EpsilonTransitions { get; } = new List<FA>();
		/// <summary>
		/// Constructs a new instance of an FA state
		/// </summary>
		public FA() { }
		/// <summary>
		/// Constructs a new instance of an FA state with the specified parameters
		/// </summary>
		/// <param name="accepting">The symbol that this state returns, or null if the state is not accepting.</param>
		/// <param name="tag">The arbitrary tag associated with this symbol, if any.</param>
		/// <remarks>For code generation to function, <paramref name="accepting"/> should be an intrinsic type.</remarks>
		public FA(object accepting, object tag = null)
		{
			AcceptingSymbol = accepting;
			Tag = tag;
		}
		/// <summary>
		/// Clones a state 
		/// </summary>
		public FA Clone()
		{
			return Clone(FillClosure());
		}
		object ICloneable.Clone() { return Clone(); }
		/// <summary>
		/// Clones a state given its closure
		/// </summary>
		/// <param name="closure">The closure of the state to clone</param>
		/// <returns>A new state that is a deep clone of the passed in state.</returns>
		public static FA Clone(IEnumerable<FA> closure)
		{
			IList<FA> lclosure = closure.AsList();
			var newClosure = new FA[lclosure.Count];
			var c = newClosure.Length;
			int i;
			for (i = 0; i < newClosure.Length; i++)
				newClosure[i] = new FA();
			i = 0;
			foreach (var fa in lclosure)
			{
				foreach (var trns in (IDictionary<FA, ICollection<char>>)fa.Transitions)
					((IDictionary<FA, ICollection<char>>)newClosure[i].Transitions).Add(newClosure[lclosure.IndexOf(trns.Key)], new HashSet<char>(trns.Value));
				foreach (var efa in fa.EpsilonTransitions)
					newClosure[i].EpsilonTransitions.Add(newClosure[lclosure.IndexOf(efa)]);
				newClosure[i].AcceptingSymbol = fa.AcceptingSymbol;
				newClosure[i].Tag = fa.Tag;
				++i;
			}
			return newClosure[0];
		}
		private string _RegexEscape(char ch)
		{
			switch (ch)
			{
				case '\r':
					return @"\r";
				case '\n':
					return @"\n";
				case '\t':
					return @"\t";
				case '\v':
					return @"\v";
				case '\f':
					return @"\f";
				case '\0':
					return @"\0";
				case '\a':
					return @"\a";
				case '\b':
					return @"\b";
				case '[':
					return @"\[";
				case ']':
					return @"\]";
				case '-':
					return @"\-";
				case '^':
					return @"\^";
				case '.':
					return @"\.";
				case '{':
					return @"\{";
				case '}':
					return @"\}";
				case '(':
					return @"\(";
				case ')':
					return @"\)";
				default:
					if (!char.IsLetterOrDigit(ch) && !char.IsSeparator(ch) && !char.IsPunctuation(ch) && !char.IsSymbol(ch))
						return string.Concat("\\u", unchecked((ushort)ch).ToString("x4"));
					return ch.ToString();
			}
		}
		void _ToString(StringBuilder sb, IList<FA> visited, IList<KeyValuePair<FA, FA>> loopMarkers)
		{
			if (null == visited)
				visited = new List<FA>();
			else if (visited.Contains(this))
				return;
			visited.Add(this);
			foreach (var lp in loopMarkers)
			{
				if (this.FillEpsilonClosure().Contains(lp.Key))
				{
					sb.Append("(");
				}
			}
			var states = new List<FA>();
			FillEpsilonClosure(states);
			var d = new Dictionary<FA, IList<KeyValuePair<char, char>>>();
			foreach (var fa in states)
			{
				fa.FillInputTransitionRangesGroupedByState(d);
			}
			string delim = "";
			if (1 < d.Count)
				sb.Append('(');
			var sb2 = new StringBuilder();
			foreach (var tr in d)
			{
				sb.Append(delim);
				sb2.Clear();
				int i = 0, j = 0;
				foreach (var rg in tr.Value)
				{
					sb2.Append(_RegexEscape(rg.Key));
					if (rg.Key + 1 == rg.Value || rg.Key == rg.Value - 1)
					{
						sb2.Append(_RegexEscape(rg.Value));
						++i;
					}
					else if (rg.Key != rg.Value)
					{
						sb2.Append('-');
						sb2.Append(_RegexEscape(rg.Value));
						++i;
					}
					++i;
					++j;
				}
				if (1 != i)
				{
					sb.Append('[');
					sb.Append(sb2.ToString());
					sb.Append(']');
				}
				else
					sb.Append(sb2.ToString());
				var visited2 = new List<FA>(visited);
				/*foreach (var lp in loopMarkers)
				{
					if (lp.Key == tr.Key)
						sb.Append("(");
				}*/
				tr.Key._ToString(sb, visited2, loopMarkers);
				foreach (var lp in loopMarkers)
				{
					if (lp.Value == tr.Key)
					{
						visited2 = new List<FA>(visited);
						lp.Key._ToString(sb, visited2, loopMarkers);
						sb.Append(")*");
					}
				}
				delim = "|";
			}
			if (1 < d.Count)
				sb.Append(')');
		}
		/// <summary>
		/// Returns the regular expression that represents the FA
		/// </summary>
		/// <returns>A regular expression</returns>
		/// <remarks>DOES NOT WORK YET. Mostly for debugging. This algorithm is naive and only supports |, *, (), and [] which can make expressions very large, and unreasonable for more complicated expressions with hundreds or sometimes even dozens of states.</remarks>
		public override string ToString()
		{
			var sb = new StringBuilder();
			_ToString(sb, null, FillLoops(FillClosure()));
			return sb.ToString();
		}
		IEnumerable<FA> _EnumClosure(ICollection<FA> visited)
		{
			if (0 < visited.Count)
			{
				foreach (var fa in visited)
					yield return fa;
				yield break;
			}
			visited.Add(this);
			yield return this;
			foreach (var trns in Transitions)
				foreach (var ffa in trns.Value._EnumClosure2(visited))
					yield return ffa;
			foreach (var fa in EpsilonTransitions)
				foreach (var ffa in fa._EnumClosure2(visited))
					yield return ffa;
		}
		IEnumerable<FA> _EnumClosure2(ICollection<FA> visited)
		{
			if (visited.Contains(this))
				yield break;
			visited.Add(this);
			yield return this;
			foreach (var trns in Transitions)
				foreach (var ffa in trns.Value._EnumClosure2(visited))
					yield return ffa;
			foreach (var fa in EpsilonTransitions)
				foreach (var ffa in fa._EnumClosure2(visited))
					yield return ffa;
		}
		/// <summary>
		/// Lazy enumeration of the closure
		/// </summary>
		/// <remarks>Usually, <see cref="FA.FillClosure(IList{FA})"/> will be faster. The exception is when a large closure only needs to be partially enumerated. This is wrapped with a <see cref="System.Collections.Generic.IList{FA}"/>for convenience but the list doesn't have the performance properties of a standard list.</remarks>
		public IList<FA> Closure {
			get {
				return _EnumClosure(new List<FA>()).AsList();
			}
		}
		/// <summary>
		/// Fills a list with a list of all states reachable from this state, including itself.
		/// </summary>
		/// <param name="result">The list to fill. If null, the list will be created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list if <paramref name="result"/> was null.</returns>
		public IList<FA> FillClosure(IList<FA> result = null)
		{
			if (null == result)
				result = new List<FA>();
			else if (result.Contains(this))
				return result;
			result.Add(this);
			foreach (var trns in (IDictionary<FA, ICollection<char>>)Transitions)
				trns.Key.FillClosure(result);
			foreach (var fa in EpsilonTransitions)
				fa.FillClosure(result);
			return result;
		}
		/// <summary>
		/// Fills a list with a list of all states reachable from this state on an epsilon transition, including itself.
		/// </summary>
		/// <param name="result">The list to fill. If null, the list will be created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list if <paramref name="result"/> was null.</returns>
		public IList<FA> FillEpsilonClosure(IList<FA> result = null)
		{
			if (null == result)
				result = new List<FA>();
			else if (result.Contains(this))
				return result;
			result.Add(this);
			foreach (var fa in EpsilonTransitions)
				fa.FillEpsilonClosure(result);
			return result;
		}
		IEnumerable<FA> _EnumEpsilonClosure(IList<FA> visited)
		{
			if (visited.Contains(this))
				yield break;
			visited.Add(this);
			yield return this;
			foreach (var fa in EpsilonTransitions)
				foreach (var ffa in fa._EnumEpsilonClosure(visited))
					yield return ffa;
		}
		/// <summary>
		/// Lazy enumerates the epsilon closure.
		/// </summary>
		public IList<FA> EpsilonClosure {
			get {
				return _EnumEpsilonClosure(new List<FA>()).AsList();
			}
		}
		/// <summary>
		/// Fills a list with all states reachable from the specified states on an epsilon transition, including themselves.
		/// </summary>
		/// <param name="result">The list to fill. If null, the list will be created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list if <paramref name="result"/> was null.</returns>
		public static IList<FA> FillEpsilonClosure(IEnumerable<FA> states, IList<FA> result = null)
		{
			if (null == result)
				result = new List<FA>();
			foreach (var fa in states)
				fa.FillEpsilonClosure(result);
			return result;
		}
		/// <summary>
		/// Returns true if the state has exactly one epsilon transition and no input transitions.
		/// </summary>
		public bool IsNeutral {
			get {
				return null == AcceptingSymbol && 0 == Transitions.Count && 1 == EpsilonTransitions.Count;
			}
		}
		/// <summary>
		/// Fills a list with all neutral states reachable from the specified state, if necessary including itself.
		/// </summary>
		/// <param name="result">The list to fill. If null, the list will be created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list if <paramref name="result"/> was null.</returns>
		public IList<FA> FillNeutrals(IList<FA> result = null)
		{
			return FillNeutrals(FillClosure(), result);
		}
		/// <summary>
		/// Fills a list with all neutral states from the specified closure.
		/// </summary>
		/// <param name="closure">The closure to use.</param>
		/// <param name="result">The list to fill. If null, the list will be created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list if <paramref name="result"/> was null.</returns>
		public static IList<FA> FillNeutrals(IEnumerable<FA> closure, IList<FA> result = null)
		{
			if (null == closure)
				throw new ArgumentNullException(nameof(closure));
			if (null == result) result = new List<FA>();
			foreach (var fa in closure)
				if (fa.IsNeutral)
					result.Add(fa);
			return result;
		}
		static IEnumerable<FA> _EnumNeutrals(IEnumerable<FA> closure)
		{
			foreach (var fa in closure)
				if (null != fa.AcceptingSymbol)
					yield return fa;
		}
		/// <summary>
		/// Lazy enumerates the neutral states
		/// </summary>
		public IList<FA> Neutrals {
			get {
				return _EnumNeutrals(FillClosure()).AsList();
			}
		}
		/// <summary>
		/// Returns true if the state has no transitions.
		/// </summary>
		public bool IsFinal {
			get {
				return 0 == Transitions.Count && 0 == EpsilonTransitions.Count;
			}
		}
		/// <summary>
		/// Fills a list with all final states reachable from this state.
		/// </summary>
		/// <param name="result">The list to fill. If null, a list is created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list that was filled.</returns>
		public IList<FA> FillFinals(IList<FA> result = null)
		{
			return FillFinals(FillClosure(), result);
		}
		/// <summary>
		/// Fills a list with all final states in the specified closure.
		/// </summary>
		/// <param name="closure">The closure to use. Alternately, a collection of states to filter for finals.</param>
		/// <param name="result">The list to fill. If null, a list is created.</param>
		/// <returns>The list specified in <paramref name="result"/> or the new list that was filled.</returns>
		public static IList<FA> FillFinals(IEnumerable<FA> closure, IList<FA> result = null)
		{
			if (null == closure)
				throw new ArgumentNullException(nameof(closure));
			if (null == result) result = new List<FA>();
			foreach (var fa in closure)
				if (fa.IsFinal)
					result.Add(fa);
			return result;
		}
		static IEnumerable<FA> _EnumFinals(IEnumerable<FA> closure)
		{
			foreach (var fa in closure)
				if (null != fa.AcceptingSymbol)
					yield return fa;
		}
		/// <summary>
		/// Lazy enumerates the final states.
		/// </summary>
		public IList<FA> Finals {
			get {
				return _EnumFinals(FillClosure()).AsList();
			}
		}
		/// <summary>
		/// Returns true if the state is an accepting state
		/// </summary>
		public bool IsAccepting { get { return null != AcceptingSymbol; } }
		/// <summary>
		/// Fills a list with all accepting states reachable from this state.
		/// </summary>
		/// <param name="result">The list to fill</param>
		/// <returns>Either <paramref name="result"/> or the new list filled with the accepting states</returns>
		public IList<FA> FillAccepting(IList<FA> result = null)
		{
			return FillAccepting(FillClosure(), result);
		}
		/// <summary>
		/// Fills a list with all accepting states reachable from the specified closure.
		/// </summary>
		/// <param name="closure">The closure of all states, or alternatively, a list of states to filter for accepting states.</param>
		/// <param name="result">The list to fill</param>
		/// <returns>Either <paramref name="result"/> or the new list filled with the accepting states</returns>
		public static IList<FA> FillAccepting(IEnumerable<FA> closure, IList<FA> result = null)
		{
			if (null == closure)
				throw new ArgumentNullException(nameof(closure));
			if (null == result) result = new List<FA>();
			foreach (var fa in closure)
				if (null != fa.AcceptingSymbol)
					result.Add(fa);
			return result;
		}
		static IEnumerable<FA> _EnumAccepting(IEnumerable<FA> closure)
		{
			foreach (var fa in closure)
				if (null != fa.AcceptingSymbol)
					yield return fa;
		}
		/// <summary>
		/// Lazy enumerates the accepting states
		/// </summary>
		public IList<FA> Accepting {
			get {
				return _EnumAccepting(FillClosure()).AsList();
			}
		}
		/// <summary>
		/// Reports if any of the specified states is an accepting state.
		/// </summary>
		/// <param name="states">The states to check</param>
		/// <returns>True if one or more of of the states in <paramref name="states"/> is an accepting state</returns>
		public static bool IsAnyAccepting(IEnumerable<FA> states)
		{
			foreach (var fa in states)
				if (fa.IsAccepting)
					return true;
			return false;
		}
		/// <summary>
		/// Fills a list with all accepting symbols reachable from this state.
		/// </summary>
		/// <param name="result">The list to fill, or null, to create a new list.</param>
		/// <returns>Either <paramref name="result"/> or the new list, filled with the accepting symbols</returns>
		public IList<object> FillAcceptingSymbols(IList<object> result = null)
		{
			return FillAcceptingSymbols(FillClosure(), result);
		}
		private static IEnumerable<object> _EnumAcceptingSymbols(IEnumerable<FA> closure)
		{
			foreach (var fa in closure)
				if (null != fa.AcceptingSymbol)
					yield return fa.AcceptingSymbol;
		}
		/// <summary>
		/// Lazy enumerates the accepting symbols
		/// </summary>
		public IList<object> AcceptingSymbols {
			get {
				return _EnumAcceptingSymbols(FillClosure()).AsList();
			}
		}
		/// <summary>
		/// Fills a list with all accepting symbols reachable from the specified closure.
		/// </summary>
		/// <param name="closure">The closure of all states, or alternatively, a collection of states from which to retrieve accepting symbols.</param>
		/// <param name="result">The list to fill</param>
		/// <returns>Either <paramref name="result"/> or the new list with the reachable accepting symbols</returns>
		public static IList<object> FillAcceptingSymbols(IEnumerable<FA> closure, IList<object> result = null)
		{
			if (null == result) result = new List<object>();
			foreach (var fa in closure)
				if (null != fa.AcceptingSymbol && !result.Contains(fa.AcceptingSymbol))
					result.Add(fa.AcceptingSymbol);
			return result;
		}
		/// <summary>
		/// Returns true if the machine contains no epsilon transitions
		/// </summary>
		public bool IsDfa {
			get {
				return _IsDfa(FillClosure());
			}
		}
		/// <summary>
		/// Returns true if this state is the start point of one or more loops
		/// </summary>
		public bool IsLoop {
			get {
				foreach (var dst in Transitions.Values)
				{
					if (dst.Closure.Contains(this))
						return true;
				}
				foreach (var dst in EpsilonTransitions)
				{
					if (dst.Closure.Contains(this))
						return true;
				}
				return false;
			}
		}
		/// <summary>
		/// Returns true if the machine matches exactly one string.
		/// </summary>
		public bool IsLiteral {
			get {
				if (IsLoop)
					return false;
				if (IsNeutral)
				{
					var fa = EpsilonTransitions[0];
					return fa.IsLiteral || fa.IsAccepting;
				}
				if (Transitions.Count == 1)
				{
					var fa = Transitions.Values.First();
					return fa.IsLiteral || fa.IsAccepting;
				}
				return false;
			}
		}
		static bool _IsDfa(IEnumerable<FA> closure)
		{
			if (null == closure) throw new ArgumentNullException(nameof(closure));
			foreach (var fa in closure)
			{
				if (0 != fa.EpsilonTransitions.Count)
					return false;
			}
			return true;
		}
		/// <summary>
		/// Tries to read the next match from the specied <see cref="Grimoire.ParseContext"/>, with capture
		/// </summary>
		/// <param name="pc">The parse context</param>
		/// <returns>True if the read was successful, otherwise false</returns>
		/// <remarks>The capture buffer will contain all characters consumed. After reading, the current character will either be the character immediately following the match, or the error character.</remarks>
		public bool TryRead(ParseContext pc)
		{
			pc.EnsureStarted();
			IList<FA> states = FillEpsilonClosure();
			bool isAccepting = IsAnyAccepting(states);
			if (-1 == pc.Current)
				return isAccepting; // accept an empty string?
			var next = new List<FA>(Math.Max(states.Count, 8));
			while (0 < states.Count)
			{
				int ch = pc.Current;
				next.Clear();
				foreach (var s in states)
				{
					FA n;
					char k = (char)ch;
					if (s.Transitions.TryGetValue(k, out n))
					{
						if (!next.Contains(n))
							next.Add(n);
					}
				}
				if (0 == next.Count)
					break;
				states = FillEpsilonClosure(next, null);
				isAccepting = IsAnyAccepting(states);
				pc.CaptureCurrent();
				if (-1 == pc.Advance())
					return isAccepting;
			}
			pc.Advance();
			return isAccepting;
		}
		/// <summary>
		/// Tries to skip the next match from the specied <see cref="Grimoire.ParseContext"/> with no capture
		/// </summary>
		/// <param name="pc">The parse context</param>
		/// <returns>True if the skip was successful, otherwise false</returns>
		/// <remarks>There is no mechanism for error recovery when using this method.</remarks>
		public bool TrySkip(ParseContext pc)
		{
			pc.EnsureStarted();
			IList<FA> states = FillEpsilonClosure();
			bool isAccepting = IsAnyAccepting(states);
			if (-1 == pc.Current)
				return isAccepting; // accept an empty string?
			var next = new List<FA>(Math.Max(states.Count, 8));
			while (0 < states.Count)
			{
				int ch = pc.Current;
				next.Clear();
				foreach (var s in states)
				{
					FA n;
					char k = (char)ch;
					if (s.Transitions.TryGetValue(k, out n))
					{
						if (!next.Contains(n))
							next.Add(n);
					}
				}
				if (0 == next.Count)
					break;
				states = FillEpsilonClosure(next, null);
				isAccepting = IsAnyAccepting(states);
				if (-1 == pc.Advance())
					return isAccepting;
			}
			pc.Advance();
			return isAccepting; // && 0==states.Count
		}
		static object _GetAcceptingSymbol(IEnumerable<FA> states, bool firstOnly = false)
		{
			var result = new List<object>();
			foreach (var fa in states)
			{
				if (null != fa.AcceptingSymbol)
				{
					var l = fa.AcceptingSymbol as IList<object>;
					if (null != l)
					{
						foreach (var s in l)
						{
							if (!result.Contains(s))
								result.Add(s);
							if (firstOnly)
								break;
						}
					}
					else
					{
						if (!result.Contains(fa.AcceptingSymbol))
							result.Add(fa.AcceptingSymbol);
					}
				}
			}
			switch (result.Count)
			{
				case 0:
					return null;
				case 1:
					return result[0];
				default:
					return (firstOnly) ? result.First() : result;
			}
		}
		static void _ExpectingDfat((KeyValuePair<char, char>[] Ranges, int Destination)[] trns, ParseContext pc)
		{
			var ranges = new List<KeyValuePair<char, char>>();
			for (int i = 0; i < trns.Length; ++i)
			{
				var trn = trns[i];
				for (int j = 0; j < trn.Item1.Length; ++j)
					ranges.Add(trn.Item1[j]);
			}
			pc.Expecting(_ExpandRanges(ranges).Convert<int>().ToArray());
		}
		static int _GetDfatTransition((KeyValuePair<char, char>[] Ranges, int Destination)[]trns, char ch)
		{
			for (int i = 0; i < trns.Length; ++i)
			{
				var trn = trns[i];
				for (int j = 0; j < trn.Item1.Length; ++j)
				{
					var rg = trn.Ranges[j];
					if (ch >= rg.Key && ch <= rg.Value)
						return trn.Destination;
				}
			}
			return -1; // no state
		}
		/// <summary>
		/// Lexes the the next token from the specifed <see cref="Grimoire.ParseContext"/>
		/// </summary>
		/// <param name="dfaTable">The DFA table to use for lexing</param>
		/// <param name="pc">The parse context to use</param>
		/// <param name="sb">The <see cref="System.Text.StringBuilder"/> that holds the result. If null, a new <see cref="System.Text.StringBuilder"/> will be created. Otherwise the passed in <see cref="System.Text.StringBuilder"/> will be cleared.</param>
		/// <returns>A <see cref="System.Collections.Generic.KeyValuePair" /> that contains the accepting symbol(s) and the captured string.</returns>
		/// <remarks>The capture buffer is not affected.</remarks>
		public static KeyValuePair<object, string> Lex((object Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] dfaTable, ParseContext pc, StringBuilder sb = null)
			=> Lex<object>(dfaTable, pc, sb);
		/// <summary>
		/// Lexes the the next token from the specifed <see cref="Grimoire.ParseContext"/>
		/// </summary>
		/// <typeparam name="TAccept">The type of the accepting symbols</typeparam>
		/// <param name="dfaTable">The DFA table to use for lexing</param>
		/// <param name="pc">The parse context to use</param>
		/// <param name="sb">The <see cref="System.Text.StringBuilder"/> that holds the result. If null, a new <see cref="System.Text.StringBuilder"/> will be created. Otherwise the passed in <see cref="System.Text.StringBuilder"/> will be cleared.</param>
		/// <returns>A <see cref="System.Collections.Generic.KeyValuePair" /> that contains the accepting symbol(s) and the captured string.</returns>
		/// <remarks>The capture buffer is not affected.</remarks>
		public static KeyValuePair<TAccept, string> Lex<TAccept>((TAccept Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] dfaTable, ParseContext pc, StringBuilder sb = null)
		{
			if (null == sb)
				sb = new StringBuilder();
			else
				sb.Clear();
			pc.EnsureStarted();
			int state = 0;
			var dfaEntry = dfaTable[state];
			object acc = dfaEntry.Item1;
			if (-1 == pc.Current)
			{
				if (null == acc)
					_ExpectingDfat(dfaEntry.Item2, pc);
				return new KeyValuePair<TAccept, string>(dfaEntry.Item1, sb.ToString());
			}
			while (true)
			{
				var ns = _GetDfatTransition(dfaEntry.Item2, (char)pc.Current);
				if (-1 == ns)
				{
					if (null == dfaEntry.Item1)
						_ExpectingDfat(dfaEntry.Item2, pc);
					if (typeof(TAccept)==typeof(int) || typeof(TAccept)==typeof(short) || typeof(TAccept)==typeof(long) || typeof(TAccept)==typeof(sbyte))
					{
						if (-1L == Convert.ToInt64(dfaEntry.Item1))
						{
							_ExpectingDfat(dfaEntry.Item2, pc);
						}
					}
					return new KeyValuePair<TAccept, string>(dfaEntry.Item1, sb.ToString());
				}
				state = ns;
				dfaEntry = dfaTable[state];
				if (-1 != pc.Current)
					sb.Append((char)pc.Current);
				if (-1 == pc.Advance())
				{
					if (null == dfaEntry.Item1)
						_ExpectingDfat(dfaEntry.Item2, pc);
					if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) || typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
					{
						if (-1L == Convert.ToInt64(dfaEntry.Item1))
							_ExpectingDfat(dfaEntry.Item2, pc);
					}
					return new KeyValuePair<TAccept, string>(dfaEntry.Item1, sb.ToString());
				}
			}
		}
		/// <summary>
		/// Lexes the the next token from the specifed <see cref="Grimoire.ParseContext"/>
		/// </summary>
		/// <param name="pc">The parse context to use</param>
		/// <param name="sb">The <see cref="System.Text.StringBuilder"/> that holds the result. If null, a new <see cref="System.Text.StringBuilder"/> will be created. Otherwise the passed in <see cref="System.Text.StringBuilder"/> will be cleared.
		/// <returns>A <see cref="System.Collections.Generic.KeyValuePair" /> that contains the accepting symbol(s) and the captured string.</returns>
		/// <remarks>The capture buffer is not affected.</remarks>
		[DebuggerHidden()]
		public KeyValuePair<object, string> Lex(ParseContext pc, StringBuilder sb = null)
		{
			if (null == sb)
				sb = new StringBuilder();
			else
				sb.Clear();
			pc.EnsureStarted();
			IList<FA> states = FillEpsilonClosure();
			bool isAccepting = IsAnyAccepting(states);
			if (-1 == pc.Current)
			{
				if (!isAccepting)
				{
					var ex = new List<int>();
					foreach (var s in states)
					{
						foreach (char ch in s.Transitions.Keys)
							ex.Add(ch);
					}
					pc.Expecting(ex.ToArray());
				}
				return new KeyValuePair<object, string>(_GetAcceptingSymbol(states, true), sb.ToString()); // accept an empty string?
			}
			var next = new List<FA>(Math.Max(states.Count, 8));
			while (0 < states.Count)
			{
				int ch = pc.Current;
				next.Clear();
				foreach (var s in states)
				{
					FA n;
					char k = (char)ch;
					if (s.Transitions.TryGetValue(k, out n))
					{
						if (!next.Contains(n))
							next.Add(n);
					}
				}
				if (0 == next.Count)
					break;
				sb.Append((char)pc.Current);
				states = FillEpsilonClosure(next, null);
				isAccepting = IsAnyAccepting(states);
				if (-1 == pc.Advance())
				{
					if (!isAccepting)
					{
						var ex = new List<int>();
						foreach (var s in states)
						{
							foreach (char ch2 in s.Transitions.Keys)
								ex.Add(ch2);
						}
						pc.Expecting(ex.ToArray());
					}
					return new KeyValuePair<object, string>(_GetAcceptingSymbol(states, true), sb.ToString());
				}
			}
			if (isAccepting)
			{
				return new KeyValuePair<object, string>(_GetAcceptingSymbol(states, true), sb.ToString()); // && 0==states.Count
			}
			else
			{
				var ex = new List<int>();
				foreach (var s in states)
				{
					foreach (char ch2 in s.Transitions.Keys)
						ex.Add(ch2);
				}
				pc.Expecting(ex.ToArray());
				throw new Exception("Failure in runtime lexer.");
			}
		}
		/// <summary>
		/// Attempts to lex the next token from the specified <see cref="Grimoire.ParseContext"/>, with capture
		/// </summary>
		/// <param name="pc">The parse context</param>
		/// <param name="result">The <see cref="System.Collections.KeyValuePair"/> that contains the token</param>
		/// <returns>True if successful, otherwise false. The capture contains the consumed input.</returns>
		/// <remarks>On success, the cursor is advanced past the token. On error, the current character is over the error.</remarks>
		public bool TryLex(ParseContext pc, out KeyValuePair<object, string> result)
		{
			int l = pc.CaptureBuffer.Length;
			pc.EnsureStarted();
			IList<FA> states = FillEpsilonClosure();
			bool isAccepting = IsAnyAccepting(states);
			if (-1 == pc.Current)
			{
				if (!isAccepting)
				{
					result = default(KeyValuePair<object, string>);
					return false;
				}
				result = new KeyValuePair<object, string>(_GetAcceptingSymbol(states, true), pc.GetCapture(l)); // accept an empty string?
				return true;
			}
			var next = new List<FA>(Math.Max(states.Count, 8));
			while (0 < states.Count)
			{
				int ch = pc.Current;
				next.Clear();
				foreach (var s in states)
				{
					FA n;
					char k = (char)ch;
					if (s.Transitions.TryGetValue(k, out n))
					{
						if (!next.Contains(n))
							next.Add(n);
					}
				}
				if (0 == next.Count)
					break;
				pc.CaptureCurrent();
				states = FillEpsilonClosure(next, null);
				isAccepting = IsAnyAccepting(states);
				if (-1 == pc.Advance())
				{
					if (!isAccepting)
					{
						result = default(KeyValuePair<object, string>);
						return false;
					}
					result = new KeyValuePair<object, string>(_GetAcceptingSymbol(states, true), pc.GetCapture(l));
					return true;
				}
			}
			result = new KeyValuePair<object, string>(_GetAcceptingSymbol(states, true), pc.GetCapture(l)); // && 0==states.Count
			return true;
		}
		/// <summary>
		/// Moves from the current <paramref name="states"/> to the next set of states based on <paramref name="input"/>
		/// </summary>
		/// <param name="states">The states to move from</param>
		/// <param name="input">The input to move on</param>
		/// <returns>The states moved to</returns>
		public static IList<FA> Move(IEnumerable<FA> states, char input)
		{
			var fas = FillEpsilonClosure(states);
			int fac = fas.Count;
			var result = new List<FA>();
			for (int i = 0; i < fac; ++i)
			{
				var fa = fas[i];
				FA dst;
				if (fa.Transitions.TryGetValue(input, out dst))
					if (!result.Contains(dst))
						result.Add(dst);
			}
			return result;
		}
		/// <summary>
		/// Writes a Lex method in C# 
		/// </summary>
		/// <param name="writer">The <see cref="TextWriter"/> with which to emit the code</param>
		/// <param name="name">The name of FSM. This name will be appended to the method name.</param>
		/// <param name="access">The access level of the generated function. Can be "public", "private", "internal" or "" or null</param>
		public void WriteCSharpLexMethodTo(TextWriter writer, string name, string access = null)
		{
			_WriteLexMethodTo(FillClosure(), writer, name, access, false);
		}
		/// <summary>
		/// Writes a Lex method in C#
		/// </summary>
		/// <param name="closure">The closure of all states</param>
		/// <param name="writer">The <see cref="TextWriter"/> with which to emit the code</param>
		/// <param name="name">The name of FSM. This name will be appended to the method name.</param>
		/// <param name="access">The access level of the generated function. Can be "public", "private", "internal" or "" or null</param>
		public static void WriteCSharpLexMethodTo(IEnumerable<FA> closure, TextWriter writer, string name, string access = null)
		{
			_WriteLexMethodTo(closure, writer, name, access, false);
		}
		/// <summary>
		/// Writes a TryLex method in C#
		/// </summary>
		/// <param name="writer">The <see cref="TextWriter"/> with which to emit the code</param>
		/// <param name="name">The name of FSM. This name will be appended to the method name.</param>
		/// <param name="access">The access level of the generated function. Can be "public", "private", "internal" or "" or null</param>
		public void WriteCSharpTryLexMethodTo(TextWriter writer, string name, string access = null)
		{
			_WriteLexMethodTo(FillClosure(), writer, name, access, true);
		}
		/// <summary>
		/// Writes a TryLex method in C#
		/// </summary>
		/// <param name="closure">The closure of all states</param>
		/// <param name="writer">The <see cref="TextWriter"/> with which to emit the code</param>
		/// <param name="name">The name of FSM. This name will be appended to the method name.</param>
		/// <param name="access">The access level of the generated function. Can be "public", "private", "internal" or "" or null</param>
		public static void WriteTryLexMethodTo(IEnumerable<FA> closure, TextWriter writer, string name, string access = null)
		{
			_WriteLexMethodTo(closure, writer, name, access, true);
		}
		public static void WriteCSharpDfaTableCreationExpressionTo(TextWriter writer, (object Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] dfaTable)
			=> WriteCSharpDfaTableCreationExpressionTo<object>(writer,dfaTable);
		public static void WriteCSharpDfaTableCreationExpressionTo<TAccept>(TextWriter writer,(TAccept Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] dfaTable)
		{
			writer.WriteLine(string.Concat("new (",typeof(TAccept).FullName," Accept, (System.Collections.Generic.KeyValuePair<char, char>[] Ranges, int Destination)[])[] {"));
			var delim = "";
			for (int i = 0; i < dfaTable.Length; ++i)
			{
				writer.Write(delim);
				var dfaEntry = dfaTable[i];
				writer.Write("\t");
				writer.WriteLine("(");
				writer.Write("\t\t");
				CSharpUtility.WriteCSharpLiteralTo(writer, dfaEntry.Item1);
				writer.WriteLine(",");
				writer.WriteLine("\t\tnew (System.Collections.Generic.KeyValuePair<char,char>[] Ranges,int Destination)[] {");
				var delim2 = "";
				for (int j = 0; j < dfaEntry.Item2.Length; ++j)
				{
					writer.Write(delim2);
					var trns = dfaEntry.Item2[j];
					writer.WriteLine("\t\t\t(");
					writer.WriteLine("\t\t\t\tnew System.Collections.Generic.KeyValuePair<char,char>[] {");
					var delim3 = "";
					for (int k = 0; k < trns.Item1.Length; ++k)
					{
						writer.Write(delim3);
						var rg = trns.Item1[k];
						writer.Write("\t\t\t\t\tnew System.Collections.Generic.KeyValuePair<char,char>(");
						CSharpUtility.WriteCSharpCharTo(writer, rg.Key);
						writer.Write(",");
						CSharpUtility.WriteCSharpCharTo(writer, rg.Value);
						writer.WriteLine(")");
						delim3 = ",";
					}
					writer.WriteLine("\t\t\t\t\t},");
					writer.Write("\t\t\t\t");
					writer.WriteLine(trns.Item2.ToString());
					writer.WriteLine("\t\t\t\t)");
					delim2 = ",";
				}
				writer.Write("}");
				writer.Write(")");
				delim = ",";
			}
			writer.WriteLine("}");
		}
#if CODEDOM
		static CodeExpression _MakeBinOps(IEnumerable exprs, CodeBinaryOperatorType type)
		{
			var result = new CodeBinaryOperatorExpression();
			foreach (CodeExpression expr in exprs)
			{
				result.Operator = type;
				if (null == result.Left)
				{
					result.Left = expr;
					continue;
				}
				if (null == result.Right)
				{
					result.Right = expr;
					continue;
				}
				result = new CodeBinaryOperatorExpression(result, type, expr);
			}
			if (null == result.Right)
				return result.Left;
			return result;
		}
		public static CodeArrayCreateExpression GenerateDfaTableCreationExpression(Tuple<object, Tuple<KeyValuePair<char, char>[], int>[]>[] dfaTable)
			=> GenerateDfaTableCreationExpression<object>(dfaTable);
		public static CodeArrayCreateExpression GenerateDfaTableCreationExpression<TAccept>(Tuple<TAccept, Tuple<KeyValuePair<char, char>[], int>[]>[] dfaTable)
		{
			var result = new CodeArrayCreateExpression();
			var rgtype = new CodeTypeReference(typeof(KeyValuePair<,>));
			rgtype.TypeArguments.Add(new CodeTypeReference(typeof(char)));
			rgtype.TypeArguments.Add(new CodeTypeReference(typeof(char)));
			var trntype = new CodeTypeReference(typeof(Tuple<,>));
			trntype.TypeArguments.Add(new CodeTypeReference(rgtype, 1));
			trntype.TypeArguments.Add(new CodeTypeReference(typeof(int)));
			var setype = new CodeTypeReference(typeof(Tuple<,>));
			setype.TypeArguments.Add(new CodeTypeReference(typeof(TAccept)));
			setype.TypeArguments.Add(new CodeTypeReference(trntype, 1));
			result.CreateType = setype;
			for (int i = 0; i < dfaTable.Length; ++i)
			{
				var dfaEntry = dfaTable[i];
				var ta = new CodeArrayCreateExpression(trntype);
				for (int j = 0; j < dfaEntry.Item2.Length; ++j)
				{
					var trn = dfaEntry.Item2[j];
					var ra = new CodeArrayCreateExpression(rgtype);
					for (int k = 0; k < trn.Item1.Length; ++k)
					{
						var rg = trn.Item1[k];
						ra.Initializers.Add(new CodeObjectCreateExpression(rgtype, new CodePrimitiveExpression(rg.Key), new CodePrimitiveExpression(rg.Value)));
					}
					ta.Initializers.Add(
						new CodeObjectCreateExpression(trntype, ra,
							new CodePrimitiveExpression(trn.Item2))
						);
				}
				result.Initializers.Add(new CodeObjectCreateExpression(
					setype, new CodePrimitiveExpression(dfaEntry.Item1),
					ta
					));
			}
			return result;
		}
		public CodeMemberMethod GenerateLexMethod(string name, MemberAttributes attributes)
		{
			return _GenerateLexMethod(FillClosure(), name, attributes, false);
		}
		public static CodeMemberMethod GenerateLexMethod(IEnumerable<FA> closure, string name, MemberAttributes attributes)
		{
			return _GenerateLexMethod(closure, name, attributes, false);
		}
		public CodeMemberMethod GenerateTryLexMethod(string name, MemberAttributes attributes)
		{
			return _GenerateLexMethod(FillClosure(), name, attributes, true);
		}
		public static CodeMemberMethod GenerateTryLexMethod(IEnumerable<FA> closure, string name, MemberAttributes attributes)
		{
			return _GenerateLexMethod(closure, name, attributes, true);
		}
		static CodeMemberMethod _GenerateLexMethod(IEnumerable<FA> closure, string name, MemberAttributes attributes, bool tryLex)
		{
			var result = new CodeMemberMethod();
			result.Attributes = attributes | MemberAttributes.Static;
			FA fa;
			fa = closure.First();
			if (!_IsDfa(closure))
			{
				fa = fa.ToDfa();
				fa.TrimDuplicates();
				closure = fa.FillClosure();
			}
			var al = FillAcceptingSymbols(closure, null);
			for (int j = 0; j < al.Count; ++j)
			{
				var e = al[j] as IEnumerable;
				if (al[j] is string) e = null;
				if (null != e)
				{
					al[j] = e.First();
				}
			}
			Type t = al.InferElementType();
			var cet = new CodeTypeReference(t);
			var kvpt = new CodeTypeReference(typeof(KeyValuePair<,>));
			kvpt.TypeArguments.Add(t);
			kvpt.TypeArguments.Add(typeof(string));
			if (!tryLex)
			{
				result.ReturnType = kvpt;
				result.Name = string.Concat("Lex", name);
				var pcp = new CodeParameterDeclarationExpression(typeof(ParseContext), "pc");
				result.Parameters.Add(pcp);
				var sbp = new CodeParameterDeclarationExpression(typeof(StringBuilder), "sb");
				result.Parameters.Add(sbp);
			}
			else
			{
				result.ReturnType = new CodeTypeReference(typeof(bool));
				result.Name = string.Concat("TryLex", name);
				var pcp = new CodeParameterDeclarationExpression(typeof(ParseContext), "pc");
				result.Parameters.Add(pcp);
				var resp = new CodeParameterDeclarationExpression(kvpt, "result");
				resp.Direction = FieldDirection.Out;
				result.Parameters.Add(resp);
			}
			var ld = new CodeVariableDeclarationStatement(typeof(int), "l");
			var lr = new CodeVariableReferenceExpression(ld.Name);
			var pcr = new CodeArgumentReferenceExpression(result.Parameters[0].Name);
			var stmts = result.Statements;
			stmts.Add(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(pcr, "EnsureStarted")));
			if (!tryLex)
			{
				var ccs = new CodeConditionStatement(
					new CodeBinaryOperatorExpression(
						new CodePrimitiveExpression(null),
						CodeBinaryOperatorType.IdentityEquality,
						new CodeArgumentReferenceExpression(result.Parameters[1].Name)
						)
					);
				ccs.TrueStatements.Add(
						new CodeAssignStatement(
							new CodeArgumentReferenceExpression(result.Parameters[1].Name),
							new CodeObjectCreateExpression(new CodeTypeReference(typeof(StringBuilder)))
						)
					);
				ccs.FalseStatements.Add(
					new CodeMethodInvokeExpression(
						new CodeMethodReferenceExpression(
								new CodeArgumentReferenceExpression(result.Parameters[1].Name),
								"Clear"
							)
						)
					);
				stmts.Add(ccs);
			}
			else
			{
				ld.InitExpression = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(pcr, "Capture"), "Length");
				stmts.Add(ld);
			}
			int i = 0;
			foreach (var ffa in closure)
			{
				if (0 != i || ffa.IsLoop)
				{
					stmts.Add(new CodeLabeledStatement("q" + i.ToString(), new CodeCommentStatement("state q" + i.ToString())));
				}
				else
					stmts.Add(new CodeCommentStatement("state q" + i.ToString()));
				var itr = ffa.FillInputTransitionRangesGroupedByState(null);
				var ranges = new List<KeyValuePair<char, char>>();
				foreach (var kvp in itr)
				{
					var pccr = new CodePropertyReferenceExpression(new CodeArgumentReferenceExpression(result.Parameters[0].Name), "Current");
					var cif = new CodeConditionStatement();
					stmts.Add(cif);
					var exprs = new CodeExpressionCollection();
					//w.Write("\tif(");
					foreach (var rg in kvp.Value) // each range in ranges
					{
						ranges.Add(rg);
						if (!rg.Key.Equals(rg.Value))
						{
							exprs.Add(
								new CodeBinaryOperatorExpression(
									new CodeBinaryOperatorExpression(
										pccr,
										CodeBinaryOperatorType.GreaterThanOrEqual,
										new CodePrimitiveExpression((int)rg.Key)
										),
									CodeBinaryOperatorType.BooleanAnd,
									new CodeBinaryOperatorExpression(
										pccr,
										CodeBinaryOperatorType.LessThanOrEqual,
										new CodePrimitiveExpression((int)rg.Value)
										)
									)
								);
						}
						else
						{
							exprs.Add(
								new CodeBinaryOperatorExpression(
									pccr,
									CodeBinaryOperatorType.ValueEquality,
									new CodePrimitiveExpression((int)rg.Key)
									)
								);
						}
					}
					var sbr = new CodeArgumentReferenceExpression(result.Parameters[1].Name);
					cif.Condition = _MakeBinOps(exprs, CodeBinaryOperatorType.BooleanOr);
					if (!tryLex)
					{
						cif.TrueStatements.Add(
							new CodeMethodInvokeExpression(sbr, "Append", new CodeCastExpression(typeof(char), pccr))
							);
					}
					else
					{
						cif.TrueStatements.Add(
						new CodeMethodInvokeExpression(pcr, "CaptureCurrent")
						);
					}
					cif.TrueStatements.Add(
						new CodeMethodInvokeExpression(pcr, "Advance")
						);
					cif.TrueStatements.Add(
						new CodeGotoStatement("q" + closure.IndexOf(kvp.Key))
						);
				}
				if (ffa.IsAccepting)
				{
					var o = ffa.AcceptingSymbol;
					var e = o as IEnumerable;
					if (o is string) e = null;
					if (null != e)
						o = e.First();
					CodeExpression capt;
					if (!tryLex)
					{
						capt = new CodeMethodInvokeExpression(new CodeArgumentReferenceExpression(result.Parameters[1].Name), "ToString");
					}
					else
					{
						capt = new CodeMethodInvokeExpression(pcr, "GetCapture", lr);
					}
					var robj = new CodeObjectCreateExpression(kvpt, new CodePrimitiveExpression(o), capt);
					if (tryLex)
					{
						stmts.Add(new CodeAssignStatement(new CodeArgumentReferenceExpression(result.Parameters[1].Name), robj));
						stmts.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
					}
					else
					{
						stmts.Add(new CodeMethodReturnStatement(robj));
					}
				}
				else
				{
					if (!tryLex)
					{
						var es = new CodeMethodInvokeExpression(pcr, "Expecting");
						foreach (char ch in _ExpandRanges(ranges))
							es.Parameters.Add(new CodePrimitiveExpression(ch));
						stmts.Add(es);
						stmts.Add(new CodeMethodReturnStatement(new CodeDefaultValueExpression(kvpt)));
					}
					else
					{
						stmts.Add(new CodeAssignStatement(new CodeArgumentReferenceExpression(result.Parameters[1].Name), new CodeDefaultValueExpression(kvpt)));
						stmts.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
					}
				}
				++i;
			}
			return result;
		}
#endif
		static void _WriteLexMethodTo(IEnumerable<FA> closure, TextWriter w, string name, string access, bool tryLex)
		{
			FA fa;
			fa = closure.First();
			if (!_IsDfa(closure))
			{
				fa = fa.ToDfa();
				fa.TrimDuplicates();
				closure = fa.FillClosure();
			}
			var al = FillAcceptingSymbols(closure, null);
			for (int j = 0; j < al.Count; ++j)
			{
				var e = al[j] as IEnumerable;
				if (al[j] is string) e = null;
				if (null != e)
				{
					al[j] = e.First();
				}
			}
			Type t = al.InferElementType();
			if (!string.IsNullOrEmpty(access))
			{
				w.Write(access);
				w.Write(" ");
			}
			if (!tryLex)
				w.Write("System.Collections.Generic.KeyValuePair<{0},string> Lex{1}(Grimoire.ParseContext pc, System.Text.StringBuilder sb=null) ", t.FullName, name);
			else
			{
				w.Write("bool TryLex{1}(Grimoire.ParseContext pc, out System.Collections.Generic.KeyValuePair<{0},string> result) ", t.FullName, name);
			}
			w.WriteLine("{");
			w.WriteLine("\tpc.EnsureStarted();");
			if (!tryLex)
				w.WriteLine("\tif(null==sb) sb = new System.Text.StringBuilder(); else sb.Clear();");
			else
				w.WriteLine("\tint l = pc.CaptureBuffer.Length;");
			int i = 0;
			foreach (var ffa in closure)
			{
				if (0 != i || ffa.IsLoop)
					w.WriteLine("q{0}:", i);
				var itr = ffa.FillInputTransitionRangesGroupedByState(null);
				var ranges = new List<KeyValuePair<char, char>>();
				foreach (var kvp in itr)
				{
					w.Write("\tif(");
					string delim = "";
					foreach (var rg in kvp.Value) // each range in ranges
					{
						ranges.Add(rg);
						w.Write(delim);
						if (!rg.Key.Equals(rg.Value))
						{
							w.Write("(pc.Current>=");
							CSharpUtility.WriteCSharpLiteralTo(w, rg.Key);
							w.Write("&& pc.Current<=");
							CSharpUtility.WriteCSharpLiteralTo(w, rg.Value);
							w.Write(")");
						}
						else
						{
							w.Write("(pc.Current==");
							CSharpUtility.WriteCSharpLiteralTo(w, rg.Key);
							w.Write(")");
						}
						delim = string.Concat("||", Environment.NewLine, "\t\t");
					}
					w.WriteLine(") {");
					if (!tryLex)
						w.WriteLine("\t\tsb.Append((char)pc.Current);");
					else
						w.WriteLine("\t\tpc.CaptureCurrent();");
					w.WriteLine("\t\tpc.Advance();");
					w.WriteLine("\t\tgoto q{0};", closure.IndexOf(kvp.Key));
					w.WriteLine("\t}");
				}
				if (ffa.IsAccepting)
				{
					if (tryLex)
						w.Write("\tresult=");
					else
						w.Write("\treturn ");
					w.Write("new System.Collections.Generic.KeyValuePair<{0},string>(", t.FullName);
					var o = ffa.AcceptingSymbol;
					var e = o as IEnumerable;
					if (o is string) e = null;
					if (null != e)
						o = e.First();
					CSharpUtility.WriteCSharpLiteralTo(w, o);
					if (!tryLex)
						w.WriteLine(",sb.ToString());");
					else
					{
						w.WriteLine(",pc.GetCapture(l));");
						w.WriteLine("\treturn true;");
					}
				}
				else
				{
					if (!tryLex)
					{
						w.Write("\tpc.ThrowExpectingRanges(new int[] {");
						var delim = "";
						var j = 0;
						foreach (var kvp in ranges)
						{
							w.Write(delim);
							if (-1 == kvp.Key)
								w.Write("-1");
							else
								CSharpUtility.WriteCSharpCharTo(w, kvp.Key);
							w.Write(",");
							if (-1 == kvp.Value)
								w.Write("-1");
							else
								CSharpUtility.WriteCSharpCharTo(w, kvp.Value);
							delim = ",";
							if (49 == j)
							{
								j = 0;
								delim = Environment.NewLine + ",";
							}
							++j;
						}
						w.WriteLine("});");
						if (tryLex)
							w.Write("\tresult=");
						else
							w.Write("\treturn ");
						w.WriteLine("default(System.Collections.Generic.KeyValuePair<{0},string>);", t.FullName);
						if (tryLex)
							w.WriteLine("\treturn false;");
					}
					else
					{
						w.WriteLine("\tresult=default(System.Collections.Generic.KeyValuePair<{0},string>);", t.FullName);
						w.WriteLine("\treturn false;");
					}
				}
				++i;
			}
			w.WriteLine("}");
		}
		/// <summary>
		/// Returns a <see cref="IDictionary{FA,IList{KeyValuePair{Char,Char}}}"/>, keyed by state, that contains all of the outgoing local input transitions, expressed as a series of ranges
		/// </summary>
		/// <param name="result">The <see cref="IDictionary{FA,IList{KeyValuePair{Char,Char}}}"/> to fill, or null to create one.</param>
		/// <returns>A <see cref="IDictionary{FA,IList{KeyValuePair{Char,Char}}}"/> containing the result of the query</returns>
		public IDictionary<FA, IList<KeyValuePair<char, char>>> FillInputTransitionRangesGroupedByState(IDictionary<FA, IList<KeyValuePair<char, char>>> result = null)
		{
			if (null == result)
				result = new Dictionary<FA, IList<KeyValuePair<char, char>>>();
			/*foreach (var trns in Transitions)
			{
				IList<KeyValuePair<char, char>> ranges;
				if (result.TryGetValue(trns.Value as FA, out ranges))
				{
					_AddValueToRanges(ranges, trns.Key);
				}
				else
				{
					ranges = new List<KeyValuePair<char, char>>();
					ranges.Add(new KeyValuePair<char, char>(trns.Key, trns.Key));
					result.Add(trns.Value as FA, ranges);
				}
			}*/
			// using the optimized dictionary we have little to do here.
			foreach (var trns in (IDictionary<FA, ICollection<char>>)Transitions)
			{
				result.Add(trns.Key, new List<KeyValuePair<char, char>>(_GetRanges(trns.Value)));
			}
			return result;
		}
		/// <summary>
		/// Fills a list with the references to <paramref name="target"/> from the state machine indicated by <paramref name="closure"/>
		/// </summary>
		/// <param name="closure">The set of all states</param>
		/// <param name="target">The state to find the references for</param>
		/// <param name="result">A list to fill with the states that refer to <paramref name="target"/>, or null for a new list to be created</param>
		/// <returns>The new list, or the passed in list, filled with states that refer to <paramref name="target"/></returns>
		public static IList<FA> FillReferences(IEnumerable<FA> closure, FA target, IList<FA> result = null)
		{
			if (null == result)
				result = new List<FA>();
			foreach (var fa in closure)
			{
				if (!result.Contains(fa))
				{
					var found = false;
					foreach (var trns in (IDictionary<FA, ICollection<char>>)fa.Transitions)
					{
						if (trns.Key == target)
						{
							found = true;
							result.Add(fa);
							break;
						}
					}
					if (!found)
					{
						foreach (var efa in fa.EpsilonTransitions)
						{
							if (efa == target)
							{
								result.Add(fa);
								break;
							}
						}
					}
				}
			}
			return result;
		}
		/// <summary>
		/// Indicates if two states are duplicates of each other
		/// </summary>
		/// <param name="rhs">The <see cref="FA"/> to compare</param>
		/// <returns>True if the two states are duplicates, otherwise false.</returns>
		public bool IsDuplicate(FA rhs)
		{
			return null != rhs &&
				AcceptingSymbol == rhs.AcceptingSymbol &&
				_SetComparer.Default.Equals((ICollection<FA>)EpsilonTransitions, rhs.EpsilonTransitions) &&
				_SetComparer.Default.Equals((IDictionary<FA, ICollection<char>>)Transitions, (IDictionary<FA, ICollection<char>>)rhs.Transitions);
		}
		/// <summary>
		/// Fills a <see cref="IDictionary{FA, ICollection{FA}}"/> with all duplicates in this machine, grouped by each duplicate state
		/// </summary>
		/// <param name="result">The <see cref="IDictionary{FA, ICollection{FA}}"/> to fill, or null to create a new one</param>
		/// <returns>The <see cref="IDictionary{FA, ICollection{FA}}"/> containing the duplicates</returns>
		public IDictionary<FA, ICollection<FA>> FillDuplicatesGroupedByState(IDictionary<FA, ICollection<FA>> result)
		{
			return FillDuplicatesGroupedByState(FillClosure(), result);
		}
		/// <summary>
		/// Fills a <see cref="IDictionary{FA, ICollection{FA}}"/> with all duplicates in the closure, grouped by each duplicate state
		/// </summary>
		/// <param name="closure">The closure of all states</param>
		/// <param name="result">The <see cref="IDictionary{FA, ICollection{FA}}"/> to fill, or null to create a new one</param>
		/// <returns>The <see cref="IDictionary{FA, ICollection{FA}}"/> containing the duplicates</returns>
		public static IDictionary<FA, ICollection<FA>> FillDuplicatesGroupedByState(IEnumerable<FA> closure, IDictionary<FA, ICollection<FA>> result)
		{
			if (null == closure)
				throw new ArgumentNullException(nameof(closure));
			if (null == result)
				result = new Dictionary<FA, ICollection<FA>>();
			IList<FA> cl = closure as IList<FA> ?? new List<FA>(closure);
			int c = cl.Count;
			for (int i = 0; i < c; i++)
			{
				var s = cl[i];
				for (int j = i + 1; j < c; j++)
				{
					var cmp = cl[j];
					if (s.IsDuplicate(cmp))
					{
						ICollection<FA> col = new List<FA>();
						if (!result.ContainsKey(s))
							result.Add(s, col);
						else
							col = result[s];
						if (!col.Contains(cmp))
							col.Add(cmp);
					}
				}
			}
			return result;
		}
		/// <summary>
		/// Finds all of the loop points in the specified machine
		/// </summary>
		/// <param name="closure">The set of all states that represent the machine</param>
		/// <param name="result">Null, or a list to fill with <see cref="KeyValuePair{FA,FA}"/> entries</param>
		/// <returns>The list of <see cref="KeyValuePair{FA,FA}"/> entries where Key is the start of the loop, and Value is the end of the loop. Keys may be duplicated.</returns>
		public static IList<KeyValuePair<FA, FA>> FillLoops(IEnumerable<FA> closure, IList<KeyValuePair<FA, FA>> result = null)
		{
			if (null == result)
				result = new List<KeyValuePair<FA, FA>>();
			var cl = closure.AsList();
			var i = 0;
			foreach (var ffa in cl)
			{
				foreach (var rfa in FA.FillReferences(cl, ffa))
				{
					var ri = cl.IndexOf(rfa);
					if (!(ri < i || !ffa.IsLoop))
						result.Add(new KeyValuePair<FA, FA>(ffa, rfa));
				}
				++i;
			}
			return result;
		}
		/// <summary>
		/// Removes duplicate states from this machine
		/// </summary>
		public void TrimDuplicates()
		{
			TrimDuplicates(FillClosure());
		}
		/// <summary>
		/// Removes duplicate states from this machine
		/// </summary>
		/// <param name="closure">The set of all states</param>
		public static void TrimDuplicates(IEnumerable<FA> closure)
		{
			IList<FA> lclosure = new List<FA>(closure);
			var dups = new Dictionary<FA, ICollection<FA>>();
			int oc = 0;
			int c = -1;
			while (c < oc)
			{
				c = lclosure.Count;
				FillDuplicatesGroupedByState(lclosure, dups);
				if (0 < dups.Count)
				{
					foreach (KeyValuePair<FA, ICollection<FA>> de in dups)
					{
						var replacement = de.Key;
						var targets = de.Value;
						for (int i = 0; i < c; ++i)
						{
							var s = lclosure[i];
							var repls = new List<KeyValuePair<FA, FA>>();
							var td = (IDictionary<FA, ICollection<char>>)s.Transitions;
							foreach (var trns in td)
								if (targets.Contains(trns.Key))
									repls.Add(new KeyValuePair<FA, FA>(trns.Key, replacement));
							foreach (var repl in repls)
							{
								var inps = td[repl.Key];
								td.Remove(repl.Key);
								td.Add(repl.Value, inps);
							}
							int lc = s.EpsilonTransitions.Count;
							for (int j = 0; j < lc; ++j)
								if (targets.Contains(s.EpsilonTransitions[j]))
									s.EpsilonTransitions[j] = de.Key;
						}
					}
					dups.Clear();
				}
				else
					break;
				oc = c;
				var f = lclosure[0];
				//lclosure.Clear();
				lclosure = f.FillClosure();
				c = lclosure.Count;
			}
		}
		static IEnumerable<char> _ExpandRange(KeyValuePair<char, char> range)
		{
			if (range.Value < range.Key)
				for (int i = range.Value; i >= range.Key; --i)
					yield return (char)i;
			else
				for (int i = range.Key; i <= range.Value; ++i)
					yield return (char)i;
		}
		static IEnumerable<char> _ExpandRanges(IEnumerable<KeyValuePair<char, char>> ranges)
		{
			foreach (var range in ranges)
				foreach (char ch in _ExpandRange(range))
					yield return ch;
		}
		static IEnumerable<KeyValuePair<char, char>> _GetRanges(IEnumerable<char> sortedString)
		{
			char first = '\0';
			char last = '\0';
			using (IEnumerator<char> e = sortedString.GetEnumerator())
			{
				bool moved = e.MoveNext();
				while (moved)
				{
					first = last = e.Current;
					while ((moved = e.MoveNext()) && (e.Current == last || e.Current == last + 1))
					{
						last = e.Current;
					}
					yield return new KeyValuePair<char, char>(first, last);
				}
			}
		}
		static IEnumerable<KeyValuePair<char, char>> _NotRanges(IEnumerable<KeyValuePair<char, char>> ranges)
		{
			// expects ranges to be normalized
			var last = char.MaxValue;
			using (var e = ranges.GetEnumerator())
			{
				if (!e.MoveNext())
				{
					yield return new KeyValuePair<char, char>(char.MinValue, char.MaxValue);
					yield break;
				}
				if (e.Current.Key > char.MinValue)
				{
					yield return new KeyValuePair<char, char>(char.MinValue, unchecked((char)(e.Current.Key - 1)));
					last = e.Current.Value;
					if (char.MaxValue == last)
						yield break;
				}
				while (e.MoveNext())
				{
					if (char.MaxValue == last)
						yield break;
					if (unchecked((char)(last + 1)) < e.Current.Key)
					{
						yield return new KeyValuePair<char, char>(unchecked((char)(last + 1)), unchecked((char)(e.Current.Key - 1)));
					}
					last = e.Current.Value;
				}
				if (char.MaxValue > last)
				{
					yield return new KeyValuePair<char, char>(unchecked((char)(last + 1)), char.MaxValue);
					// last = char.MaxValue;
				}
			}
		}
		static void _NormalizeRanges(List<KeyValuePair<char, char>> ranges)
		{
			for (int i = 0; i < ranges.Count; ++i)
				if (ranges[i].Key > ranges[i].Value)
					ranges[i] = new KeyValuePair<char, char>(ranges[i].Value, ranges[i].Key);
			ranges.Sort(delegate (KeyValuePair<char, char> left, KeyValuePair<char, char> right)
			{
				return left.Key.CompareTo(right.Key);
			});
			var or = default(KeyValuePair<char, char>);
			for (int i = 1; i < ranges.Count; ++i)
			{
				if (ranges[i - 1].Value >= ranges[i].Key)
				{
					var nr = new KeyValuePair<char, char>(ranges[i - 1].Key, ranges[i].Value);
					ranges[i - 1] = or = nr;
					ranges.RemoveAt(i);
					--i; // compensated for by ++i in for loop
				}
			}
		}
		static char _ReadRangeChar(IEnumerator<char> e)
		{
			char ch;
			if ('\\' != e.Current || !e.MoveNext())
			{
				return e.Current;
			}
			ch = e.Current;
			switch (ch)
			{
				case 't':
					ch = '\t';
					break;
				case 'n':
					ch = '\n';
					break;
				case 'r':
					ch = '\r';
					break;
				case '0':
					ch = '\0';
					break;
				case 'v':
					ch = '\v';
					break;
				case 'f':
					ch = '\f';
					break;
				case 'b':
					ch = '\b';
					break;
				case 'x':
					byte x = _FromHexChar(ch);
					if (!e.MoveNext())
					{
						ch = unchecked((char)x);
						return ch;
					}
					x *= 0x10;
					x += _FromHexChar(e.Current);
					ch = unchecked((char)x);
					break;
				case 'u':
					ushort u = _FromHexChar(ch);
					if (!e.MoveNext())
					{
						ch = unchecked((char)u);
						return ch;
					}
					u *= 0x10;
					u += _FromHexChar(e.Current);
					if (!e.MoveNext())
					{
						ch = unchecked((char)u);
						return ch;
					}
					u *= 0x10;
					u += _FromHexChar(e.Current);
					if (!e.MoveNext())
					{
						ch = unchecked((char)u);
						return ch;
					}
					u *= 0x10;
					u += _FromHexChar(e.Current);
					ch = unchecked((char)u);
					break;
				default: // return itself
					break;
			}
			return ch;
		}
		static byte _FromHexChar(char hex)
		{
			if (':' > hex && '/' < hex)
				return (byte)(hex - '0');
			if ('G' > hex && '@' < hex)
				return (byte)(hex - '7'); // 'A'-10
			if ('g' > hex && '`' < hex)
				return (byte)(hex - 'W'); // 'a'-10
			throw new ArgumentException("The value was not hex.", "hex");
		}
		static IEnumerable<KeyValuePair<char, char>> _ParseRanges(IEnumerable<char> charRanges, bool normalize)
		{
			if (!normalize)
				return _ParseRanges(charRanges);
			else
			{
				var result = new List<KeyValuePair<char, char>>(_ParseRanges(charRanges));
				_NormalizeRanges(result);
				return result;
			}
		}
		static IEnumerable<KeyValuePair<char, char>> _ParseRanges(IEnumerable<char> charRanges)
		{
			using (var e = charRanges.GetEnumerator())
			{
				var skipRead = false;
				while (skipRead || e.MoveNext())
				{
					skipRead = false;
					char first = _ReadRangeChar(e);
					if (e.MoveNext())
					{
						if ('-' == e.Current)
						{
							if (e.MoveNext())
								yield return new KeyValuePair<char, char>(first, _ReadRangeChar(e));
							else
							{
								yield return new KeyValuePair<char, char>('-', '-');
							}
						}
						else
						{
							yield return new KeyValuePair<char, char>(first, first);
							skipRead = true;
							continue;
						}
					}
					else
					{
						yield return new KeyValuePair<char, char>(first, first);
						yield break;
					}
				}
			}
			yield break;
		}
		static void _Literal(FA first, FA final, IEnumerable<char> @string)
		{
			var current = first;
			var l = new List<char>(@string);
			int i;
			for (i = 0; i < l.Count - 1; ++i)
			{
				var fa = new FA();
				current.Transitions.Add(l[i], fa);
				current = fa;
			}
			current.Transitions.Add(l[i], final);
		}
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified literal
		/// </summary>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <param name="string">The string to match</param>
		/// <returns>A new machine that matches the <paramref name="string"/></returns>
		public static FA Literal(object accepting, params char[] @string) => Literal(@string, accepting);
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified literal
		/// </summary>
		/// <param name="string">The string to match</param>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <returns>A new machine that matches the <paramref name="string"/></returns>
		public static FA Literal(IEnumerable<char> @string, object accepting = null)
		{
			var result = new FA();
			if (null == accepting) accepting = result;
			if (@string.IsNullOrEmpty())
			{
				result.AcceptingSymbol = accepting;
				return result;
			}
			var final = new FA();
			final.AcceptingSymbol = accepting;
			_Literal(result, final, @string);
			return result;
		}
		static void _Set(FA first, FA final, IEnumerable<char> inputs)
		{
			foreach (var input in inputs)
				first.Transitions.Add(input, final);
		}
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified set
		/// </summary>
		/// <param name="charRanges">The character ranges to match</param>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <returns>A new machine that matches the <paramref name="charRanges"/></returns>
		public static FA Set(IEnumerable<KeyValuePair<char, char>> charRanges, object accepting = null)
		{
			return FA.Set(_ExpandRanges(charRanges), accepting);
		}
		public static FA Set(object accepting, params char[] inputs) => Set(inputs, accepting);
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified set
		/// </summary>
		/// <param name="inputs">The input characters to match</param>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <returns>A new machine that matches the <paramref name="inputs"/></returns>
		public static FA Set(IEnumerable<char> inputs, object accepting = null)
		{
			var result = new FA();
			if (null == accepting) accepting = result;
			if (inputs.IsNullOrEmpty())
			{
				result.AcceptingSymbol = accepting;
				return result;
			}
			var final = new FA();
			final.AcceptingSymbol = accepting;
			_Set(result, final, inputs);
			return result;
		}
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified union
		/// </summary>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <param name="exprs">The expressions to match</param>
		/// <returns>A new machine that matches the <paramref name="exprs"/></returns>
		public static FA Or(object accepting, params FA[] exprs) => Or(exprs, accepting);
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified union
		/// </summary>
		/// <param name="exprs">The expressions to match</param>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <returns>A new machine that matches the <paramref name="exprs"/></returns>
		public static FA Or(IEnumerable<FA> exprs, object accepting = null)
		{
			var result = new FA();
			if (null == accepting) accepting = result;
			if (exprs.IsNullOrEmpty())
			{
				result.AcceptingSymbol = accepting;
				return result;
			}
			var final = new FA();
			final.AcceptingSymbol = accepting;
			foreach (var fa in exprs)
			{
				if (null != fa)
				{
					foreach (var afa in fa.Accepting)
					{
						afa.AcceptingSymbol = null;
						afa.EpsilonTransitions.Add(final);
					}
					result.EpsilonTransitions.Add(fa);
				}
				else if (!result.EpsilonTransitions.Contains(final))
					result.EpsilonTransitions.Add(final);
			}
			return result;
		}
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified sequence
		/// </summary>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <param name="exprs">The expressions to match</param>
		/// <returns>A new machine that matches the <paramref name="exprs"/></returns>
		public static FA Concat(object accepting, params FA[] exprs) => Concat(exprs, accepting);
		/// <summary>
		/// Creates a new generalized NFA (Thompson construction) matching the specified sequence
		/// </summary>
		/// <param name="exprs">The expressions to match</param>
		/// <param name="accepting">The symbol reported on accept</param>
		/// <returns>A new machine that matches the <paramref name="exprs"/></returns>
		public static FA Concat(IEnumerable<FA> exprs, object accepting = null)
		{
			var result = new FA();
			if (null == accepting) accepting = result;
			if (exprs.IsNullOrEmpty())
			{
				result.AcceptingSymbol = accepting;
				return result;
			}
			FA left = null, right = null;
			foreach (var fa in exprs)
			{
				if (null == left)
				{
					left = fa;
					result = left;
					continue;
				}
				else right = fa;
				foreach (var afa in left.Accepting)
				{
					afa.AcceptingSymbol = null;
					afa.EpsilonTransitions.Add(right);
				}
				left = right;
			}
			foreach (var afa in left.Accepting)
			{
				afa.AcceptingSymbol = accepting;
			}
			return result;
		}
		/// <summary>
		/// Makes the specified machine optional
		/// </summary>
		/// <param name="fa">The machine</param>
		/// <param name="accepting">The symbol to report on accept</param>
		/// <returns>The modified machine</returns>
		public static FA Optional(FA fa, object accepting = null)
		{
			var final = new FA();
			final.AcceptingSymbol = accepting ?? fa;
			foreach (var afa in fa.Accepting)
			{
				afa.AcceptingSymbol = null;
				afa.EpsilonTransitions.Add(final);
			}
			fa.EpsilonTransitions.Add(final);
			return fa;
		}
		public static FA Repeat(FA fa, object accepting)
		{
			return Repeat(fa, 1, 0, accepting);
		}
		/// <summary>
		/// Makes the specified machine repeat one or more times
		/// </summary>
		/// <param name="fa">The machine</param>
		/// <param name="accepting">The symbol to report on accept</param>
		/// <returns>The modified machine</returns>
		public static FA Repeat(FA fa, int min = 0, int max = 0, object accepting = null)
		{
			accepting = accepting ?? fa;
			if (min != 0 && max != 0 && min > max)
				throw new ArgumentOutOfRangeException(nameof(max));
			switch (min)
			{
				case 0:
					switch (max)
					{
						case 0:
							var result = new FA();
							var final = new FA();
							final.AcceptingSymbol = accepting ?? result;
							final.EpsilonTransitions.Add(result);
							foreach (var afa in fa.Accepting)
							{
								afa.AcceptingSymbol = null;
								afa.EpsilonTransitions.Add(final);
							}
							result.EpsilonTransitions.Add(fa);
							result.EpsilonTransitions.Add(final);
							return result;
						case 1:
							return Optional(fa, accepting);
						default:
							var l = new List<FA>();
							fa = Optional(fa);
							l.Add(fa);
							for (int i = 1; i < max; ++i)
							{
								l.Add(fa.Clone());
							}
							return Concat(l, accepting);
					}
				case 1:
					switch (max)
					{
						case 0:
							var result = new FA();
							var final = new FA();
							final.AcceptingSymbol = accepting;
							final.EpsilonTransitions.Add(result);
							foreach (var afa in fa.Accepting)
							{
								afa.AcceptingSymbol = null;
								afa.EpsilonTransitions.Add(final);
							}
							result.EpsilonTransitions.Add(fa);
							return result;
						case 1:
							return fa;
						default:
							return Concat(accepting, fa, Repeat(fa.Clone(), 0, max - 1));
					}
				default:
					switch (max)
					{
						case 0:
							return Concat(accepting, Repeat(fa, min, min, accepting), Repeat(fa, 0, 0, accepting));
						case 1:
							throw new ArgumentOutOfRangeException(nameof(max));
						default:
							if (min == max)
							{
								var l = new List<FA>();
								l.Add(fa);
								for (int i = 1; i < min; ++i)
									l.Add(fa.Clone());
								return Concat(l, accepting);
							}
							return Concat(accepting, Repeat(fa.Clone(), min, min, accepting), Repeat(FA.Optional(fa.Clone()), max - min, max - min, accepting));
					}
			}
			// should never get here
			throw new NotImplementedException();
		}
		/// <summary>
		/// Makes the specified machine repeat zero or more times
		/// </summary>
		/// <param name="fa">The machine</param>
		/// <param name="accepting">The symbol to report on accept</param>
		/// <returns>The modified machine</returns>
		public static FA Kleene(FA fa, object accepting = null)
		{
			var result = new FA();
			var final = new FA();
			final.AcceptingSymbol = accepting ?? result;
			final.EpsilonTransitions.Add(result);
			foreach (var afa in fa.Accepting)
			{
				afa.AcceptingSymbol = null;
				afa.EpsilonTransitions.Add(final);
			}
			fa.EpsilonTransitions.Add(final);
			result.EpsilonTransitions.Add(fa);
			return result;
		}
		/// <summary>
		/// Creates a Lexer from the specified expressions
		/// </summary>
		/// <param name="exprs">The expressions to compose the lexer of. Each expression should produce a token</param>
		/// <param name="createDefaultAcceptConstants">True if the default FA instances that are used for accepting states (when unspecified) should be replaced instead with integer constants. States with explicitly set accepting symbols shouldn't be affected by this unless they use FA states as accepting symbols.</param>
		/// <returns>An FA that will lex the specified expressions</returns>
		public static FA Lexer(IEnumerable<FA> exprs, bool createDefaultAcceptConstants = true)
		{
			var result = new FA();
			int i = 0;
			foreach (var expr in exprs)
			{
				if (createDefaultAcceptConstants)
				{
					foreach (var fa in expr.FillAccepting())
					{
						FA f = null;
						IList<object> l = fa.AcceptingSymbol as IList<object>;
						if (null != l)
						{
							int c = l.Count;
							for (int j = 0; j < c; ++j)
							{
								f = l[j] as FA;
								if (null != f)
								{
									// use shorts if we can
									if (short.MaxValue >= i && short.MinValue <= i)
										l[j] = unchecked((short)i);
									else if (ushort.MaxValue >= i && ushort.MinValue <= i)
										l[i] = unchecked((ushort)i);
									else
										l[j] = i;
								}
							}
						}
						else
						{
							f = fa.AcceptingSymbol as FA;
							if (null != f)
							{
								if (short.MaxValue >= i && short.MinValue <= i)
									fa.AcceptingSymbol = unchecked((short)i);
								else if (ushort.MaxValue >= i && ushort.MinValue <= i)
									fa.AcceptingSymbol = unchecked((ushort)i);
								else
									fa.AcceptingSymbol = i;
							}
						}
					}
					++i;
				}
				result.EpsilonTransitions.Add(expr);
			}
			return result;
		}
		/// <summary>
		/// Creates a Lexer from the specified expressions
		/// </summary>
		/// <param name="exprs">The expressions to compose the lexer of. Each expression should produce a token</param>
		/// <returns>An FA that will lex the specified expressions</returns>
		public static FA Lexer(params FA[] exprs) => Lexer(exprs, true);
		/// <summary>
		/// The options used for rendering dot graphs
		/// </summary>
		/// <remarks>Currently, this is little more than a placeholder for future options like coloring of states</remarks>
#if GRIMOIRELIB || NEWT
		public
#else
		internal
#endif
		sealed class DotGraphOptions
		{
			/// <summary>
			/// The resolution, in dots-per-inch to render at
			/// </summary>
			public int Dpi = 300;
			/// <summary>
			/// The prefix used for state labels
			/// </summary>
			public string StatePrefix = "q";
			/// <summary>
			/// If non-null, specifies a debug render using the specified input string.
			/// </summary>
			/// <remarks>The debug render is useful for tracking the transitions in a state machine</remarks>
			public IEnumerable<char> DebugString { get; set; }
			/// <summary>
			/// If non-null, specifies the source NFA from which this DFA was derived - used for debug view
			/// </summary>
			public FA DebugSourceNfa = null;
		}
		static void _AppendRangesTo(StringBuilder builder, IEnumerable<KeyValuePair<char, char>> ranges)
		{
			foreach (KeyValuePair<char, char> range in ranges)
				_AppendRangeTo(builder, range);
		}
		static void _AppendRangeTo(StringBuilder builder, KeyValuePair<char, char> range)
		{
			_AppendRangeCharTo(builder, range.Key);
			if (0 == range.Value.CompareTo(range.Key)) return;
			if (range.Value == range.Key + 1) // spit out 1 length ranges as two chars
			{
				_AppendRangeCharTo(builder, range.Value);
				return;
			}
			builder.Append('-');
			_AppendRangeCharTo(builder, range.Value);
		}
		static void _AppendRangeCharTo(StringBuilder builder, char rangeChar)
		{
			switch (rangeChar)
			{
				case '-':
				case '\\':
					builder.Append('\\');
					builder.Append(rangeChar);
					return;
				case '\t':
					builder.Append("\\t");
					return;
				case '\n':
					builder.Append("\\n");
					return;
				case '\r':
					builder.Append("\\r");
					return;
				case '\0':
					builder.Append("\\0");
					return;
				case '\f':
					builder.Append("\\f");
					return;
				case '\v':
					builder.Append("\\v");
					return;
				case '\b':
					builder.Append("\\b");
					return;
				default:
					if (!char.IsLetterOrDigit(rangeChar) && !char.IsSeparator(rangeChar) && !char.IsPunctuation(rangeChar) && !char.IsSymbol(rangeChar))
					{
						builder.Append("\\u");
						builder.Append(unchecked((ushort)rangeChar).ToString("x4"));
					}
					else
						builder.Append(rangeChar);
					break;
			}
		}
		static bool _TryForwardNeutral(FA fa, out FA result)
		{
			result = fa ?? throw new ArgumentNullException(nameof(fa));
			if (!fa.IsNeutral)
				return false;
			result = fa.EpsilonTransitions[0];
			return fa != result; // false if circular
		}
		static FA _ForwardNeutrals(FA fa)
		{
			var result = fa;
			while (_TryForwardNeutral(result, out result))
				;
			return result;
		}
		/// <summary>
		/// Trims the neutral states from this machine
		/// </summary>
		public void TrimNeutrals() { TrimNeutrals(FillClosure()); }
		/// <summary>
		/// Trims the neutral states from the specified closure
		/// </summary>
		/// <param name="closure">The set of all states</param>
		public static void TrimNeutrals(IEnumerable<FA> closure)
		{
			var cl = new List<FA>(closure);
			foreach (var s in cl)
			{
				var repls = new List<KeyValuePair<FA, FA>>();
				var td = (IDictionary<FA, ICollection<char>>)s.Transitions;
				foreach (var trns in td)
				{
					var fa = trns.Key;
					var fa2 = _ForwardNeutrals(fa);
					if (fa != fa2)
						repls.Add(new KeyValuePair<FA, FA>(fa, fa2));
				}
				foreach (var repl in repls)
				{
					var inps = td[repl.Key];
					td.Remove(repl.Key);
					td.Add(repl.Value, inps);
				}
				var ec = s.EpsilonTransitions.Count;
				for (int j = 0; j < ec; ++j)
					s.EpsilonTransitions[j] = _ForwardNeutrals(s.EpsilonTransitions[j]);
			}
		}
		/// <summary>
		/// Creates a new machine that is the deterministic equivelent of this machine
		/// </summary>
		/// <returns>A DFA</returns>
		public FA ToDfa()
		{
			return ToDfa(Closure);
		}
		/// <summary>
		/// Creates a new machine that is the deterministic equivelent of this machine
		/// </summary>
		/// <returns>A DFA</returns>
		public static FA ToDfa(IEnumerable<FA> closure)
		{
			// The DFA states are keyed by the set of NFA states they represent.
			var dfaMap = new Dictionary<List<FA>, FA>(_SetComparer.Default);
			var unmarked = new HashSet<FA>();
			// compute the epsilon closure of the initial state in the NFA
			var states = new List<FA>();
			closure.First().FillEpsilonClosure(states);
			// create a new state to represent the current set of states. If one 
			// of those states is accepting, set this whole state to be accepting.
			FA dfa = new FA();
			var al = new List<object>();
			foreach (var fa in states)
				if (fa.IsAccepting)
					if (!al.Contains(fa.AcceptingSymbol))
						al.Add(fa.AcceptingSymbol);
			int ac = al.Count;
			if (1 == ac)
				dfa.AcceptingSymbol = al[0];
			else if (1 < ac)
				dfa.AcceptingSymbol = al; // hang on to the multiple symbols
			var tl = new List<object>();
			foreach (var fa in states)
				if (null != fa.Tag)
					if (!tl.Contains(fa.Tag))
						tl.Add(fa.Tag);
			var tcl = tl.Count;
			if (1 == tcl)
				dfa.Tag = tl[0];
			else if (1 < tcl)
				dfa.Tag = tl; // hang on to the multiple tags
			FA result = dfa; // store the initial state for later, so we can return it.
			// add it to the dfa map
			dfaMap.Add(states, dfa);
			// add it to the unmarked states, signalling that we still have work to do.
			unmarked.Add(dfa);
			bool done = false;
			while (!done)
			{
				done = true;
				HashSet<List<FA>> mapKeys = new HashSet<List<FA>>(dfaMap.Keys, _SetComparer.Default);
				foreach (List<FA> mapKey in mapKeys)
				{
					dfa = dfaMap[mapKey];
					if (unmarked.Contains(dfa))
					{
						// when we get here, mapKey represents the epsilon closure of our 
						// current dfa state, which is indicated by kvp.Value
						// build the transition list for the new state by combining the transitions
						// from each of the old states
						// retrieve every possible input for these states
						HashSet<char> inputs = new HashSet<char>();
						foreach (FA state in mapKey)
						{
							var dtrns = (IDictionary<FA, ICollection<char>>)state.Transitions;
							foreach (var trns in dtrns)
							{
								foreach (var inp in trns.Value)
									inputs.Add(inp);
							}
						}
						foreach (var input in inputs)
						{
							var acc = new List<object>();
							var tags = new List<object>();
							List<FA> ns = new List<FA>();
							foreach (var state in mapKey)
							{
								FA dst = null;
								if (state.Transitions.TryGetValue(input, out dst))
								{
									foreach (var d in dst.FillEpsilonClosure())
									{
										if (d.IsAccepting)
											if (!acc.Contains(d.AcceptingSymbol))
												acc.Add(d.AcceptingSymbol);
										if (null != d.Tag)
										{
											if (!tags.Contains(d.Tag))
												tags.Add(d.Tag);
										}
										if (!ns.Contains(d))
											ns.Add(d);
									}
								}
							}
							FA ndfa;
							if (!dfaMap.TryGetValue(ns, out ndfa))
							{
								ndfa = new FA(ns);
								ac = acc.Count;
								if (1 == ac)
									ndfa.AcceptingSymbol = acc[0];
								else if (1 < ac)
									ndfa.AcceptingSymbol = acc;
								else
									ndfa.AcceptingSymbol = null;
								var tc = tags.Count;
								if (1 == tc)
									ndfa.Tag = tags[0];
								else if (1 < tc)
									ndfa.Tag = tags;
								else
									ndfa.Tag = null;
								dfaMap.Add(ns, ndfa);
								unmarked.Add(ndfa);
								done = false;
							}
							dfa.Transitions.Add(input, ndfa);
						}
						unmarked.Remove(dfa);
					}
				}
			}
			return result;
		}
		/// <summary>
		/// Creates a table representing the state transitions for a DFA of this machine
		/// </summary>
		/// <returns>A complex tuple representing the DFA table</returns>
		public (object Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] ToDfaTable()
			=> ToDfaTable<object>();
		/// <summary>
		/// Creates a table representing the state transitions for a DFA of this machine
		/// </summary>
		/// <typeparam name="TAccept">The accepting symbol type</typeparam>
		/// <returns>A complex tuple representing the DFA table</returns>
		public (TAccept Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] ToDfaTable<TAccept>()
			=> ToDfaTable<TAccept>(FillClosure());
		/// <summary>
		/// Creates a table representing the state transitions for a DFA of this machine
		/// </summary>
		/// <param name="closure">The set of all states</param>
		/// <returns>A complex tuple representing the DFA table</returns>
		public static (object Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] ToDfaTable(IEnumerable<FA> closure)
			=> ToDfaTable<object>(closure);
		/// <summary>
		/// Creates a table representing the state transitions for a DFA of this machine
		/// </summary>
		/// <typeparam name="TAccept">The accepting symbol type</typeparam>
		/// <param name="closure">The set of all states</param>
		/// <returns>A complex tuple representing the DFA table</returns>
		public static (TAccept Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])[] ToDfaTable<TAccept>(IEnumerable<FA> closure)
		{
			if (!_IsDfa(closure))
			{
				var dfa = closure.First().ToDfa();
				dfa.TrimDuplicates();
				closure = dfa.FillClosure();
			}
			var cl = closure.AsList();
			var result = new List<(TAccept Accept, (KeyValuePair<char, char>[] Ranges, int Destination)[])>();
			var i = 0;
			foreach (var ffa in cl)
			{
				var igrpt = new List<(KeyValuePair<char, char>[] Ranges, int Destination)>();
				foreach (var igrp in ffa.FillInputTransitionRangesGroupedByState())
				{
					var ranges = new List<KeyValuePair<char, char>>(igrp.Value);
					var dstId = closure.IndexOf(igrp.Key);
					igrpt.Add((ranges.ToArray(), dstId));
				}
				object asym = _GetAcceptingSymbol(new FA[] { ffa }, true);
				if(null==asym)
				{
					asym = default(TAccept);
					if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) || typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
						asym = -1;
				}
				result.Add(((TAccept)asym, igrpt.ToArray()));
				++i;
			}
			return result.ToArray();
		}
		/// <summary>
		/// Writes a Graphviz dot specification to the specified <see cref="TextWriter"/>
		/// </summary>
		/// <param name="writer">The writer</param>
		/// <param name="options">A <see cref="DotGraphOptions"/> instance with any options, or null to use the defaults</param>
		public void WriteDotTo(TextWriter writer, DotGraphOptions options = null)
		{
			WriteDotTo(FillClosure(), writer, options);
		}
		/// <summary>
		/// Writes a Graphviz dot specification of the specified closure to the specified <see cref="TextWriter"/>
		/// </summary>
		/// <param name="closure">The closure of all states</param>
		/// <param name="writer">The writer</param>
		/// <param name="options">A <see cref="DotGraphOptions"/> instance with any options, or null to use the defaults</param>
		public static void WriteDotTo(IEnumerable<FA> closure, TextWriter writer, DotGraphOptions options = null)
		{
			if (null == options) options = new DotGraphOptions();
			string spfx = null == options.StatePrefix ? "q" : options.StatePrefix;
			writer.WriteLine("digraph FA {");
			writer.WriteLine("rankdir=LR");
			writer.WriteLine("node [shape=circle]");
			var finals = new List<FA>();
			var neutrals = new List<FA>();
			var accepting = FillAccepting(closure, null);
			foreach (var ffa in closure)
			{
				if (ffa.IsFinal && !ffa.IsAccepting)
					finals.Add(ffa);
			}
			IList<FA> fromStates = null;
			IList<FA> toStates = null;
			char tchar = default(char);
			toStates = closure.First().FillEpsilonClosure();
			if (null != options.DebugString)
			{
				foreach (char ch in options.DebugString)
				{
					fromStates = FillEpsilonClosure(toStates, null);
					tchar = ch;
					toStates = FA.Move(fromStates, ch);
					if (0 == toStates.Count)
						break;
				}
			}
			if (null != toStates)
			{
				toStates = FillEpsilonClosure(toStates, null);
			}
			int i = 0;
			foreach (var ffa in closure)
			{
				if (!finals.Contains(ffa))
				{
					if (ffa.IsAccepting)
						accepting.Add(ffa);
					else if (ffa.IsNeutral)
						neutrals.Add(ffa);
				}
				var rngGrps = ffa.FillInputTransitionRangesGroupedByState(null);
				foreach (var rngGrp in rngGrps)
				{
					var di = closure.IndexOf(rngGrp.Key);
					writer.Write(spfx);
					writer.Write(i);
					writer.Write("->");
					writer.Write(spfx);
					writer.Write(di.ToString());
					writer.Write(" [label=\"");
					var sb = new StringBuilder();
					_AppendRangesTo(sb, rngGrp.Value);
					if (sb.Length != 1 || " " == sb.ToString())
					{
						writer.Write('[');
						writer.Write(_EscapeLabel(sb.ToString()));
						writer.Write(']');
					}
					else
						writer.Write(_EscapeLabel(sb.ToString()));
					writer.WriteLine("\"]");
				}
				// do epsilons
				foreach (var fffa in ffa.EpsilonTransitions)
				{
					writer.Write(spfx);
					writer.Write(i);
					writer.Write("->");
					writer.Write(spfx);
					writer.Write(closure.IndexOf(fffa));
					writer.WriteLine(" [style=dashed,color=gray]");
				}
				++i;
			}
			string delim = "";
			i = 0;
			foreach (var ffa in closure)
			{
				writer.Write(spfx);
				writer.Write(i);
				writer.Write(" [");
				if (null != options.DebugString)
				{
					if (null != toStates && toStates.Contains(ffa))
					{
						writer.Write("color=green,");
					}
					if (null != fromStates && fromStates.Contains(ffa) && (null == toStates || !toStates.Contains(ffa)))
					{
						writer.Write("color=darkgreen,");
					}
				}
				writer.Write("label=<");
				writer.Write("<TABLE BORDER=\"0\"><TR><TD>");
				writer.Write(spfx);
				writer.Write("<SUB>");
				writer.Write(i);
				writer.Write("</SUB></TD></TR>");
				if (null != options.DebugString && null != options.DebugSourceNfa && null != ffa.Tag)
				{
					var tags = ffa.Tag as IList<object>;
					if (null != tags || ffa.Tag is FA)
					{
						writer.Write("<TR><TD>{");
						if (null == tags)
						{
							writer.Write(" q<SUB>");
							writer.Write(options.DebugSourceNfa.FillClosure().IndexOf((FA)ffa.Tag).ToString());
							writer.Write("</SUB>");
						}
						else
						{
							delim = "";
							foreach (var tag in tags)
							{
								writer.Write(delim);
								if (tag is FA)
								{
									writer.Write(delim);
									writer.Write(" q<SUB>");
									writer.Write(options.DebugSourceNfa.FillClosure().IndexOf((FA)tag).ToString());
									writer.Write("</SUB>");
									// putting a comma here is what we'd like
									// but it breaks dot no matter how its encoded
									delim = @" ";
								}
							}
						}
						writer.Write(" }</TD></TR>");
					}
				}
				if (null != ffa.AcceptingSymbol)
				{
					var al = ffa.AcceptingSymbol as IList<object>;
					if (null == al)
					{
						writer.Write("<TR><TD>");
						writer.Write(Convert.ToString(ffa.AcceptingSymbol).Replace("\"", "&quot;"));
						writer.Write("</TD></TR>");
					}
					else
					{
						foreach (var o in al)
						{
							writer.Write("<TR><TD>");
							writer.Write(Convert.ToString(o).Replace("\"", "&quot;"));
							writer.Write("</TD></TR>");
						}
					}
				}
				writer.Write("</TABLE>");
				writer.Write(">");
				bool isfinal = false;
				if (accepting.Contains(ffa) || (isfinal = finals.Contains(ffa)))
					writer.Write(",shape=doublecircle");
				if (isfinal || neutrals.Contains(ffa))
				{
					if ((null == fromStates || !fromStates.Contains(ffa)) &&
						(null == toStates || !toStates.Contains(ffa)))
					{
						writer.Write(",color=gray");
					}
				}
				writer.WriteLine("]");
				++i;
			}
			if (0 < accepting.Count)
			{
				foreach (var ntfa in accepting)
				{
					writer.Write(delim);
					writer.Write(spfx);
					writer.Write(closure.IndexOf(ntfa));
					delim = ",";
				}
				writer.WriteLine(" [shape=doublecircle]");
			}
			delim = "";
			if (0 < neutrals.Count)
			{
				foreach (var ntfa in neutrals)
				{
					if ((null == fromStates || !fromStates.Contains(ntfa)) &&
						(null == toStates || !toStates.Contains(ntfa))
						)
					{
						writer.Write(delim);
						writer.Write(spfx);
						writer.Write(closure.IndexOf(ntfa));
						delim = ",";
					}
				}
				writer.WriteLine(" [color=gray]");
				if (null != fromStates)
				{
					foreach (var ntfa in neutrals)
					{
						if (fromStates.Contains(ntfa) && (null == toStates || !toStates.Contains(ntfa)))
						{
							writer.Write(delim);
							writer.Write(spfx);
							writer.Write(closure.IndexOf(ntfa));
							delim = ",";
						}
					}
					writer.WriteLine(" [color=darkgreen]");
				}
				if (null != toStates)
				{
					foreach (var ntfa in neutrals)
					{
						if (toStates.Contains(ntfa))
						{
							writer.Write(delim);
							writer.Write(spfx);
							writer.Write(closure.IndexOf(ntfa));
							delim = ",";
						}
					}
					writer.WriteLine(" [color=green]");
				}
			}
			delim = "";
			if (0 < finals.Count)
			{
				foreach (var ntfa in finals)
				{
					writer.Write(delim);
					writer.Write(spfx);
					writer.Write(closure.IndexOf(ntfa));
					delim = ",";
				}
				writer.WriteLine(" [shape=doublecircle,color=gray]");
			}
			writer.WriteLine("}");
		}
		static string _EscapeLabel(string label)
		{
			if (string.IsNullOrEmpty(label)) return label;
			string result = label.Replace("\\", @"\\");
			result = result.Replace("\"", "\\\"");
			result = result.Replace("\n", "\\n");
			result = result.Replace("\r", "\\r");
			result = result.Replace("\0", "\\0");
			result = result.Replace("\v", "\\v");
			result = result.Replace("\t", "\\t");
			result = result.Replace("\f", "\\f");
			return result;
		}
		/// <summary>
		/// Renders Graphviz output for this machine to the specified file
		/// </summary>
		/// <param name="filename">The output filename. The format to render is indicated by the file extension.</param>
		/// <param name="options">A <see cref="DotGraphOptions"/> instance with any options, or null to use the defaults</param>
		public void RenderToFile(string filename, DotGraphOptions options = null)
		{
			if (null == options)
				options = new DotGraphOptions();
			string args = "-T";
			string ext = Path.GetExtension(filename);
			if (0 == string.Compare(".png", ext, StringComparison.InvariantCultureIgnoreCase))
				args += "png";
			else if (0 == string.Compare(".jpg", ext, StringComparison.InvariantCultureIgnoreCase))
				args += "jpg";
			else if (0 == string.Compare(".bmp", ext, StringComparison.InvariantCultureIgnoreCase))
				args += "bmp";
			else if (0 == string.Compare(".svg", ext, StringComparison.InvariantCultureIgnoreCase))
				args += "svg";
			if (0 < options.Dpi)
				args += " -Gdpi=" + options.Dpi.ToString();
			args += " -o\"" + filename + "\"";
			var psi = new ProcessStartInfo("dot", args)
			{
				CreateNoWindow = true,
				UseShellExecute = false,
				RedirectStandardInput = true
			};
			using (var proc = Process.Start(psi))
			{
				WriteDotTo(proc.StandardInput, options);
				proc.StandardInput.Close();
				proc.WaitForExit();
			}
		}
		/// <summary>
		/// Renders Graphviz output for this machine to a stream
		/// </summary>
		/// <param name="format">The output format. The format to render can be any supported dot output format. See dot command line documation for details.</param>
		/// <param name="options">A <see cref="DotGraphOptions"/> instance with any options, or null to use the defaults</param>
		/// <returns>A stream containing the output. The caller is expected to close the stream when finished.</returns>
		public Stream RenderToStream(string format, bool copy = false, DotGraphOptions options = null)
		{
			if (null == options)
				options = new DotGraphOptions();
			string args = "-T";
			args += string.Concat(" ", format);
			if (0 < options.Dpi)
				args += " -Gdpi=" + options.Dpi.ToString();
			var psi = new ProcessStartInfo("dot", args)
			{
				CreateNoWindow = true,
				UseShellExecute = false,
				RedirectStandardInput = true,
				RedirectStandardOutput = true
			};
			using (var proc = Process.Start(psi))
			{
				WriteDotTo(proc.StandardInput, options);
				proc.StandardInput.Close();
				if (!copy)
					return proc.StandardOutput.BaseStream;
				else
				{
					MemoryStream stm = new MemoryStream();
					proc.StandardOutput.BaseStream.CopyTo(stm);
					proc.StandardOutput.BaseStream.Close();
					proc.WaitForExit();
					return stm;
				}
			}
		}
		public static int _ParseEscape(ParseContext pc)
		{
			if ('\\' != pc.Current)
				return -1;
			if (-1 == pc.Advance())
				return -1;
			switch (pc.Current)
			{
				case 't':
					pc.Advance();
					return '\t';
				case 'n':
					pc.Advance();
					return '\n';
				case 'r':
					pc.Advance();
					return '\r';
				case 'x':
					if (-1 == pc.Advance())
						return 'x';
					byte b = _FromHexChar((char)pc.Current);
					b <<= 4;
					if (-1 == pc.Advance())
						return unchecked((char)b);
					b |= _FromHexChar((char)pc.Current);
					return unchecked((char)b);
				case 'u':
					if (-1 == pc.Advance())
						return 'u';
					ushort u = _FromHexChar((char)pc.Current);
					u <<= 4;
					if (-1 == pc.Advance())
						return unchecked((char)u);
					u |= _FromHexChar((char)pc.Current);
					u <<= 4;
					if (-1 == pc.Advance())
						return unchecked((char)u);
					u |= _FromHexChar((char)pc.Current);
					u <<= 4;
					if (-1 == pc.Advance())
						return unchecked((char)u);
					u |= _FromHexChar((char)pc.Current);
					return unchecked((char)u);
				default:
					int i = pc.Current;
					pc.Advance();
					return (char)i;
			}
		}
		/// <summary>
		/// Parses a regular expresion from the specified string
		/// </summary>
		/// <param name="string">The string</param>
		/// <param name="accepting">The symbol reported when accepting the specified expression</param>
		/// <returns>A new machine that matches the regular expression</returns>
		public static FA Parse(IEnumerable<char> @string, object accepting = null) => Parse(ParseContext.Create(@string), accepting);
		/// <summary>
		/// Parses a regular expresion from the specified <see cref="TextReader"/>
		/// </summary>
		/// <param name="reader">The text reader</param>
		/// <param name="accepting">The symbol reported when accepting the specified expression</param>
		/// <returns>A new machine that matches the regular expression</returns>
		public static FA Parse(TextReader reader, object accepting = null) => Parse(ParseContext.Create(reader), accepting);
		/// <summary>
		/// Parses a regular expresion from the specified <see cref="ParseContext"/>
		/// </summary>
		/// <param name="pc">The parse context</param>
		/// <param name="accepting">The symbol reported when accepting the specified expression</param>
		/// <returns>A new machine that matches the regular expression</returns>
		public static FA Parse(ParseContext pc, object accepting = null)
		{
			var result = new FA();
			if (null == accepting) accepting = result;
			result.AcceptingSymbol = accepting;
			FA f, next;
			int ch;
			pc.EnsureStarted();
			var current = result;
			while (true)
			{
				switch (pc.Current)
				{
					case -1:
						result.TrimNeutrals();
						return result;
					case '.':
						pc.Advance();
						f = current.Accepting.First();
						current = FA.Set(new KeyValuePair<char, char>[] {new KeyValuePair<char, char>(char.MinValue,char.MaxValue) }, accepting);
						switch (pc.Current)
						{
							case '*':
								current = FA.Kleene(current, accepting);
								pc.Advance();
								break;
							case '+':
								current = FA.Repeat(current, accepting);
								pc.Advance();
								break;
							case '?':
								current = FA.Optional(current, accepting);
								pc.Advance();
								break;
						}
						f.AcceptingSymbol = null;
						f.EpsilonTransitions.Add(current);
						break;
					case '\\':
						if (-1 != (ch = _ParseEscape(pc)))
						{
							next = null;
							switch (pc.Current)
							{
								case '*':
									next = new FA();
									next.Transitions.Add((char)ch, new FA(accepting));
									next = FA.Kleene(next, accepting);
									pc.Advance();
									break;
								case '+':
									next = new FA();
									next.Transitions.Add((char)ch, new FA(accepting));
									next = FA.Repeat(next, accepting);
									pc.Advance();
									break;
								case '?':
									next = new FA();
									next.Transitions.Add((char)ch, new FA(accepting));
									next = FA.Optional(next, accepting);
									pc.Advance();
									break;
								default:
									current = current.Finals.First();
									current.AcceptingSymbol = null;
									current.Transitions.Add((char)ch, new FA(accepting));
									break;
							}
							if (null != next)
							{
								current = current.Finals.First();
								current.AcceptingSymbol = null;
								current.EpsilonTransitions.Add(next);
								current = next;
							}
						}
						else
						{
							pc.Expecting(); // throw an error
							return null; // doesn't execute
						}
						break;
					case ')':
						result.TrimNeutrals();
						return result;
					case '(':
						pc.Advance();
						pc.Expecting();
						f = current.Accepting.First();
						current = Parse(pc, accepting);
						pc.Expecting(')');
						pc.Advance();
						switch (pc.Current)
						{
							case '*':
								current = FA.Kleene(current, accepting);
								pc.Advance();
								break;
							case '+':
								current = FA.Repeat(current, accepting);
								pc.Advance();
								break;
							case '?':
								current = FA.Optional(current, accepting);
								pc.Advance();
								break;
						}
						f = FA.Concat(accepting, f, current);
						break;
					case '|':
						if (-1 != pc.Advance())
						{
							current = Parse(pc, accepting);
							result = FA.Or(accepting, result, current);
						}
						else
						{
							current = current.Finals.First();
							result = FA.Optional(result, accepting);
						}
						break;
					case '[':
						pc.ClearCapture();
						pc.Advance();
						pc.Expecting();
						bool not = false;
						if ('^' == pc.Current)
						{
							not = true;
							pc.Advance();
							pc.Expecting();
						}
						pc.TryReadUntil(']', '\\', false);
						pc.Expecting(']');
						pc.Advance();
						var r = (!not && "." == pc.Capture) ?
							new KeyValuePair<char, char>[] { new KeyValuePair<char, char>(char.MinValue, char.MaxValue) } :
							_ParseRanges(pc.Capture, true);
						if (not)
							r = _NotRanges(r);
						f = current.Accepting.First();
						current = FA.Set(r, accepting);
						switch (pc.Current)
						{
							case '*':
								current = FA.Kleene(current, accepting);
								pc.Advance();
								break;
							case '+':
								current = FA.Repeat(current, accepting);
								pc.Advance();
								break;
							case '?':
								current = FA.Optional(current, accepting);
								pc.Advance();
								break;
						}
						f.AcceptingSymbol = null;
						f.EpsilonTransitions.Add(current);
						break;
					default:
						ch = pc.Current;
						pc.Advance();
						next = null;
						switch (pc.Current)
						{
							case '*':
								next = new FA();
								next.Transitions.Add((char)ch, new FA(accepting));
								next = FA.Kleene(next, accepting);
								pc.Advance();
								break;
							case '+':
								next = new FA();
								next.Transitions.Add((char)ch, new FA(accepting));
								next = FA.Repeat(next, accepting);
								pc.Advance();
								break;
							case '?':
								next = new FA();
								next.Transitions.Add((char)ch, new FA(accepting));
								next = FA.Optional(next, accepting);
								pc.Advance();
								break;
							default:
								current = current.Finals.First();
								current.AcceptingSymbol = null;
								current.Transitions.Add((char)ch, new FA(accepting));
								break;
						}
						if (null != next)
						{
							current = current.Accepting.First();
							current.AcceptingSymbol = null;
							current.EpsilonTransitions.Add(next);
							current = next;
						}
						break;
				}
			}
		}
		// a dictionary optimized for FA transitions
		class _TrnsDic : IDictionary<char, FA>, IDictionary<FA, ICollection<char>>
		{
			IDictionary<FA, ICollection<char>> _inner = new Dictionary<FA, ICollection<char>>();
			public FA this[char key] {
				get {
					foreach (var trns in _inner)
					{
						if (trns.Value.Contains(key))
							return trns.Key;
					}
					throw new KeyNotFoundException();
				}
				set {
					Remove(key);
					ICollection<char> hs;
					if (_inner.TryGetValue(value, out hs))
					{
						hs.Add(key);
					}
					else
					{
						hs = new HashSet<char>();
						hs.Add(key);
						_inner.Add(value, hs);
					}
				}
			}
			public ICollection<char> Keys {
				get {
					return _EnumKeys().AsCollection();
				}
			}
			IEnumerable<char> _EnumKeys()
			{
				foreach (var trns in _inner)
					foreach (var key in trns.Value)
						yield return key;
			}
			public ICollection<FA> Values { get { return _EnumValues().AsCollection(); } }
			IEnumerable<FA> _EnumValues()
			{
				foreach (var trns in _inner)
					foreach (var key in trns.Value)
						yield return trns.Key;
			}
			public int Count {
				get {
					var result = 0;
					foreach (var trns in _inner)
						result += trns.Value.Count;
					return result;
				}
			}
			ICollection<FA> IDictionary<FA, ICollection<char>>.Keys { get { return _inner.Keys; } }
			ICollection<ICollection<char>> IDictionary<FA, ICollection<char>>.Values { get { return _inner.Values; } }
			int ICollection<KeyValuePair<FA, ICollection<char>>>.Count { get { return _inner.Count; } }
			public bool IsReadOnly { get { return _inner.IsReadOnly; } }
			ICollection<char> IDictionary<FA, ICollection<char>>.this[FA key] { get { return _inner[key]; } set { _inner[key] = value; } }
			public void Add(char key, FA value)
			{
				if (ContainsKey(key))
					throw new InvalidOperationException("The key is already present in the dictionary.");
				ICollection<char> hs;
				if (_inner.TryGetValue(value, out hs))
				{
					hs.Add(key);
				}
				else
				{
					hs = new HashSet<char>();
					hs.Add(key);
					_inner.Add(value, hs);
				}
			}
			public void Add(KeyValuePair<char, FA> item)
			{
				Add(item.Key, item.Value);
			}
			public void Clear()
			{
				_inner.Clear();
			}
			public bool Contains(KeyValuePair<char, FA> item)
			{
				ICollection<char> hs;
				return _inner.TryGetValue(item.Value, out hs) && hs.Contains(item.Key);
			}
			public bool ContainsKey(char key)
			{
				foreach (var trns in _inner)
				{
					if (trns.Value.Contains(key))
						return true;
				}
				return false;
			}
			public void CopyTo(KeyValuePair<char, FA>[] array, int arrayIndex)
			{
				((IEnumerable<KeyValuePair<char, FA>>)this).CopyTo(array, arrayIndex);
			}
			public IEnumerator<KeyValuePair<char, FA>> GetEnumerator()
			{
				foreach (var trns in _inner)
					foreach (var ch in trns.Value)
						yield return new KeyValuePair<char, FA>(ch, trns.Key);
			}
			public bool Remove(char key)
			{
				FA rem = null;
				foreach (var trns in _inner)
				{
					if (trns.Value.Contains(key))
					{
						trns.Value.Remove(key);
						if (0 == trns.Value.Count)
						{
							rem = trns.Key;
							break;
						}
						return true;
					}
				}
				if (null != rem)
				{
					_inner.Remove(rem);
					return true;
				}
				return false;
			}
			public bool Remove(KeyValuePair<char, FA> item)
			{
				ICollection<char> hs;
				if (_inner.TryGetValue(item.Value, out hs))
				{
					if (hs.Contains(item.Key))
					{
						if (1 == hs.Count)
							_inner.Remove(item.Value);
						else
							hs.Remove(item.Key);
						return true;
					}
				}
				return false;
			}
			public bool TryGetValue(char key, out FA value)
			{
				foreach (var trns in _inner)
				{
					if (trns.Value.Contains(key))
					{
						value = trns.Key;
						return true;
					}
				}
				value = null;
				return false;
			}
			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
			void IDictionary<FA, ICollection<char>>.Add(FA key, ICollection<char> value)
			{
				_inner.Add(key, value);
			}
			bool IDictionary<FA, ICollection<char>>.ContainsKey(FA key)
			{
				return _inner.ContainsKey(key);
			}
			bool IDictionary<FA, ICollection<char>>.Remove(FA key)
			{
				return _inner.Remove(key);
			}
			bool IDictionary<FA, ICollection<char>>.TryGetValue(FA key, out ICollection<char> value)
			{
				return _inner.TryGetValue(key, out value);
			}
			void ICollection<KeyValuePair<FA, ICollection<char>>>.Add(KeyValuePair<FA, ICollection<char>> item)
			{
				_inner.Add(item);
			}
			bool ICollection<KeyValuePair<FA, ICollection<char>>>.Contains(KeyValuePair<FA, ICollection<char>> item)
			{
				return _inner.Contains(item);
			}
			void ICollection<KeyValuePair<FA, ICollection<char>>>.CopyTo(KeyValuePair<FA, ICollection<char>>[] array, int arrayIndex)
			{
				_inner.CopyTo(array, arrayIndex);
			}
			bool ICollection<KeyValuePair<FA, ICollection<char>>>.Remove(KeyValuePair<FA, ICollection<char>> item)
			{
				return _inner.Remove(item);
			}
			IEnumerator<KeyValuePair<FA, ICollection<char>>> IEnumerable<KeyValuePair<FA, ICollection<char>>>.GetEnumerator()
			{
				return _inner.GetEnumerator();
			}
		}
		// compares several types of state collections or dictionaries used by FA
		sealed class _SetComparer : IEqualityComparer<IList<FA>>, IEqualityComparer<ICollection<FA>>, IEqualityComparer<IDictionary<char, FA>>
		{
			// ordered comparison
			public bool Equals(IList<FA> lhs, IList<FA> rhs)
			{
				return lhs.Equals<FA>(rhs);
			}
			// unordered comparison
			public bool Equals(ICollection<FA> lhs, ICollection<FA> rhs)
			{
				return lhs.Equals<FA>(rhs);
			}
			public bool Equals(IDictionary<char, FA> lhs, IDictionary<char, FA> rhs)
			{
				return lhs.Equals<KeyValuePair<char, FA>>(rhs);
			}
			public bool Equals(IDictionary<FA, ICollection<char>> lhs, IDictionary<FA, ICollection<char>> rhs)
			{
				if (lhs.Count != rhs.Count) return false;
				if (ReferenceEquals(lhs, rhs))
					return true;
				else if (ReferenceEquals(null, lhs) || ReferenceEquals(null, rhs))
					return false;
				using (var xe = lhs.GetEnumerator())
				using (var ye = rhs.GetEnumerator())
					while (xe.MoveNext() && ye.MoveNext())
					{
						if (xe.Current.Key != ye.Current.Key)
							return false;
						if (!CollectionUtility.Equals(xe.Current.Value, ye.Current.Value))
							return false;
					}
				return true;
			}
			public int GetHashCode(IList<FA> lhs)
			{
				return lhs.GetHashCode<FA>();
			}
			public int GetHashCode(ICollection<FA> lhs)
			{
				return lhs.GetHashCode<FA>();
			}
			public int GetHashCode(IDictionary<char, FA> lhs)
			{
				return lhs.GetHashCode<KeyValuePair<char, FA>>();
			}
			public static readonly _SetComparer Default = new _SetComparer();
		}
	}
}
//*** SourceCombiner -> original file FA2.cs ***
// FA w/ Error recovery
namespace Grimoire
{
	partial class FA
	{
		public static void WriteCSharpDfaTable2CreationExpressionTo<TAccept>(TextWriter writer, (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[] PossibleAccepts)[] dfaTable)
		{
			var tuple = string.Concat("(", typeof(TAccept).FullName, " Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, ", typeof(TAccept).FullName, "[] PossibleAccepts)");
			writer.WriteLine(string.Concat("new ",tuple,"[] {"));
			for(var i = 0;i<dfaTable.Length;i++)
			{
				var dfaEntry = dfaTable[i];
				writer.Write("\t");
				if (0 != i) writer.Write(",");
				writer.WriteLine(string.Concat("(",dfaEntry.Accept,", new ((char First, char Last)[] Ranges, int Destination)[] {"));
				for(var j =0;j<dfaEntry.Transitions.Length;j++)
				{
					var trn = dfaEntry.Transitions[j];
					writer.Write("\t\t");
					if (0 != j) writer.Write(",");
					writer.WriteLine("(new (char First,char Last)[] {");
					for(var k = 0;k<trn.Ranges.Length;k++) {
						var rng = trn.Ranges[k];
						writer.Write("\t\t\t");
						if (0 != k) writer.Write(",");
						writer.Write("((char)");
						// spitting chars here breaks unicode so we use ints
						// WriteCSharpCharTo doesn't support unicode yet.
						CSharpUtility.WriteCSharpLiteralTo(writer, (int)rng.First);
						writer.Write(",(char)");
						CSharpUtility.WriteCSharpLiteralTo(writer, (int)rng.Last);
						writer.WriteLine(")");
					}
					writer.Write("}");
					writer.Write(string.Concat(",", trn.Destination));
					writer.Write(")");
				}
				writer.Write("}, new int[] ");
				writer.Write(CollectionUtility.ToString(dfaEntry.PossibleAccepts));
				writer.WriteLine(")");
			}
			writer.WriteLine("}");
		}
		public static (TAccept Accept, string Value, (int First, int Last)[] ExpectingRanges, TAccept[] ExpectingSymbols) Lex2<TAccept>(
			(TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[] PossibleAccepts)[] dfaTable,
			TAccept errorSymbol,
			ParseContext pc,
			StringBuilder sb = null)
		{
			if (null == sb)
				sb = new StringBuilder();
			else
				sb.Clear();
			pc.EnsureStarted();
			var state = 0;
			var dfaEntry = dfaTable[state];
			object acc = dfaEntry.Accept;
			if (-1 == pc.Current)
			{
				if (null == acc)
					return _DoRecoveryDfat<TAccept>(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
				if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) || typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
				{
					if (-1L == Convert.ToInt64(dfaEntry.Accept))
					{
						return _DoRecoveryDfat(
						dfaTable,
						dfaEntry,
						errorSymbol,
						pc,
						sb,
						dfaEntry.Transitions);
					}
				}
				return (dfaEntry.Accept, sb.ToString(), null, null);
			}
			while (true)
			{
				var ns = _GetDfatTransition(dfaEntry.Transitions, (char)pc.Current);
				if (-1 == ns)
				{
					if (null == dfaEntry.Accept)
					{
						return _DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
					}
					if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) || typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
					{
						if (-1L == Convert.ToInt64(dfaEntry.Accept))
						{
							return _DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
						}
					}
					return (dfaEntry.Accept, sb.ToString(), null, null);
				}
				state = ns;
				dfaEntry = dfaTable[state];
				if (-1 != pc.Current)
					sb.Append((char)pc.Current);
				if (-1 == pc.Advance())
				{
					if (null == dfaEntry.Accept)
						return _DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
					if (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) || typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte))
					{
						if (-1L == Convert.ToInt64(dfaEntry.Accept))
							return _DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
					}
					return (dfaEntry.Accept, sb.ToString(), null, null);
				}
			}
		}
		static (TAccept Accept, string Value, (int First, int Last)[] ExpectingRanges, TAccept[] ExpectingSymbols) _DoRecoveryDfat<TAccept>(
			(TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[] PossibleAccepts)[] dfaTable,
			(TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[] PossibleAccepts) dfaEntry,
			TAccept errorSymbol,
			ParseContext pc,StringBuilder sb,((char First, char Last)[] Ranges, int Destination)[] trns)
		{
			var ranges = new List<(int First, int Last)>();
			for (var i = 0; i < dfaEntry.Transitions.Length; i++)
			{
				var trn = dfaEntry.Transitions[i];
				for (var j = 0; j < trn.Ranges.Length; j++)
				{
					var range = trn.Ranges[j];
					ranges.Add((range.First, range.Last));
				}
			}
			while (true)
			{
				if (-1 == pc.Current)
					break;
				sb.Append((char)pc.Current);
				if (-1 != pc.Advance())
				{
					var dt = _GetDfatTransition(dfaTable[0].Transitions, (char)pc.Current);
					if (-1!=dt)
						break;
				}
			}
			return (errorSymbol, sb.ToString(), ranges.ToArray(), dfaEntry.PossibleAccepts);
		}
		static int _GetDfatTransition(((char First,char Last)[] Ranges, int Destination)[] trns, char ch)
		{
			for (var i = 0; i < trns.Length; ++i)
			{
				var trn = trns[i];
				for (var j = 0; j < trn.Ranges.Length; ++j)
				{
					var rg = trn.Ranges[j];
					if (ch >= rg.First && ch <= rg.Last)
					{
						return trn.Destination;
					}
				}
			}
			return -1; // no state
		}
		public (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[] PossibleAccepts)[] ToDfaTable2<TAccept>()
		{
			var fa = this;
			if (!fa.IsDfa)
				fa = fa.ToDfa();
			var closure = fa.FillClosure();
			var cc = closure.Count;
			var result = new (TAccept Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, TAccept[] PossibleAccepts)[cc];
			for (var i = 0;i<result.Length;i++)
			{
				var cfa = closure[i];
				var possibleAccepts = cfa.AcceptingSymbols.Cast<TAccept>().ToArray();
				var tc = ((IDictionary<FA,ICollection<char>>)cfa.Transitions).Count;
				var transitions = new ((char First, char Last)[] Ranges, int Destination)[tc];
				var j = 0;
				foreach (var trns in (IDictionary<FA, ICollection<char>>)cfa.Transitions)
				{
					var dranges = _GetRanges(trns.Value).ToArray();
					var ranges = new (char First, char Last)[dranges.Length];
					for(var k = 0;k<dranges.Length;k++)
					{
						var range = dranges[k];
						ranges[k] = (range.Key, range.Value);
					}
					transitions[j] = (ranges, closure.IndexOf(trns.Key));
					++j;
				}
				object acc;
				if (null == cfa.AcceptingSymbol && (typeof(TAccept) == typeof(int) || typeof(TAccept) == typeof(short) || typeof(TAccept) == typeof(long) || typeof(TAccept) == typeof(sbyte)))
					acc = (TAccept)Convert.ChangeType(-1, typeof(TAccept));
				else
					acc = cfa.AcceptingSymbol;
				result[i] = ((TAccept)Convert.ChangeType(acc,typeof(TAccept)), transitions, possibleAccepts);
			}
			return result;
		}
	}
}
//*** SourceCombiner -> original file GeneralSettings.Designer.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Grimoire {
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.9.0.0")]
    internal sealed partial class GeneralSettings : global::System.Configuration.ApplicationSettingsBase {
        private static GeneralSettings defaultInstance = ((GeneralSettings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new GeneralSettings())));
        public static GeneralSettings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
//*** SourceCombiner -> original file ISymbolResolver.cs ***
namespace Grimoire
{

	interface ISymbolResolver
	{
		string GetSymbolById(int symbolId);
		int GetSymbolId(string symbol);
	}
}
//*** SourceCombiner -> original file ListDictionary.cs ***
namespace Grimoire
{
#if GRIMOIRELIB
	public
#else
	internal
#endif
	class ListDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IList<KeyValuePair<TKey, TValue>>
	{
		IEqualityComparer<TKey> _equalityComparer;
		IList<KeyValuePair<TKey, TValue>> _inner;
		public ListDictionary(IList<KeyValuePair<TKey,TValue>> inner = null, IEqualityComparer<TKey> equalityComparer=null)
		{
			if (null == inner)
				inner = new List<KeyValuePair<TKey, TValue>>();
			_inner = inner;
			_equalityComparer = equalityComparer;
		}
		public TValue this[TKey key] {
			get {
				int i = IndexOfKey(key);
				if (0 > i) throw new KeyNotFoundException();
				return _inner[i].Value;
			}
			set {
				int i = IndexOfKey(key);
				if (0 > i)
					_inner.Add(new KeyValuePair<TKey, TValue>(key, value));
				else
					_inner[i] = new KeyValuePair<TKey, TValue>(key, value);
			}
		}
		public object GetValueAt(int index)
			=> _inner[index].Value;
		public ICollection<TKey> Keys { get => new _KeysCollection(_inner, _equalityComparer); }
		public ICollection<TValue> Values { get => new _ValuesCollection(_inner); }
		public int Count { get => _inner.Count; }
		public bool IsReadOnly { get => _inner.IsReadOnly; }
		public KeyValuePair<TKey, TValue> this[int index] {
			get => _inner[index];
			set {
				var i = IndexOfKey(value.Key);
				if (0 > i || i == index)
				{
					_inner[index] = value;
				}
				else
					throw new InvalidOperationException("An item with the specified key already exists in the collection.");
			}
		}
		public void Add(TKey key, TValue value)
			=> Add(new KeyValuePair<TKey, TValue>(key, value));
		public void Add(KeyValuePair<TKey, TValue> item)
		{
			if (ContainsKey(item.Key))
				throw new InvalidOperationException("An item with the specified key already exists in the collection.");
			_inner.Add(item);
		}
		public void Clear()
			=> _inner.Clear();
		public bool Contains(KeyValuePair<TKey, TValue> item)
			=> _inner.Contains(item);
		public bool ContainsKey(TKey key)
			=> -1 < IndexOfKey(key);
		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
			=> _inner.CopyTo(array, arrayIndex);
		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
			=> _inner.GetEnumerator();
		public bool Remove(TKey key)
		{
			var i = IndexOfKey(key);
			if (0 > i) return false;
			_inner.RemoveAt(i);
			return true;
		}
		public int IndexOfKey(TKey key)
		{
			var c = _inner.Count;
			if (null == _equalityComparer)
			{
				for (var i = 0; i < c; ++i)
					if (Equals(_inner[i].Key, key))
						return i;
			}
			else for (var i = 0; i < c; ++i)
					if (_equalityComparer.Equals(_inner[i].Key, key))
						return i;
			return -1;
		}
		public bool Remove(KeyValuePair<TKey, TValue> item)
			=> _inner.Remove(item);
		public bool TryGetValue(TKey key, out TValue value)
		{
			var c = _inner.Count;
			if (null == _equalityComparer)
				for (var i = 0; i < c; ++i)
				{
					var kvp = _inner[i];
					if (Equals(kvp.Key, key))
					{
						value = kvp.Value;
						return true;
					}
				}
			else
				for (var i = 0; i < c; ++i)
				{
					var kvp = _inner[i];
					if (_equalityComparer.Equals(kvp.Key, key))
					{
						value = kvp.Value;
						return true;
					}
				}
			value = default(TValue);
			return false;
		}
		IEnumerator IEnumerable.GetEnumerator()
			=> GetEnumerator();
		public int IndexOf(KeyValuePair<TKey, TValue> item)
		{
			return _inner.IndexOf(item);
		}
		public void Insert(int index, KeyValuePair<TKey, TValue> item)
		{
			if (0 > IndexOfKey(item.Key))
				_inner.Insert(index, item);
			else
				throw new InvalidOperationException("An item with the specified key already exists in the collection.");
		}
		public void RemoveAt(int index)
		{
			_inner.RemoveAt(index);
		}
		#region _KeysCollection
		sealed class _KeysCollection : ICollection<TKey>
		{
			IEqualityComparer<TKey> _equalityComparer;
			IList<KeyValuePair<TKey, TValue>> _inner;
			public _KeysCollection(IList<KeyValuePair<TKey, TValue>> inner, IEqualityComparer<TKey> equalityComparer)
			{
				_inner = inner;
				_equalityComparer = equalityComparer;
			}
			public int Count { get => _inner.Count; }
			public bool IsReadOnly { get => true; }
			void ICollection<TKey>.Add(TKey item)
			{
				throw new InvalidOperationException("The collection is read only.");
			}
			void ICollection<TKey>.Clear()
			{
				throw new InvalidOperationException("The collection is read only.");
			}
			public bool Contains(TKey item)
			{
				var c = _inner.Count;
				if (null == _equalityComparer)
				{
					for (var i = 0; i < c; ++i)
						if (Equals(_inner[i].Key, item))
							return true;
				}
				else
					for (var i = 0; i < c; ++i)
						if (_equalityComparer.Equals(_inner[i].Key, item))
							return true;
				return false;
			}
			public void CopyTo(TKey[] array, int arrayIndex)
			{
				var c = _inner.Count;
				if (c > (array.Length - arrayIndex))
					throw new ArgumentOutOfRangeException("arrayIndex");
				for (var i = 0; i < c; ++i)
					array[i + arrayIndex] = _inner[i].Key;
			}
			public IEnumerator<TKey> GetEnumerator()
			{
				foreach (var kvp in _inner)
					yield return kvp.Key;
			}
			bool ICollection<TKey>.Remove(TKey item)
			{
				throw new InvalidOperationException("The collection is read only.");
			}
			IEnumerator IEnumerable.GetEnumerator()
				=> GetEnumerator();
		}
		#endregion
		#region _ValuesCollection
		sealed class _ValuesCollection : ICollection<TValue>
		{
			IList<KeyValuePair<TKey, TValue>> _inner;
			public _ValuesCollection(IList<KeyValuePair<TKey, TValue>> inner)
			{
				_inner = inner;
			}
			public int Count { get => _inner.Count; }
			public bool IsReadOnly { get => true; }
			void ICollection<TValue>.Add(TValue item)
			{
				throw new InvalidOperationException("The collection is read only.");
			}
			void ICollection<TValue>.Clear()
			{
				throw new InvalidOperationException("The collection is read only.");
			}
			public bool Contains(TValue item)
			{
				var c = _inner.Count;
				for (var i = 0; i < c; ++i)
					if (Equals(_inner[i].Value, item))
						return true;
				return false;
			}
			public void CopyTo(TValue[] array, int arrayIndex)
			{
				var c = _inner.Count;
				if (c > (array.Length - arrayIndex))
					throw new ArgumentOutOfRangeException("arrayIndex");
				for (var i = 0; i < c; ++i)
					array[i + arrayIndex] = _inner[i].Value;
			}
			public IEnumerator<TValue> GetEnumerator()
			{
				foreach (var kvp in _inner)
					yield return kvp.Value;
			}
			bool ICollection<TValue>.Remove(TValue item)
			{
				throw new InvalidOperationException("The collection is read only.");
			}
			IEnumerator IEnumerable.GetEnumerator()
				=> GetEnumerator();
		}
		#endregion
	}
}
//*** SourceCombiner -> original file LLParser.cs ***
namespace Grimoire
{

	enum LLNodeType
	{
		Initial =0,
		NonTerminal=1,
		EndNonTerminal=2,
		Terminal=3,
		Error=4,
		EndDocument=5
	}

	abstract class LLParser : ISymbolResolver,IDisposable
	{
		public abstract LLNodeType NodeType { get; }
		public abstract int SymbolId { get; }
		public virtual string Symbol { get { return GetSymbolById(SymbolId); } }
		public abstract string Value { get; }
		public abstract object ParsedValue { get; }
		public abstract int Line { get; }
		public abstract int Column { get; }
		public abstract long Position { get; }
		public abstract string GetSymbolById(int symbolId);
		public abstract int GetSymbolId(string symbol);
		public abstract bool Read();
		public abstract void Close();
		public abstract void Restart(ParseContext parseContext);
		void IDisposable.Dispose() { Close(); }
		public virtual ParseNode ParseSubtree(bool trimEmpties = false)
		{
			if (!Read())
				return null;
			if (NodeType == LLNodeType.EndNonTerminal)
				return null;
			var result = new ParseNode();
			var id = SymbolId;
			if (LLNodeType.NonTerminal == NodeType)
			{
				while (true)
				{
					var k = ParseSubtree(trimEmpties);
					if (null != k)
					{
						k.Parent = result;
						if (!trimEmpties || ((null != k.Value) || 0 < k.Children.Count))
							result.Children.Add(k);
					}
					else
						break;
				}
				result.SymbolId = id;
				result.Symbol = Symbol;
				return result;
			}
			else if (LLNodeType.Terminal == NodeType)
			{
				result.SetLineInfo(Line, Column, Position);
				result.SymbolId = id;
				result.Symbol = Symbol;
				result.Value = Value;
				result.ParsedValue = ParsedValue;
				return result;
			}
			else if (LLNodeType.Error == NodeType)
			{
				result.SetLineInfo(Line, Column, Position);
				result.SymbolId = id;
				result.Symbol = Symbol;
				result.Value = Value;
				result.ParsedValue = Value;
				return result;
			}
			return null;
		}
	}
}
//*** SourceCombiner -> original file Main.cs ***
// if you can't get the thing to build because it can't 
// find EbnfParser, comment this out. Do the build.
// make sure EbnfParser.cs is in your project (it will
// have been generated). Then uncomment this and recompile

namespace HighlighterDemo
{
	public partial class Main : Form
	{

		EbnfParser _parser;
		private bool _colorizing;

		public Main()
		{
			InitializeComponent();
			_parser = new EbnfParser();
			return;
		}
		private void Main_TextChanged(object sender, EventArgs e)
		{
			Colorize();
		}
		void Colorize()
		{
#if PARSER
			if (_colorizing)
				return;
			_colorizing = true;
			var text = EditBox.Text;
			var sel = EditBox.SelectionStart;
			EditBox.Clear();
			var sb = new StringBuilder();
			sb.Append("{\\rtf1");
			sb.Append(RtfUtility.ToColorTable(
				Color.Black, 
				Color.DarkGreen, 
				Color.DarkRed,
				Color.DarkOliveGreen,
				Color.Blue,
				Color.DarkCyan,
				Color.BlueViolet,
				Color.DarkGray));
			var p = new EbnfParser(ParseContext.Create(text));
			var pos = 0L;
			var cols = new Stack<int>();
			cols.Push(0);
			while (p.Read())
			{
				switch(p.NodeType)
				{
					case LLNodeType.NonTerminal:
						switch(p.SymbolId)
						{
							case EbnfParser.attribute:
								cols.Push(3);
								break;
							case EbnfParser.symbol:
							case EbnfParser.expressions:
								cols.Push(4);
								break;
							default:
								cols.Push(0);
								break;
						}
						break;
					case LLNodeType.EndNonTerminal:
						cols.Pop();
						break;
					case LLNodeType.Terminal:
					case LLNodeType.Error:
						if(p.Position>pos) {
							sb.Append("\\cf1 ");
							sb.Append(RtfUtility.Escape(text.Substring((int)pos, (int)(p.Position - pos))));
						}
						if (LLNodeType.Error == p.NodeType)
							sb.Append("\\cf2");
						else
						{
							sb.Append("\\cf");
							switch (p.SymbolId) {
								case EbnfParser.literal:
									sb.Append(5);
									break;
								case EbnfParser.regex:
									sb.Append(6);
									break;
								default:
									sb.Append(cols.Peek());
									break;
							}
						}
						sb.Append(RtfUtility.Escape(p.Value));
						pos = p.Position+p.Value.Length;
						break;
				}
			}
			sb.Append("}");
			System.Diagnostics.Debug.WriteLine(sb.ToString());
			EditBox.Rtf = sb.ToString();
			EditBox.SelectionStart = sel;
			_colorizing = false;
#endif
		}
	}
}
//*** SourceCombiner -> original file Main.Designer.cs ***
namespace HighlighterDemo
{
	partial class Main
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}
		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.EditBox = new System.Windows.Forms.RichTextBox();
			this.SuspendLayout();
			// 
			// EditBox
			// 
			this.EditBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.EditBox.DetectUrls = false;
			this.EditBox.Dock = System.Windows.Forms.DockStyle.Fill;
			this.EditBox.Location = new System.Drawing.Point(0, 0);
			this.EditBox.Name = "EditBox";
			this.EditBox.ShowSelectionMargin = true;
			this.EditBox.Size = new System.Drawing.Size(800, 450);
			this.EditBox.TabIndex = 0;
			this.EditBox.Text = "";
			this.EditBox.WordWrap = false;
			this.EditBox.TextChanged += new System.EventHandler(this.Main_TextChanged);
			// 
			// Main
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(800, 450);
			this.Controls.Add(this.EditBox);
			this.Name = "Main";
			this.Text = "EBNF Syntax Highlighter (Ctrl-V Paste)";
			this.ResumeLayout(false);
		}
		#endregion
		private System.Windows.Forms.RichTextBox EditBox;
	}
}
//*** SourceCombiner -> original file Newt.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Newt.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtLib.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtLib.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtLL1.cs ***
#pragma warning disable VSTHRD010
namespace Grimoire
{
	public sealed class NewtLL1 : IVsSingleFileGenerator
	{
		#region IVsSingleFileGenerator Members
		public int DefaultExtension(out string pbstrDefaultExtension)
		{
			pbstrDefaultExtension = ".cs";
			return pbstrDefaultExtension.Length;
		}
		bool ReportMessage(IVsGeneratorProgress p, EbnfMessage m)
		{
			try
			{
				ThreadHelper.ThrowIfNotOnUIThread();
				if (null != p)
				{
					switch(m.ErrorLevel)
					{
						case EbnfErrorLevel.Warning:
							p.GeneratorError(1, 1, m.Message, (uint)m.Line, (uint)m.Column);
							return true;
						case EbnfErrorLevel.Error:
							p.GeneratorError(0, 1, m.Message, (uint)m.Line, (uint)m.Column);
							return true;
					}
				}
			}
			catch
			{
			}
			return false;
		}
		bool ReportMessage(IVsGeneratorProgress p, CfgMessage m)
		{
			try
			{
				ThreadHelper.ThrowIfNotOnUIThread();
				if (null != p)
				{
					switch (m.ErrorLevel)
					{
						case CfgErrorLevel.Warning:
							p.GeneratorError(1, 1, m.Message, 0, 0);
							return true;
						case CfgErrorLevel.Error:
							p.GeneratorError(0, 1, m.Message, 0, 0);
							return true;
					}
				}
			}
			catch
			{
			}
			return false;
		}
		bool ReportMessage(IVsGeneratorProgress p, string m,int line=0,int column=0,bool error=true)
		{
			try
			{
				ThreadHelper.ThrowIfNotOnUIThread();
				if (null != p)
				{
					p.GeneratorError((error) ? 0 : 1, 1, m, (uint)line, (uint)column);
					return true;
				}
			}
			catch
			{
			}
			return false;
		}
		bool ReportProgress(IVsGeneratorProgress p, int step,int steps)
		{
			try
			{
				ThreadHelper.ThrowIfNotOnUIThread();
				if (null != p)
				{
					p.Progress((uint)step, (uint)steps);
					return true;
				}
			}
			catch
			{
			}
			return false;
		}
		public int Generate(string wszInputFilePath, string bstrInputFileContents,
		  string wszDefaultNamespace, IntPtr[] rgbOutputFileContents,
		  out uint pcbOutput, IVsGeneratorProgress pGenerateProgress)
		{
			try
			{
				using (var stm = new MemoryStream())
				{
					ReportProgress(pGenerateProgress, 1, 4);
					EbnfDocument doc = null;
					var msgs = new List<object>();
					var sw = new StreamWriter(stm);
					using (var sr = new StreamReader(wszInputFilePath))
					{
						try
						{
							doc = EbnfDocument.ReadFrom(sr);
						}
						catch (ExpectingException ex)
						{
							var em = string.Concat("Error parsing grammar: ", ex.Message);
							if(!ReportMessage(pGenerateProgress, em, ex.Line, ex.Column, true))
								msgs.Add(em);
							WriteHeader(sw, wszInputFilePath, msgs);
							goto done;
						}
						ReportProgress(pGenerateProgress, 2, 4);
					}
					var hasErrors = false;
					foreach (var m in doc.Prepare(false))
					{
						if(!ReportMessage(pGenerateProgress, m))
							msgs.Add(m);
						if (EbnfErrorLevel.Error == m.ErrorLevel)
							hasErrors = true;
					}
					if (hasErrors)
					{
						// make sure to dump the messages
						WriteHeader(sw, wszInputFilePath, msgs);
						goto done;
					}
					var name = string.Concat(Path.GetFileNameWithoutExtension(wszInputFilePath),"Parser");
					var cfg = doc.ToCfg();
					foreach (var m in cfg.PrepareLL1(false))
					{
						if (!ReportMessage(pGenerateProgress, m))
							msgs.Add(m);
						if (CfgErrorLevel.Error == m.ErrorLevel)
							hasErrors = true;
					}
					if (hasErrors)
					{
						WriteHeader(sw, wszInputFilePath, msgs);
						goto done;
					}
					ReportProgress(pGenerateProgress, 3, 4);
					var lexer = doc.ToLexer(cfg);
					WriteHeader(sw, wszInputFilePath, msgs);
					var hasNS = !string.IsNullOrEmpty(wszDefaultNamespace);
					if (hasNS)
						sw.WriteLine(string.Concat("namespace ", wszDefaultNamespace, " {"));
					cfg.WriteCSharpTableDrivenLL1ParserClassTo(sw, name, null, lexer);
					if (hasNS)
						sw.WriteLine("}");
					ReportProgress(pGenerateProgress, 4, 4);
				done:
					sw.Flush();
					int length = (int)stm.Length;
					rgbOutputFileContents[0] = Marshal.AllocCoTaskMem(length);
					Marshal.Copy(stm.GetBuffer(), 0, rgbOutputFileContents[0], length);
					pcbOutput = (uint)length;
				}
			}
			catch (Exception ex)
			{
				string s = string.Concat("/* ", ex.Message, " */");
				byte[] b = Encoding.UTF8.GetBytes(s);
				int length = b.Length;
				rgbOutputFileContents[0] = Marshal.AllocCoTaskMem(length);
				Marshal.Copy(b, 0, rgbOutputFileContents[0], length);
				pcbOutput = (uint)length;
			}
			return VSConstants.S_OK;
		}
		public static void WriteHeader(TextWriter writer, string wszInputFilePath, IEnumerable<object> msgs)
		{
			if (null != wszInputFilePath)
				writer.WriteLine(string.Concat("#line 1 \"", Path.GetFullPath(wszInputFilePath).Replace("\"", "\"\""), "\""));
			foreach (var m in msgs)
			{
				var em = m as EbnfMessage;
				if (null != em)
				{
					if (EbnfErrorLevel.Warning == em.ErrorLevel)
						writer.Write("#warning ");
					else if (EbnfErrorLevel.Error == em.ErrorLevel)
						writer.Write("#error ");
					else if (EbnfErrorLevel.Message == em.ErrorLevel)
						writer.Write("// Generator ");
					else
						continue;
					writer.WriteLine(em.ToString());
				}
				else
				{
					var cm = m as CfgMessage;
					if (null != cm)
					{
						if (CfgErrorLevel.Warning == cm.ErrorLevel)
							writer.Write("#warning ");
						else if (CfgErrorLevel.Error == cm.ErrorLevel)
							writer.Write("#error ");
						else if (CfgErrorLevel.Message == cm.ErrorLevel)
							writer.Write("// Generator ");
						else
							continue;
						writer.WriteLine(cm.ToString());
					}
					else
						writer.WriteLine(string.Concat("#error ", m));
				}
			}
		}
		#endregion
	}
}
#pragma warning restore VSTHRD010
//*** SourceCombiner -> original file NewtRT.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtRT.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file NewtVS.cs ***
namespace Grimoire
{
	/// <summary>
	/// This is the class that implements the package exposed by this assembly.
	/// </summary>
	/// <remarks>
	/// <para>
	/// The minimum requirement for a class to be considered a valid package for Visual Studio
	/// is to implement the IVsPackage interface and register itself with the shell.
	/// This package uses the helper classes defined inside the Managed Package Framework (MPF)
	/// to do it: it derives from the Package class that provides the implementation of the
	/// IVsPackage interface and uses the registration attributes defined in the framework to
	/// register itself and its components with the shell. These attributes tell the pkgdef creation
	/// utility what data to put into .pkgdef file.
	/// </para>
	/// <para>
	/// To get loaded into VS, the package must be referred by &lt;Asset Type="Microsoft.VisualStudio.VsPackage" ...&gt; in .vsixmanifest file.
	/// </para>
	/// </remarks>
	[PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]
	[InstalledProductRegistration("#110", "#112", "1.0", IconResourceID = 400)] // Info on this package for Help/About
	[Guid(NewtVS.PackageGuidString)]
	[SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1650:ElementDocumentationMustBeSpelledCorrectly", Justification = "pkgdef, VS and vsixmanifest are valid VS terms")]
	public sealed class NewtVS : AsyncPackage
	{
		/// <summary>
		/// Cauldron GUID string.
		/// </summary>
		public const string PackageGuidString = "6A832166-AD92-48DC-A74E-1565179013AB";
		/// <summary>
		/// Initializes a new instance of the <see cref="NewtVS"/> class.
		/// </summary>
		public NewtVS()
		{
			// Inside this method you can place any initialization code that does not require
			// any Visual Studio service because at this point the package object is created but
			// not sited yet inside Visual Studio environment. The place to do all the other
			// initialization is the Initialize method.
		}
		#region Package Members
		/// <summary>
		/// Initialization of the package; this method is called right after the package is sited, so this is the place
		/// where you can put all the initialization code that rely on services provided by VisualStudio.
		/// </summary>
		/// <param name="cancellationToken">A cancellation token to monitor for initialization cancellation, which can occur when VS is shutting down.</param>
		/// <param name="progress">A provider for progress updates.</param>
		/// <returns>A task representing the async work of package initialization, or an already completed task if there is none. Do not return null from this method.</returns>
		protected override async Task InitializeAsync(CancellationToken cancellationToken, IProgress<ServiceProgressData> progress)
		{
			// When initialized asynchronously, the current thread may be a background thread at this point.
			// Do any initialization that requires the UI thread after switching to the UI thread.
			await this.JoinableTaskFactory.SwitchToMainThreadAsync(cancellationToken);
        }
		#endregion
	}
}
//*** SourceCombiner -> original file OrderedCollectionEqualityComparer.cs ***
namespace Grimoire
{
#if GRIMOIRELIB
	public
#else
	internal
#endif
	class OrderedCollectionEqualityComparer<T> : IEqualityComparer<IList<T>>
	{
		public static readonly OrderedCollectionEqualityComparer<T> Default = new OrderedCollectionEqualityComparer<T>();
		public OrderedCollectionEqualityComparer(IEqualityComparer<T> itemComparer)
		{
			_itemComparer = itemComparer ?? EqualityComparer<T>.Default;
		}
		public OrderedCollectionEqualityComparer() : this(EqualityComparer<T>.Default) { }
		IEqualityComparer<T> _itemComparer;
		public bool Equals(IList<T> x, IList<T> y)
		{
			if (ReferenceEquals(x, y)) return true;
			if (ReferenceEquals(null, x)) return false;
			if (ReferenceEquals(null, y)) return false;
			var c = x.Count;
			if (y.Count != c) return false;
			for (int i = 0; i < c; ++i)
				if (!_itemComparer.Equals(x[i], y[i]))
					return false;
			return true;
		}
		public int GetHashCode(IList<T> obj)
		{
			var c = obj.Count;
			var result = 0;
			for (int i = 0; i < c; ++i)
				if (null != obj[i])
					result ^= obj.GetHashCode();
			return result;
		}
		public bool Equals(ICollection<T> x, ICollection<T> y)
		{
			if (ReferenceEquals(x, y)) return true;
			if (ReferenceEquals(null, x)) return false;
			if (ReferenceEquals(null, y)) return false;
			var c = x.Count;
			if (y.Count != c) return false;
			using (var ex = x.GetEnumerator())
			{
				using (var ey = y.GetEnumerator())
				{
					while (true)
					{
						var moved = false;
						if ((moved = ex.MoveNext()) != ey.MoveNext())
							return false;
						if (!moved)
							break;
						if (!_itemComparer.Equals(ex.Current, ey.Current))
							return false;
					}
				}
			}
			return true;
		}
		public int GetHashCode(ICollection<T> obj)
		{
			var result = 0;
			foreach(var item in obj)
				if (null != item)
					result ^=item.GetHashCode();
			return result;
		}
		public bool Equals(IEnumerable<T> x, IEnumerable<T> y)
		{
			if (ReferenceEquals(x, y)) return true;
			if (ReferenceEquals(null, x)) return false;
			if (ReferenceEquals(null, y)) return false;
			using (var ex = x.GetEnumerator())
			{
				using (var ey = y.GetEnumerator())
				{
					while (true)
					{
						var moved = false;
						if ((moved = ex.MoveNext()) != ey.MoveNext())
							return false;
						if (!moved)
							break;
						if (!_itemComparer.Equals(ex.Current, ey.Current))
							return false;
					}
				}
			}
			return true;
		}
		public int GetHashCode(IEnumerable<T> obj)
		{
			var result = 0;
			foreach (var item in obj)
				if (null != item)
					result ^= item.GetHashCode();
			return result;
		}
	}
}
//*** SourceCombiner -> original file ParseContext.cs ***
namespace Grimoire
{
	#region ExpectingException
	/// <summary>
	/// An exception encountered during parsing where the stream contains one thing, but another is expected
	/// </summary>
	[Serializable]

	sealed class ExpectingException : Exception
	{
		/// <summary>
		/// Initialize the exception with the specified message.
		/// </summary>
		/// <param name="message">The message</param>
		public ExpectingException(string message) : base(message) { }
		/// <summary>
		/// The list of expected strings.
		/// </summary>
		public string[] Expecting { get; internal set; }
		/// <summary>
		/// The position when the error was realized.
		/// </summary>
		public long Position { get; internal set; }
		/// <summary>
		/// The line of the error
		/// </summary>
		public int Line { get; internal set; }
		/// <summary>
		/// The column of the error
		/// </summary>
		public int Column { get; internal set; }
	}
	#endregion ExpectingException
	#region ParseContext

	abstract partial class ParseContext : IEnumerator<char>, IDisposable
	{
		public bool TryReadWhiteSpace()
		{
			EnsureStarted();
			if (-1 == Current || !char.IsWhiteSpace((char)Current))
				return false;
			CaptureCurrent();
			while (-1 != Advance() && char.IsWhiteSpace((char)Current))
				CaptureCurrent();
			return true;
		}
		public bool TrySkipWhiteSpace()
		{
			EnsureStarted();
			if (-1 == Current || !char.IsWhiteSpace((char)Current))
				return false;
			while (-1 != Advance() && char.IsWhiteSpace((char)Current)) ;
			return true;
		}
		public bool TryReadUntil(int character, bool readCharacter = true)
		{
			EnsureStarted();
			if (0 > character) character = -1;
			CaptureCurrent();
			if (Current == character)
			{
				return true;
			}
			while (-1 != Advance() && Current != character)
				CaptureCurrent();
			CaptureCurrent();
			if (Current == character)
			{
				if (readCharacter)
					Advance();
				return true;
			}
			return false;
		}
		public bool TrySkipUntil(int character, bool skipCharacter = true)
		{
			EnsureStarted();
			if (0 > character) character = -1;
			if (Current == character)
				return true;
			while (-1 != Advance() && Current != character) ;
			if (Current == character)
			{
				if (skipCharacter)
					Advance();
				return true;
			}
			return false;
		}
		public bool TryReadUntil(int character, int escapeChar, bool readCharacter = true)
		{
			EnsureStarted();
			if (0 > character) character = -1;
			if (-1 == Current) return false;
			if (Current == character)
			{
				if (readCharacter)
				{
					CaptureCurrent();
					Advance();
				}
				return true;
			}
			do
			{
				if (escapeChar == Current)
				{
					CaptureCurrent();
					if (-1 == Advance())
						return false;
					CaptureCurrent();
				}
				else
				{
					if (character == Current)
					{
						if (readCharacter)
						{
							CaptureCurrent();
							Advance();
						}
						return true;
					}
					else
						CaptureCurrent();
				}
			}
			while (-1 != Advance());
			return false;
		}
		public bool TrySkipUntil(int character, int escapeChar, bool skipCharacter = true)
		{
			EnsureStarted();
			if (0 > character) character = -1;
			if (Current == character)
				return true;
			while (-1 != Advance() && Current != character)
			{
				if (character == escapeChar)
					if (-1 == Advance())
						break;
			}
			if (Current == character)
			{
				if (skipCharacter)
					Advance();
				return true;
			}
			return false;
		}
		private static bool _ContainsChar(char[] chars, char ch)
		{
			foreach (char cmp in chars)
				if (cmp == ch)
					return true;
			return false;
		}
		public bool TryReadUntil(bool readCharacter = true, params char[] anyOf)
		{
			EnsureStarted();
			if (null == anyOf)
				anyOf = Array.Empty<char>();
			CaptureCurrent();
			if (-1 != Current && _ContainsChar(anyOf, (char)Current))
			{
				if (readCharacter)
				{
					CaptureCurrent();
					Advance();
				}
				return true;
			}
			while (-1 != Advance() && !_ContainsChar(anyOf, (char)Current))
				CaptureCurrent();
			if (-1 != Current && _ContainsChar(anyOf, (char)Current))
			{
				if (readCharacter)
				{
					CaptureCurrent();
					Advance();
				}
				return true;
			}
			return false;
		}
		public bool TrySkipUntil(bool skipCharacter = true, params char[] anyOf)
		{
			EnsureStarted();
			if (null == anyOf)
				anyOf = Array.Empty<char>();
			if (-1 != Current && _ContainsChar(anyOf, (char)Current))
			{
				if (skipCharacter)
					Advance();
				return true;
			}
			while (-1 != Advance() && !_ContainsChar(anyOf, (char)Current)) ;
			if (-1 != Current && _ContainsChar(anyOf, (char)Current))
			{
				if (skipCharacter)
					Advance();
				return true;
			}
			return false;
		}
		public bool TryReadUntil(string text)
		{
			EnsureStarted();
			if (string.IsNullOrEmpty(text))
				return false;
			while (-1 != Current && TryReadUntil(text[0], false))
			{
				bool found = true;
				for (int i = 1; i < text.Length; ++i)
				{
					if (Advance() != text[i])
					{
						found = false;
						break;
					}
					CaptureCurrent();
				}
				if (found)
				{
					Advance();
					return true;
				}
			}
			return false;
		}
		public bool TrySkipUntil(string text)
		{
			EnsureStarted();
			if (string.IsNullOrEmpty(text))
				return false;
			while (-1 != Current && TrySkipUntil(text[0], false))
			{
				bool found = true;
				for (int i = 1; i < text.Length; ++i)
				{
					if (Advance() != text[i])
					{
						found = false;
						break;
					}
				}
				if (found)
				{
					Advance();
					return true;
				}
			}
			return false;
		}
		public bool TryReadDigits()
		{
			EnsureStarted();
			if (-1 == Current || !char.IsDigit((char)Current))
				return false;
			CaptureCurrent();
			while (-1 != Advance() && char.IsDigit((char)Current))
				CaptureCurrent();
			return true;
		}
		public bool TrySkipDigits()
		{
			EnsureStarted();
			if (-1 == Current || !char.IsDigit((char)Current))
				return false;
			while (-1 != Advance() && char.IsDigit((char)Current)) ;
			return true;
		}
		public bool TryReadJsonString()
		{
			EnsureStarted();
			if ('\"' != Current)
				return false;
			CaptureCurrent();
			while (-1 != Advance() && '\r' != Current && '\n' != Current && Current != '\"')
			{
				CaptureCurrent();
				if ('\\' == Current)
				{
					if (-1 == Advance() || '\r' == Current || '\n' == Current)
						return false;
					CaptureCurrent();
				}
			}
			if (Current == '\"')
			{
				CaptureCurrent();
				Advance(); // move past the string
				return true;
			}
			return false;
		}
		static bool _IsHexChar(char hex)
		{
			return (
				(':' > hex && '/' < hex) ||
				('G' > hex && '@' < hex) ||
				('g' > hex && '`' < hex)
			);
		}
		static byte _FromHexChar(char hex)
		{
			if (':' > hex && '/' < hex)
				return (byte)(hex - '0');
			if ('G' > hex && '@' < hex)
				return (byte)(hex - '7'); // 'A'-10
			if ('g' > hex && '`' < hex)
				return (byte)(hex - 'W'); // 'a'-10
			throw new ArgumentException("The value was not hex.", "hex");
		}
		public bool TrySkipJsonString()
		{
			EnsureStarted();
			if ('\"' != Current)
				return false;
			while (-1 != Advance() && '\r' != Current && '\n' != Current && Current != '\"')
				if ('\\' == Current)
					if (-1 == Advance() || '\r' == Current || '\n' == Current)
						return false;
			if (Current == '\"')
			{
				Advance(); // move past the string
				return true;
			}
			return false;
		}
		public bool TryParseJsonString(out string result)
		{
			result = null;
			var sb = new StringBuilder();
			EnsureStarted();
			if ('\"' != Current)
				return false;
			CaptureCurrent();
			while (-1 != Advance() && '\r' != Current && '\n' != Current && Current != '\"')
			{
				CaptureCurrent();
				if ('\\' == Current)
				{
					if (-1 == Advance() || '\r' == Current || '\n' == Current)
						return false;
					CaptureCurrent();
					switch (Current)
					{
						case 'f':
							sb.Append('\f');
							break;
						case 'r':
							sb.Append('\r');
							break;
						case 'n':
							sb.Append('\n');
							break;
						case 't':
							sb.Append('\t');
							break;
						case '\\':
							sb.Append('\\');
							break;
						case '/':
							sb.Append('/');
							break;
						case '\"':
							sb.Append('\"');
							break;
						case 'b':
							sb.Append('\b');
							break;
						case 'u':
							CaptureCurrent();
							if (-1 == Advance())
								return false;
							int ch = 0;
							if (!_IsHexChar((char)Current))
								return false;
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							CaptureCurrent();
							if (-1 == Advance())
								return false;
							if (!_IsHexChar((char)Current))
								return false;
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							CaptureCurrent();
							if (-1 == Advance())
								return false;
							if (!_IsHexChar((char)Current))
								return false;
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							CaptureCurrent();
							if (-1 == Advance())
								return false;
							if (!_IsHexChar((char)Current))
								return false;
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							sb.Append((char)ch);
							break;
						default:
							return false;
					}
				}
				else
					sb.Append((char)Current);
			}
			if (Current == '\"')
			{
				CaptureCurrent();
				Advance(); // move past the string
				result = sb.ToString();
				return true;
			}
			return false;
		}
		public string ParseJsonString()
		{
			var sb = new StringBuilder();
			EnsureStarted();
			Expecting('\"');
			while (-1 != Advance() && '\r' != Current && '\n' != Current && Current != '\"')
			{
				if ('\\' == Current)
				{
					Advance();
					switch (Current)
					{
						case 'b':
							sb.Append('\b');
							break;
						case 'f':
							sb.Append('\f');
							break;
						case 'n':
							sb.Append('\n');
							break;
						case 'r':
							sb.Append('\r');
							break;
						case 't':
							sb.Append('\t');
							break;
						case '\\':
							sb.Append('\\');
							break;
						case '\"':
							sb.Append('\"');
							break;
						case 'u':
							int ch = 0;
							Advance();
							Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f');
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							Advance();
							Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f');
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							Advance();
							Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f');
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							Advance();
							Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f');
							ch <<= 4;
							ch |= _FromHexChar((char)Current);
							sb.Append((char)ch);
							break;
						default:
							Expecting('b', 'n', 'r', 't', '\\', '/', '\"', 'u');
							break;
					}
				}
				else
					sb.Append((char)Current);
			}
			Expecting('\"');
			Advance();
			return sb.ToString();
		}
		public bool TryReadJsonValue()
		{
			TryReadWhiteSpace();
			if ('t' == Current)
			{
				CaptureCurrent();
				if (Advance() != 'r')
					return false;
				CaptureCurrent();
				if (Advance() != 'u')
					return false;
				CaptureCurrent();
				if (Advance() != 'e')
					return false;
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('f' == Current)
			{
				CaptureCurrent();
				if (Advance() != 'a')
					return false;
				CaptureCurrent();
				if (Advance() != 'l')
					return false;
				CaptureCurrent();
				if (Advance() != 's')
					return false;
				CaptureCurrent();
				if (Advance() != 'e')
					return false;
				CaptureCurrent();
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('n' == Current)
			{
				CaptureCurrent();
				if (Advance() != 'u')
					return false;
				CaptureCurrent();
				if (Advance() != 'l')
					return false;
				CaptureCurrent();
				if (Advance() != 'l')
					return false;
				CaptureCurrent();
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('-' == Current || '.' == Current || char.IsDigit((char)Current))
				return TryReadReal();
			if ('\"' == Current)
				return TryReadJsonString();
			if ('[' == Current)
			{
				CaptureCurrent();
				Advance();
				if (TryReadJsonValue())
				{
					TryReadWhiteSpace();
					while (',' == Current)
					{
						CaptureCurrent();
						Advance();
						if (!TryReadJsonValue()) return false;
						TryReadWhiteSpace();
					}
				}
				TryReadWhiteSpace();
				if (']' != Current)
					return false;
				CaptureCurrent();
				Advance();
				return true;
			}
			if ('{' == Current)
			{
				CaptureCurrent();
				Advance();
				TryReadWhiteSpace();
				if (TryReadJsonString())
				{
					TryReadWhiteSpace();
					if (':' != Current) return false;
					CaptureCurrent();
					Advance();
					if (!TryReadJsonValue())
						return false;
					TryReadWhiteSpace();
					while (',' == Current)
					{
						CaptureCurrent();
						Advance();
						TryReadWhiteSpace();
						if (!TryReadJsonString())
							return false;
						TryReadWhiteSpace();
						if (':' != Current) return false;
						CaptureCurrent();
						Advance();
						if (!TryReadJsonValue())
							return false;
						TryReadWhiteSpace();
					}
				}
				TryReadWhiteSpace();
				if ('}' != Current)
					return false;
				CaptureCurrent();
				Advance();
				return true;
			}
			return false;
		}
		public bool TrySkipJsonValue()
		{
			TrySkipWhiteSpace();
			if ('t' == Current)
			{
				if (Advance() != 'r')
					return false;
				if (Advance() != 'u')
					return false;
				if (Advance() != 'e')
					return false;
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('f' == Current)
			{
				if (Advance() != 'a')
					return false;
				if (Advance() != 'l')
					return false;
				if (Advance() != 's')
					return false;
				if (Advance() != 'e')
					return false;
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('n' == Current)
			{
				if (Advance() != 'u')
					return false;
				if (Advance() != 'l')
					return false;
				if (Advance() != 'l')
					return false;
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('-' == Current || '.' == Current || char.IsDigit((char)Current))
				return TrySkipReal();
			if ('\"' == Current)
				return TrySkipJsonString();
			if ('[' == Current)
			{
				Advance();
				if (TrySkipJsonValue())
				{
					TrySkipWhiteSpace();
					while (',' == Current)
					{
						Advance();
						if (!TrySkipJsonValue()) return false;
						TrySkipWhiteSpace();
					}
				}
				TrySkipWhiteSpace();
				if (']' != Current)
					return false;
				Advance();
				return true;
			}
			if ('{' == Current)
			{
				Advance();
				TrySkipWhiteSpace();
				if (TrySkipJsonString())
				{
					TrySkipWhiteSpace();
					if (':' != Current) return false;
					Advance();
					if (!TrySkipJsonValue())
						return false;
					TrySkipWhiteSpace();
					while (',' == Current)
					{
						Advance();
						TrySkipWhiteSpace();
						if (!TrySkipJsonString())
							return false;
						TrySkipWhiteSpace();
						if (':' != Current) return false;
						Advance();
						if (!TrySkipJsonValue())
							return false;
						TrySkipWhiteSpace();
					}
				}
				TrySkipWhiteSpace();
				if ('}' != Current)
					return false;
				Advance();
				return true;
			}
			return false;
		}
		public bool TryParseJsonValue(out object result)
		{
			result = null;
			TryReadWhiteSpace();
			if ('t' == Current)
			{
				CaptureCurrent();
				if (Advance() != 'r')
					return false;
				CaptureCurrent();
				if (Advance() != 'u')
					return false;
				CaptureCurrent();
				if (Advance() != 'e')
					return false;
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				result = true;
				return true;
			}
			if ('f' == Current)
			{
				CaptureCurrent();
				if (Advance() != 'a')
					return false;
				CaptureCurrent();
				if (Advance() != 'l')
					return false;
				CaptureCurrent();
				if (Advance() != 's')
					return false;
				CaptureCurrent();
				if (Advance() != 'e')
					return false;
				CaptureCurrent();
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				result = false;
				return true;
			}
			if ('n' == Current)
			{
				CaptureCurrent();
				if (Advance() != 'u')
					return false;
				CaptureCurrent();
				if (Advance() != 'l')
					return false;
				CaptureCurrent();
				if (Advance() != 'l')
					return false;
				CaptureCurrent();
				if (-1 != Advance() && char.IsLetterOrDigit((char)Current))
					return false;
				return true;
			}
			if ('-' == Current || '.' == Current || char.IsDigit((char)Current))
			{
				double r;
				if (TryParseReal(out r))
				{
					result = r;
					return true;
				}
				return false;
			}
			if ('\"' == Current)
			{
				string s;
				if (TryParseJsonString(out s))
				{
					result = s;
					return true;
				}
				return false;
			}
			if ('[' == Current)
			{
				CaptureCurrent();
				Advance();
				var l = new List<object>();
				object v;
				if (TryParseJsonValue(out v))
				{
					l.Add(v);
					TryReadWhiteSpace();
					while (',' == Current)
					{
						CaptureCurrent();
						Advance();
						if (!TryParseJsonValue(out v)) return false;
						l.Add(v);
						TryReadWhiteSpace();
					}
				}
				TryReadWhiteSpace();
				if (']' != Current)
					return false;
				CaptureCurrent();
				Advance();
				result = l;
				return true;
			}
			if ('{' == Current)
			{
				CaptureCurrent();
				Advance();
				TryReadWhiteSpace();
				string n;
				object v;
				var d = new Dictionary<string, object>();
				if (TryParseJsonString(out n))
				{
					TryReadWhiteSpace();
					if (':' != Current) return false;
					CaptureCurrent();
					Advance();
					if (!TryParseJsonValue(out v))
						return false;
					d.Add(n, v);
					TryReadWhiteSpace();
					while (',' == Current)
					{
						CaptureCurrent();
						Advance();
						TryReadWhiteSpace();
						if (!TryParseJsonString(out n))
							return false;
						TryReadWhiteSpace();
						if (':' != Current) return false;
						CaptureCurrent();
						Advance();
						if (!TryParseJsonValue(out v))
							return false;
						d.Add(n, v);
						TryReadWhiteSpace();
					}
				}
				TryReadWhiteSpace();
				if ('}' != Current)
					return false;
				CaptureCurrent();
				Advance();
				result = d;
				return true;
			}
			return false;
		}
		public object ParseJsonValue()
		{
			TrySkipWhiteSpace();
			if ('t' == Current)
			{
				Advance(); Expecting('r');
				Advance(); Expecting('u');
				Advance(); Expecting('e');
				Advance();
				return true;
			}
			if ('f' == Current)
			{
				Advance(); Expecting('a');
				Advance(); Expecting('l');
				Advance(); Expecting('s');
				Advance(); Expecting('e');
				Advance();
				return true;
			}
			if ('n' == Current)
			{
				Advance(); Expecting('u');
				Advance(); Expecting('l');
				Advance(); Expecting('l');
				Advance();
				return null;
			}
			if ('-' == Current || '.' == Current || char.IsDigit((char)Current))
				return ParseReal();
			if ('\"' == Current)
				return ParseJsonString();
			if ('[' == Current)
			{
				Advance();
				TrySkipWhiteSpace();
				var l = new List<object>();
				if (']' != Current)
				{
					l.Add(ParseJsonValue());
					TrySkipWhiteSpace();
					while (',' == Current)
					{
						Advance();
						l.Add(ParseJsonValue());
						TrySkipWhiteSpace();
					}
				}
				TrySkipWhiteSpace();
				Expecting(']');
				Advance();
				return l;
			}
			if ('{' == Current)
			{
				Advance();
				TrySkipWhiteSpace();
				var d = new Dictionary<string, object>();
				if ('}' != Current)
				{
					string n = ParseJsonString();
					TrySkipWhiteSpace();
					Expecting(':');
					Advance();
					object v = ParseJsonValue();
					d.Add(n, v);
					TrySkipWhiteSpace();
					while (',' == Current)
					{
						Advance();
						TrySkipWhiteSpace();
						n = ParseJsonString();
						TrySkipWhiteSpace();
						Expecting(':');
						Advance();
						v = ParseJsonValue();
						d.Add(n, v);
						TrySkipWhiteSpace();
					}
				}
				TrySkipWhiteSpace();
				if ('}' != Current)
					return false;
				Advance();
				return d;
			}
			return false;
		}
		public bool TryReadInteger()
		{
			EnsureStarted();
			bool neg = false;
			if ('-' == Current)
			{
				neg = true;
				CaptureCurrent();
				Advance();
			}
			else if ('0' == Current)
			{
				CaptureCurrent();
				Advance();
				if (-1 == Current) return true;
				return !char.IsDigit((char)Current);
			}
			if (-1 == Current || (neg && '0' == Current) || !char.IsDigit((char)Current))
				return false;
			if (!TryReadDigits())
				return false;
			return true;
		}
		public bool TrySkipInteger()
		{
			EnsureStarted();
			bool neg = false;
			if ('-' == Current)
			{
				neg = true;
				Advance();
			}
			else if ('0' == Current)
			{
				Advance();
				if (-1 == Current) return true;
				return !char.IsDigit((char)Current);
			}
			if (-1 == Current || (neg && '0' == Current) || !char.IsDigit((char)Current))
				return false;
			if (!TrySkipDigits())
				return false;
			return true;
		}
		// must be object because we don't know the int type. To be lexically valid we must use BigInteger when necessary
		public bool TryParseInteger(out object result)
		{
			result = null;
			EnsureStarted();
			if (-1 == Current) return false;
			bool neg = false;
			if ('-' == Current)
			{
				CaptureCurrent();
				Advance();
				neg = true;
			}
			int l = CaptureBuffer.Length;
			if (TryReadDigits())
			{
				string num = CaptureBuffer.ToString(l, CaptureBuffer.Length - l);
				if (neg)
					num = '-' + num;
				int r;
				if (int.TryParse(num, out r))
				{
					result = r;
					return true;
				}
				long ll;
				if (long.TryParse(num, out ll))
				{
					result = ll;
					return true;
				}
			}
			return false;
		}
		public object ParseInteger()
		{
			EnsureStarted();
			Expecting('-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
			bool neg = ('-' == Current);
			if (neg)
			{
				Advance();
				Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
			}
			long i = 0;
			if (!neg)
			{
				i += ((char)Current) - '0';
				while (-1 != Advance() && char.IsDigit((char)Current))
				{
					i *= 10;
					i += ((char)Current) - '0';
				}
			}
			else
			{
				i -= ((char)Current) - '0';
				while (-1 != Advance() && char.IsDigit((char)Current))
				{
					i *= 10;
					i -= ((char)Current) - '0';
				}
			}
			if (i <= int.MaxValue && i >= int.MinValue)
				return (int)i;
			else if (i <= long.MaxValue && i >= long.MinValue)
				return i;
			return i;
		}
		public bool TryReadReal()
		{
			EnsureStarted();
			bool readAny = false;
			if ('-' == Current)
			{
				CaptureCurrent();
				Advance();
			}
			if (char.IsDigit((char)Current))
			{
				if (!TryReadDigits())
					return false;
				readAny = true;
			}
			if ('.' == Current)
			{
				CaptureCurrent();
				Advance();
				if (!TryReadDigits())
					return false;
				readAny = true;
			}
			if ('E' == Current || 'e' == Current)
			{
				CaptureCurrent();
				Advance();
				if ('-' == Current || '+' == Current)
				{
					CaptureCurrent();
					Advance();
				}
				return TryReadDigits();
			}
			return readAny;
		}
		public bool TrySkipReal()
		{
			bool readAny = false;
			EnsureStarted();
			if ('-' == Current)
				Advance();
			if (char.IsDigit((char)Current))
			{
				if (!TrySkipDigits())
					return false;
				readAny = true;
			}
			if ('.' == Current)
			{
				Advance();
				if (!TrySkipDigits())
					return false;
				readAny = true;
			}
			if ('E' == Current || 'e' == Current)
			{
				Advance();
				if ('-' == Current || '+' == Current)
					Advance();
				return TrySkipDigits();
			}
			return readAny;
		}
		public bool TryParseReal(out double result)
		{
			result = default(double);
			int l = CaptureBuffer.Length;
			if (!TryReadReal())
				return false;
			return double.TryParse(CaptureBuffer.ToString(l, CaptureBuffer.Length - l), out result);
		}
		public double ParseReal()
		{
			EnsureStarted();
			var sb = new StringBuilder();
			Expecting('-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
			bool neg = ('-' == Current);
			if (neg)
			{
				sb.Append((char)Current);
				Advance();
				Expecting('.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
			}
			while (-1 != Current && char.IsDigit((char)Current))
			{
				sb.Append((char)Current);
				Advance();
			}
			if ('.' == Current)
			{
				sb.Append((char)Current);
				Advance();
				Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
				sb.Append((char)Current);
				while (-1 != Advance() && char.IsDigit((char)Current))
				{
					sb.Append((char)Current);
				}
			}
			if ('E' == Current || 'e' == Current)
			{
				sb.Append((char)Current);
				Advance();
				Expecting('+', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
				switch (Current)
				{
					case '+':
					case '-':
						sb.Append((char)Current);
						Advance();
						break;
				}
				Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
				sb.Append((char)Current);
				while (-1 != Advance())
				{
					Expecting('0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
					sb.Append((char)Current);
				}
			}
			return double.Parse(sb.ToString());
		}
		public bool TryReadCLineComment()
		{
			EnsureStarted();
			if ('/' != Current)
				return false;
			CaptureCurrent();
			if ('/' != Advance())
				return false;
			CaptureCurrent();
			while (-1 != Advance() && '\r' != Current && '\n' != Current)
				CaptureCurrent();
			return true;
		}
		public bool TrySkipCLineComment()
		{
			EnsureStarted();
			if ('/' != Current)
				return false;
			if ('/' != Advance())
				return false;
			while (-1 != Advance() && '\r' != Current && '\n' != Current) ;
			return true;
		}
		public bool TryReadCBlockComment()
		{
			EnsureStarted();
			if ('/' != Current)
				return false;
			CaptureCurrent();
			if ('*' != Advance())
				return false;
			CaptureCurrent();
			if (-1 == Advance())
				return false;
			return TryReadUntil("*/");
		}
		public bool TrySkipCBlockComment()
		{
			EnsureStarted();
			if ('/' != Current)
				return false;
			if ('*' != Advance())
				return false;
			if (-1 == Advance())
				return false;
			return TrySkipUntil("*/");
		}
		public bool TryReadCComment()
		{
			EnsureStarted();
			if ('/' != Current)
				return false;
			CaptureCurrent();
			if ('*' == Advance())
			{
				CaptureCurrent();
				if (-1 == Advance())
					return false;
				return TryReadUntil("*/");
			}
			if ('/' == Current)
			{
				CaptureCurrent();
				while (-1 != Advance() && '\r' != Current && '\n' != Current)
					CaptureCurrent();
				return true;
			}
			return false;
		}
		public bool TrySkipCComment()
		{
			EnsureStarted();
			if ('/' != Current)
				return false;
			if ('*' == Advance())
			{
				if (-1 == Advance())
					return false;
				return TrySkipUntil("*/");
			}
			if ('/' == Current)
			{
				while (-1 != Advance() && '\r' != Current && '\n' != Current) ;
				return true;
			}
			return false;
		}
		public bool TryReadCCommentsAndWhitespace()
		{
			bool result = false;
			while (-1 != Current)
			{
				if (!TryReadWhiteSpace() && !TryReadCComment())
					break;
				result = true;
			}
			if (TryReadWhiteSpace())
				result = true;
			return result;
		}
		public bool TrySkipCCommentsAndWhiteSpace()
		{
			bool result = false;
			while (-1 != Current)
			{
				if (!TrySkipWhiteSpace() && !TrySkipCComment())
					break;
				result = true;
			}
			if (TrySkipWhiteSpace())
				result = true;
			return result;
		}
		string _GetExpectingMessageRanges(int[] expecting)
		{
			StringBuilder sb = new StringBuilder();
			sb.Append('[');
			for (var i = 0; i < expecting.Length; i++)
			{
				var first = expecting[i];
				++i;
				var last = expecting[i];
				if (first == last)
				{
					if (-1 == first)
						sb.Append("(end of stream)");
					else
						sb.Append((char)first);
				}
				else
				{
					sb.Append((char)first);
					sb.Append('-');
					sb.Append((char)last);
				}
			}
			sb.Append(']');
			string at = string.Concat(" at line ", Line, ", column ", Column, ", position ", Position);
			if (-1 == Current)
			{
				if (0 == expecting.Length)
					return string.Concat("Unexpected end of input", at, ".");
				return string.Concat("Unexpected end of input. Expecting ", sb.ToString(), at, ".");
			}
			if (0 == expecting.Length)
				return string.Concat("Unexpected character \"", (char)Current, "\" in input", at, ".");
			return string.Concat("Unexpected character \"", (char)Current, "\" in input. Expecting ", sb.ToString(), at, ".");
		}
		string _GetExpectingMessage(int[] expecting)
		{
			StringBuilder sb = null;
			switch (expecting.Length)
			{
				case 0:
					break;
				case 1:
					sb = new StringBuilder();
					if (-1 == expecting[0])
						sb.Append("end of input");
					else
					{
						sb.Append("\"");
						sb.Append((char)expecting[0]);
						sb.Append("\"");
					}
					break;
				case 2:
					sb = new StringBuilder();
					if (-1 == expecting[0])
						sb.Append("end of input");
					else
					{
						sb.Append("\"");
						sb.Append((char)expecting[0]);
						sb.Append("\"");
					}
					sb.Append(" or ");
					if (-1 == expecting[1])
						sb.Append("end of input");
					else
					{
						sb.Append("\"");
						sb.Append((char)expecting[1]);
						sb.Append("\"");
					}
					break;
				default: // length > 2
					sb = new StringBuilder();
					if (-1 == expecting[0])
						sb.Append("end of input");
					else
					{
						sb.Append("\"");
						sb.Append((char)expecting[0]);
						sb.Append("\"");
					}
					int l = expecting.Length - 1;
					int i = 1;
					for (; i < l; ++i)
					{
						sb.Append(", ");
						if (-1 == expecting[i])
							sb.Append("end of input");
						else
						{
							sb.Append("\"");
							sb.Append((char)expecting[i]);
							sb.Append("\"");
						}
					}
					sb.Append(", or ");
					if (-1 == expecting[i])
						sb.Append("end of input");
					else
					{
						sb.Append("\"");
						sb.Append((char)expecting[i]);
						sb.Append("\"");
					}
					break;
			}
			string at = string.Concat(" at line ", Line, ", column ", Column, ", position ", Position);
			if (-1 == Current)
			{
				if (0 == expecting.Length)
					return string.Concat("Unexpected end of input", at, ".");
				return string.Concat("Unexpected end of input. Expecting ", sb.ToString(), at, ".");
			}
			if (0 == expecting.Length)
				return string.Concat("Unexpected character \"", (char)Current, "\" in input", at, ".");
			return string.Concat("Unexpected character \"", (char)Current, "\" in input. Expecting ", sb.ToString(), at, ".");
		}
		[DebuggerHidden()]
		public void Expecting(params int[] expecting)
		{
			ExpectingException ex = null;
			switch (expecting.Length)
			{
				case 0:
					if (-1 == Current)
						ex = new ExpectingException(_GetExpectingMessage(expecting));
					break;
				case 1:
					if (expecting[0] != Current)
						ex = new ExpectingException(_GetExpectingMessage(expecting));
					break;
				default:
					if (0 > Array.IndexOf<int>(expecting, Current))
						ex = new ExpectingException(_GetExpectingMessage(expecting));
					break;
			}
			if (null != ex)
			{
				ex.Position = Position;
				ex.Line = Line;
				ex.Column = Column;
				ex.Expecting = new string[expecting.Length];
				for (int i = 0; i < ex.Expecting.Length; i++)
					ex.Expecting[i] = Convert.ToString(expecting[i]);
				throw ex;
			}
		}
		[DebuggerHidden()]
		public void ThrowExpectingRanges(int[] expecting)
		{
			ExpectingException ex = null;
			ex = new ExpectingException(_GetExpectingMessageRanges(expecting));
			ex.Position = Position;
			ex.Line = Line;
			ex.Column = Column;
			ex.Expecting = null;
			throw ex;
		}
		StringBuilder _captureBuffer;
		/// <summary>
		/// Reports the line the parser is on
		/// </summary>
		/// <remarks>The line starts at one.</remarks>
		public int Line { get; protected set; }
		/// <summary>
		/// Reports the column the parser is on
		/// </summary>
		/// <remarks>The column starts at one.</remarks>
		public int Column { get; protected set; }
		/// <summary>
		/// Reports the position the parser is on
		/// </summary>
		/// <remarks>The position starts at zero.</remarks>
		public long Position { get; protected set; }
		/// <summary>
		/// Reports the current character, or -1 if past end of stream
		/// </summary>
		public int Current { get; protected set; }
		protected ParseContext()
		{
			_captureBuffer = new StringBuilder();
			Position = 0;
			Line = 1;
			Column = 1;
			Current = -2;
		}
		public void EnsureStarted()
		{
			if (-2 == Current)
				Advance();
		}
		public abstract int Advance();
		public abstract void Close();
		void IDisposable.Dispose()
		{
			Close();
		}
		public StringBuilder CaptureBuffer {
			get { return _captureBuffer; }
		}
		public string Capture {
			get { return _captureBuffer.ToString(); }
		}
		char IEnumerator<char>.Current { get { if (0 > Current) throw new InvalidOperationException(); return (char)Current; } }
		object IEnumerator.Current { get { return ((IEnumerator<char>)this).Current; } }
		public string GetCapture(int startIndex, int count)
		{
			return _captureBuffer.ToString(startIndex, count);
		}
		public string GetCapture(int startIndex)
		{
			return _captureBuffer.ToString(startIndex, _captureBuffer.Length - startIndex);
		}
		public void CaptureCurrent()
		{
			if (-1 < Current)
			{
				CaptureBuffer.Append((char)Current);
			}
		}
		public void ClearCapture()
		{
			CaptureBuffer.Clear();
		}
		public static ParseContext Create(IEnumerable<char> input)
		{
			return new CharEnumeratorParseContext(input.GetEnumerator());
		}
		public static ParseContext Create(TextReader input)
		{
			return new TextReaderParseContext(input);
		}
		public static ParseContext CreateFromUrl(string url)
		{
			var wreq = WebRequest.Create(url);
			var wresp = wreq.GetResponse();
			return Create(new StreamReader(wresp.GetResponseStream()));
		}
		public static ParseContext CreateFromFile(string filepath)
		{
			return Create(new StreamReader(filepath));
		}
		bool IEnumerator.MoveNext()
		{
			return -1 < Advance();
		}
		void IEnumerator.Reset()
		{
			throw new NotImplementedException();
		}
		#region CharEnumeratorParseContext
		internal partial class CharEnumeratorParseContext : ParseContext
		{
			IEnumerator<char> _enumerator;
			internal CharEnumeratorParseContext(IEnumerator<char> enumerator)
			{
				_enumerator = enumerator;
			}
			public override int Advance()
			{
				if (-2 == Current)
				{
					if (_enumerator.MoveNext())
					{
						Current = _enumerator.Current;
					}
					else
						Current = -1;
					return Current;
				}
				if (_enumerator.MoveNext())
				{
					Current = _enumerator.Current;
					++Position;
					++Column;
					switch (Current)
					{
						case '\r':
							Column = 1;
							break;
						case '\n':
							Column = 1; ++Line;
							break;
					}
				}
				else
				{
					if (-1 != Current)
					{ // last read moves us past the end. subsequent reads don't move anything
						++Position;
						++Column;
					}
					Current = -1;
				}
				return Current;
			}
			public override void Close()
			{
				if (null != _enumerator)
					_enumerator.Dispose();
				_enumerator = null;
			}
		}
		#endregion CharEnumeratorParseContext
		#region TextReaderParseContext
		internal partial class TextReaderParseContext : ParseContext
		{
			TextReader _reader;
			internal TextReaderParseContext(TextReader reader)
			{
				_reader = reader;
			}
			public override int Advance()
			{
				int och = Current;
				if (-2 == och)
				{
					return Current = _reader.Read();
				}
				if (-1 != (Current = _reader.Read()))
				{
					++Position;
					++Column;
					switch (Current)
					{
						case '\r':
							Column = 1;
							break;
						case '\n':
							Column = 1; ++Line;
							break;
					}
				}
				else
				{
					if (-1 != och) // last read moves us past the end. subsequent reads don't move anything
					{
						++Column;
						++Position;
					}
				}
				return Current;
			}
			public override void Close()
			{
				if (null != _reader)
					_reader.Dispose();
				_reader = null;
			}
		}
		#endregion TextReaderParseContext
	}
	#endregion ParseContext
}
//*** SourceCombiner -> original file ParseNode.cs ***
namespace Grimoire
{

	partial class ParseNode
	{
		WeakReference<ParseNode> _parent;
		int _line;
		int _column;
		long _position;
		public ParseNode Parent {
			get {
				ParseNode result = null;
				if (null != _parent && !_parent.TryGetTarget(out result))
					return null;
				return result;
			}
			set {
				if (null != value)
					_parent = new WeakReference<ParseNode>(value);
				else
					_parent = null;
			}
		}
		public IEnumerable<ParseNode> Select(object symbol, ISymbolResolver resolver)
		{
			if (null == resolver)
				throw new ArgumentNullException("resolver");
			var ic = Children.Count;
			for (var i = 0; i < ic; ++i)
			{
				var child = Children[i];
				if (Equals(symbol, resolver.GetSymbolById(child.SymbolId)))
					yield return child;
			}
		}
		public IEnumerable<ParseNode> Select(int symbolId)
		{
			var ic = Children.Count;
			for (var i = 0; i < ic; ++i)
			{
				var child = Children[i];
				if (symbolId == child.SymbolId)
					yield return child;
			}
		}
		public IList<ParseNode> FillDescendantsAndSelf(IList<ParseNode> result = null)
		{
			if (null == result) result = new List<ParseNode>();
			result.Add(this);
			var ic = Children.Count;
			for (var i = 0; i < ic; ++i)
				Children[i].FillDescendantsAndSelf(result);
			return result;
		}
		internal void SetLineInfo(int line, int column, long position)
		{
			_line = line;
			_column = column;
			_position = position;
		}
		public int Line {
			get {
				if (null == Value)
				{
					if (0 < Children.Count)
						return Children[0].Line;
					return 0;
				}
				else
				{
					return _line;
				}
			}
		}
		public int Column {
			get {
				if (null == Value)
				{
					if (0 < Children.Count)
						return Children[0].Column;
					return 0;
				}
				else
				{
					return _column;
				}
			}
		}
		public long Position {
			get {
				if (null == Value)
				{
					if (0 < Children.Count)
						return Children[0].Position;
					return 0;
				}
				else
				{
					return _position;
				}
			}
		}
		public int Length {
			get {
				if (null == Value)
				{
					if (0 < Children.Count)
					{
						var c = Children.Count - 1;
						var p = Children[c].Position;
						var l = Children[c].Length;
						return (int)(p - Position) + l;
					}
					return 0;
				}
				else
					return Value.Length;
			}
		}
		public int SymbolId { get; set; }
		public string Symbol { get; set; }
		public string Value { get; set; }
		public object ParsedValue { get; set; }
		public IList<ParseNode> Children { get; } = new List<ParseNode>();
		public override string ToString()
		{
			var sb = new StringBuilder();
			_AppendTreeTo(sb,this);
			return sb.ToString();
		}
		static void _AppendTreeTo(StringBuilder result, ParseNode node)
		{
			// adapted from https://stackoverflow.com/questions/1649027/how-do-i-print-out-a-tree-structure
			List<ParseNode> firstStack = new List<ParseNode>();
			firstStack.Add(node);
			List<List<ParseNode>> childListStack = new List<List<ParseNode>>();
			childListStack.Add(firstStack);
			while (childListStack.Count > 0)
			{
				List<ParseNode> childStack = childListStack[childListStack.Count - 1];
				if (childStack.Count == 0)
				{
					childListStack.RemoveAt(childListStack.Count - 1);
				}
				else
				{
					node = childStack[0];
					childStack.RemoveAt(0);
					string indent = "";
					for (int i = 0; i < childListStack.Count - 1; i++)
					{
						indent += (childListStack[i].Count > 0) ? "|  " : "   ";
					}
					var s = node.Symbol;
					result.Append(string.Concat(indent, "+- ", s, " ", node.Value ?? "").TrimEnd());
					result.AppendLine();// string.Concat(" at line ", node.Line, ", column ", node.Column, ", position ", node.Position, ", length of ", node.Length));
					if (node.Children.Count > 0)
					{
						childListStack.Add(new List<ParseNode>(node.Children));
					}
				}
			}
		}
	}
}
//*** SourceCombiner -> original file ParserUtility.cs ***
namespace Grimoire
{
	static class ParserUtility
	{
		public static Type ResolveType(string typeName)
		{
			switch (typeName)
			{
				case "string":
					return typeof(string);
				case "int":
					return typeof(int);
				case "uint":
					return typeof(uint);
				case "short":
					return typeof(short);
				case "ushort":
					return typeof(ushort);
				case "long":
					return typeof(long);
				case "ulong":
					return typeof(ulong);
				case "decimal":
					return typeof(decimal);
				case "float":
					return typeof(float);
				case "double":
					return typeof(double);
				case "char":
					return typeof(char);
				case "byte":
					return typeof(byte);
				case "sbyte":
					return typeof(sbyte);
				case "bool":
					return typeof(bool);
				case "object": // useless but consistent
					return typeof(object);
			}
			var t = Type.GetType(typeName, false, true);
			if (null != t) return t;
			t = Type.GetTypeFromProgID(typeName);
			if (null != t) return t;
			throw new InvalidOperationException("The type \"" + typeName + "\" was not found or could not be loaded.");
		}
		public static object GetParsedValue(Type type, string value)
		{
			if (null != type)
			{
				TypeConverter tc = TypeDescriptor.GetConverter(type);
				if (null != tc && tc.CanConvertFrom(typeof(string)))
					return tc.ConvertFromInvariantString(value);
			}
			return value;
		}
		public static (int Accept, string Value, (int First, int Last)[] ExpectingRanges, int[] ExpectingSymbols) Lex2(
			(int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] dfaTable,
			int errorSymbol,
			ParseContext pc,
			StringBuilder sb = null)
		{
			if (null == sb)
				sb = new StringBuilder();
			else
				sb.Clear();
			pc.EnsureStarted();
			int state = 0;
			var dfaEntry = dfaTable[state];
			var acc = dfaEntry.Accept;
			if (-1 == pc.Current)
			{
				if (0 > acc)
					return DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
				return (dfaEntry.Accept, sb.ToString(), null, null);
			}
			while (true)
			{
				var ns = GetDfatTransition(dfaEntry.Transitions, (char)pc.Current);
				if (-1 == ns)
				{
					if (0 > dfaEntry.Accept)
						return DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
					return (dfaEntry.Accept, sb.ToString(), null, null);
				}
				state = ns;
				dfaEntry = dfaTable[state];
				if (-1 != pc.Current)
					sb.Append((char)pc.Current);
				if (-1 == pc.Advance())
				{
					if (0 > dfaEntry.Accept)
						return DoRecoveryDfat(
							dfaTable,
							dfaEntry,
							errorSymbol,
							pc,
							sb,
							dfaEntry.Transitions);
					return (dfaEntry.Accept, sb.ToString(), null, null);
				}
			}
		}
		public static IEnumerable<char> ExpandRange(KeyValuePair<char, char> range)
		{
			if (range.Value < range.Key)
				for (int i = range.Value; i >= range.Key; --i)
					yield return (char)i;
			else
				for (int i = range.Key; i <= range.Value; ++i)
					yield return (char)i;
		}
		public static IEnumerable<char> ExpandRanges(IEnumerable<KeyValuePair<char, char>> ranges)
		{
			foreach (var range in ranges)
				foreach (char ch in ExpandRange(range))
					yield return ch;
		}
		static (int Accept, string Value, (int First, int Last)[] ExpectingRanges, int[] ExpectingSymbols) DoRecoveryDfat(
			(int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] dfaTable,
			(int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts) dfaEntry,
			int errorSymbol,
			ParseContext pc, StringBuilder sb, ((char First, char Last)[] Ranges, int Destination)[] trns)
		{
			var ranges = new List<(int First, int Last)>();
			for (var i = 0; i < dfaEntry.Transitions.Length; i++)
			{
				var trn = dfaEntry.Transitions[i];
				for (var j = 0; j < trn.Ranges.Length; j++)
				{
					var range = trn.Ranges[j];
					ranges.Add((range.First, range.Last));
				}
			}
			while (true)
			{
				if (-1 == pc.Current)
					break;
				sb.Append((char)pc.Current);
				if (-1 != pc.Advance())
				{
					var dt = GetDfatTransition(dfaTable[0].Transitions, (char)pc.Current);
					if (0 > dt)
						break;
				}
			}
			return (errorSymbol, sb.ToString(), ranges.ToArray(), dfaEntry.PossibleAccepts);
		}
		static int GetDfatTransition(((char First, char Last)[] Ranges, int Destination)[] trns, char ch)
		{
			for (int i = 0; i < trns.Length; ++i)
			{
				var trn = trns[i];
				for (int j = 0; j < trn.Ranges.Length; ++j)
				{
					var rg = trn.Ranges[j];
					if (ch >= rg.First && ch <= rg.Last)
					{
						return trn.Destination;
					}
				}
			}
			return -1; // no state
		}
	}
}
//*** SourceCombiner -> original file Perf.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Perf.AssemblyInfo.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated by the MSBuild WriteCodeFragment class.
//*** SourceCombiner -> original file Program.cs ***
//#define REGEN
namespace Eval
{
	static class Program
	{
		static void Main(string[] args)
		{
#if !REGEN
			Console.WriteLine("Simple Expression Evaluator");
			Console.WriteLine("Hit Enter on a new line to exit.");
			var parser = new ExprParser();
			while (true)
			{
				Console.Write(">");
				var line = Console.ReadLine();
				if (string.IsNullOrEmpty(line)) return;
				var pc = ParseContext.Create(line);
				parser.Restart(pc);
				var ptree = parser.ParseSubtree();
				// parse subtree will not read the whole
				// text, just the subtree so in order to 
				// validate the *entire* input we must read
				// the rest.
				while(parser.Read())
				{
					switch(parser.NodeType)
					{
						case LLNodeType.Error:
							Console.Error.WriteLine("Error: " + parser.Value);
							break;
					}
				}
				// check if there's an error currently.
				switch (parser.NodeType)
				{
					case LLNodeType.Error:
						Console.Error.WriteLine("Error in line after expression");
						break;
				}
				Console.WriteLine(ptree);
				Console.WriteLine();
				try
				{
					Console.WriteLine("Evaluation: {0} = {1}", line, Eval(ptree));
				}
				catch(Exception ex)
				{
					Console.Error.WriteLine("Evaluation error: " + ex.Message);
				}
			}
#endif
		}
#if !REGEN
		static int Eval(ParseNode pn)
		{
			switch (pn.SymbolId)
			{
				case ExprParser.@int:
					// Parsed value relies on the "type" attribute specified in the grammar.
					// see expr.ebnf
					// In this grammar, we specified that it was an int, so the parser
					// has automatically parsed the value into ParsedValue for us.
					// The system uses System.ComponentModel.TypeConverter to work this
					// magic so it's extensible, and should already handle a myriad of .NET
					// types
					return (int)pn.ParsedValue;
				case ExprParser.expr:
				case ExprParser.term:
					// the nice thing about a parser
					// is you already know what the tree
					// has to look like, so it has been
					// pre validated.
					var ic = pn.Children.Count;
					var i = 0;
					var lhs = Eval(pn.Children[i]);
					++i;
					if (i < ic)
					{
						var op = pn.Children[i].Value;
						++i;
						for (; i < ic; ++i)
						{
							var rhs = Eval(pn.Children[i]);
							switch (op)
							{
								case "*":
									lhs *= rhs;
									break;
								case "/":
									lhs /= rhs;
									break;
								case "+":
									lhs += rhs;
									break;
								case "-":
									lhs -= rhs;
									break;
							}
							++i;
						}
					}
					return lhs;
				case ExprParser.factor:
					// it's a nested expression
					// it's possibly surrounded by 
					// parenthesis
					switch(pn.Children.Count)
					{
						case 1: // no parens
							return Eval(pn.Children[0]);
						case 3:
							return Eval(pn.Children[1]);
						default:
							return 0;
					}
				default:
					return 0;
			}	
		}
#endif
	}
}
//*** SourceCombiner -> original file Program.cs ***
namespace HighlighterDemo
{
	static class Program
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void _Main()
		{
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			Application.Run(new Main());
		}
	}
}
//*** SourceCombiner -> original file Program.cs ***
namespace Newt
{
	class Program
	{
		static int _Main(string[] args)
		{
			var mode = 0;
			string infile = null;
			string file2 = null; // sometimes outfile, sometimes input document
			var al = -1;
			var ns = "";
			for (var i = 0; i < args.Length; i++)
			{
				string s = null;
				if (args[i].StartsWith("/"))
				{
					s = args[i].Substring(1);
					if (0 > al)
						al = i;
				}
				else if (args[i].StartsWith("--"))
				{
					s = args[i].Substring(2);
					if (0 > al)
						al = i;
				}
				if (null != s)
				{
					switch (s.ToLowerInvariant())
					{
						case "namespace":
							++i; // steal the next value
							if (i < args.Length)
								ns = args[i];
							break;
						case "parse":
							mode = 1;
							break;
					}
				}
			}
			if (0 > al) al = args.Length;
			switch (al)
			{
				case 0:
					break;
				case 2:
					file2 = args[1];
					goto case 1;
				case 1:
					infile = args[0];
					break;
				default:
					PrintUsage();
					return 1;
			}
			if ("" == infile) infile = null;
			if ("" == file2) file2 = null;
			EbnfDocument doc = null;
			if (mode == 1) // parse 
			{
				return DoParse(infile, file2);
			}
			var msgs = new List<object>();
			using (var sw = (null == file2) ? Console.Out : new StreamWriter(File.OpenWrite(file2)))
			{
				var sww = sw as StreamWriter;
				if (null != sww)
					sww.BaseStream.SetLength(0L);
				using (var sr = (null == infile) ? Console.In : new StreamReader(infile))
				{
					try
					{
						doc = EbnfDocument.ReadFrom(sr);
					}
					catch (ExpectingException ex)
					{
						var em = string.Concat("Error parsing grammar: ", ex.Message);
						msgs.Add(em);
						Console.Error.WriteLine(em);
						WriteHeader(sw, infile, msgs);
						return 2;
					}
				}
				var hasErrors = false;
				foreach (var m in doc.Prepare(false))
				{
					msgs.Add(m);
					Console.Error.WriteLine(m);
					if (EbnfErrorLevel.Error == m.ErrorLevel)
						hasErrors = true;
				}
				if (hasErrors)
				{
					// make sure to dump the messages
					WriteHeader(sw, infile, msgs);
					return 3;
				}
				var name = (file2 != null) ? Path.GetFileNameWithoutExtension(file2) : doc.StartProduction + "Parser";
				var cfg = doc.ToCfg();
				foreach (var m in cfg.PrepareLL1(false))
				{
					msgs.Add(m);
					Console.Error.WriteLine(m);
					if (CfgErrorLevel.Error == m.ErrorLevel)
						hasErrors = true;
				}
				if (hasErrors)
				{
					WriteHeader(sw, infile, msgs);
					return 4;
				}
				Console.Error.WriteLine();
				Console.Error.WriteLine("Final grammar:");
				Console.Error.WriteLine();
				Console.Error.WriteLine(cfg);
				Console.Error.WriteLine();
				Console.Error.WriteLine("{0} Terminals, {1} NonTerminals, {2} Total Symbols", cfg.Terminals.Count, cfg.NonTerminals.Count, cfg.Symbols.Count);
				var lexer = doc.ToLexer(cfg);
				WriteHeader(sw, infile, msgs);
				var hasNS = !string.IsNullOrEmpty(ns);
				if (hasNS)
					sw.WriteLine(string.Concat("namespace ", ns, " {"));
				cfg.WriteCSharpTableDrivenLL1ParserClassTo(sw, name, null, lexer);
				if (hasNS)
					sw.WriteLine("}");
			}
			return 0;
		}
		public static void PrintUsage()
		{
			Console.Error.WriteLine("Usage: newt [<grammarfile> [<outputfile>]] [/namespace <nsname>]");
			Console.Error.WriteLine("Generates code for an LL(1) parser in C# based on an EBNF grammar.");
			Console.Error.WriteLine();
			Console.Error.WriteLine("\t<grammarfile>: The input grammar to create a parser for, or unspecified for <stdin>");
			Console.Error.WriteLine();
			Console.Error.WriteLine("\t<outputfile>: The new C# class file to generate a parser to, or unspecified for <stdout>");
			Console.Error.WriteLine();
			Console.Error.WriteLine("\t<nsname>: The namespace under which to generate the specified class.");
			Console.Error.WriteLine();
			Console.Error.WriteLine("If <outputfile> is specified, the name of the class will be the name of the file withough the path or extension");
			Console.Error.WriteLine("If <outputfile> is not specified, the name of the class will be the name of start symbol with \"Parser\" appended.");
		}
		public static void WriteHeader(TextWriter writer, string infile, IEnumerable<object> msgs)
		{
			if (null != infile)
				writer.WriteLine(string.Concat("#line 1 \"", Path.GetFullPath(infile).Replace("\"", "\"\""), "\""));
			foreach (var m in msgs)
			{
				var em = m as EbnfMessage;
				if (null != em)
				{
					if (EbnfErrorLevel.Warning == em.ErrorLevel)
						writer.Write("#warning ");
					else if (EbnfErrorLevel.Error == em.ErrorLevel)
						writer.Write("#error ");
					else if (EbnfErrorLevel.Message == em.ErrorLevel)
						writer.Write("// Generator ");
					else
						continue;
					writer.WriteLine(em.ToString());
				}
				else
				{
					var cm = m as CfgMessage;
					if (null != cm)
					{
						if (CfgErrorLevel.Warning == cm.ErrorLevel)
							writer.Write("#warning ");
						else if (CfgErrorLevel.Error == cm.ErrorLevel)
							writer.Write("#error ");
						else if (CfgErrorLevel.Message == cm.ErrorLevel)
							writer.Write("// Generator ");
						else
							continue;
						writer.WriteLine(cm.ToString());
					}
					else
						writer.WriteLine(string.Concat("#error ", m));
				}
			}
		}
		static int DoParse(string grammarfile, string inputFile)
		{
			throw new NotImplementedException();
		}
	}
}
//*** SourceCombiner -> original file Program.cs ***
namespace Perf
{
	class Program
	{
		static void _Main(string[] args)
		{
			var file = @"..\..\..\ebnf.ebnf";
			var doc = EbnfDocument.ReadFrom(file);
			doc.Prepare();
			var cfg = doc.ToCfg();
			cfg.PrepareLL1();
			var lexer = doc.ToLexer(cfg);
			string filestring;
			using (var sr = File.OpenText(file))
				filestring = sr.ReadToEnd();
			LLParser parser =cfg.ToLL1Parser(lexer);
			parser.Restart(ParseContext.Create(filestring));
			Console.WriteLine(parser.ParseSubtree());
			var sw = new Stopwatch();
			sw.Restart();
			for (var i = 0; i < 100; ++i)
			{
				parser.Restart(ParseContext.Create(filestring));
				while (parser.Read()) ;
			}
			sw.Stop();
			Console.WriteLine("Runtime Parser: {0}", sw.Elapsed.TotalMilliseconds / 100);
			parser = new EbnfParser();
			sw.Restart();
			for (var i = 0; i < 100; ++i)
			{
				parser.Restart(ParseContext.Create(filestring));
				while (parser.Read()) ;
			}
			sw.Stop();
			Console.WriteLine("Generated Parser: {0}",sw.Elapsed.TotalMilliseconds / 100);
		}
	}
}
//*** SourceCombiner -> original file Resources.Designer.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace HighlighterDemo.Properties {
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        private static global::System.Resources.ResourceManager resourceMan;
        private static global::System.Globalization.CultureInfo resourceCulture;
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("HighlighterDemo.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
//*** SourceCombiner -> original file RtfUtility.cs ***
namespace Grimoire
{
#if GRIMOIRELIB
	public
#else
	internal
#endif
	static partial class RtfUtility
	{
		public static string ToColorTable(params Color[] colors) => ToColorTable((IEnumerable<Color>)colors);
		public static string ToColorTable(IEnumerable<Color> colors)
		{
			var sb = new StringBuilder();
			sb.Append("{\\colortbl");
			foreach(var c in colors)
			{
				sb.Append("\\red");
				sb.Append(c.R);
				sb.Append("\\green");
				sb.Append(c.G);
				sb.Append("\\blue");
				sb.Append(c.B);
				sb.Append(";");
			}
			sb.Append("}");
			return sb.ToString();
		}
		public static string Escape(IEnumerable<char> @string)
		{
			var sb = new StringBuilder();
			foreach(char ch in @string)
			{
				if('{'==ch || '}'==ch || '\\'==ch)
				{
					sb.Append("\\'");
					sb.Append(((int)ch).ToString("x2"));
				}
				else if(ch<128)
				{
					if (char.IsLetterOrDigit(ch) || char.IsPunctuation(ch))
						sb.Append(ch);
					else
					{
						sb.Append("\\'");
						sb.Append(((int)ch).ToString("x2"));
					}
				} else
				{
					sb.Append("\\u");
					sb.Append(((int)ch).ToString("x4"));
					sb.Append("?");
				}
			}
			return sb.ToString();
		}
	}
}
//*** SourceCombiner -> original file Settings.Designer.cs ***
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace HighlighterDemo.Properties {
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.9.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
//*** SourceCombiner -> original file TableDrivenLL1Parser.cs ***
namespace Grimoire
{

	class TableDrivenLL1Parser : LLParser
	{
		int _symbolId = -1;
		int _errorId = -1;
		int _eosId = -1;
		LLNodeType _nodeType = LLNodeType.Initial;
		StringBuilder _lexerBuffer = new StringBuilder();
		public TableDrivenLL1Parser(
				(int Left, int[] Right)[][] parseTable,
				(int SymbolId, bool IsNonTerminal,int NonTerminalCount) startingConfiguration,
				(int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] lexTable,
				string[] symbols,
				int[] substitutionsAndHiddenTerminals,
				string[] blockEnds,
				int[] collapsedNonTerminals,
				Type[] terminalTypes,
				ParseContext context)
		{
			SubstitutionsAndHiddenTerminals = substitutionsAndHiddenTerminals;
			CollapsedNonTerminals = collapsedNonTerminals;
			Symbols = symbols;
			ParseTable = parseTable;
			StartingConfiguration = startingConfiguration;
			LexTable = lexTable;
			BlockEnds = blockEnds;
			TerminalTypes = terminalTypes;
			Restart(context);
		}
		protected int EosId { get { if (-1 == _eosId) _eosId = GetSymbolId("#EOS"); return _eosId; } }
		protected int ErrorId { get { if (-1 == _errorId) _errorId = GetSymbolId("#ERROR"); return _errorId; } }
		protected (int Accept, ((char First, char Last)[] Ranges, int Destination)[] Transitions, int[] PossibleAccepts)[] LexTable { get; }
		protected (int SymbolId, bool IsNonTerminal,int NonTerminalCount) StartingConfiguration { get; }
		protected (int Left, int[] Right)[][] ParseTable { get; }
		protected int[] SubstitutionsAndHiddenTerminals { get; }
		protected string[] BlockEnds { get; }
		protected int[] CollapsedNonTerminals { get; } // we may end up holding other things from attributes here too eventually
		protected Type[] TerminalTypes { get; }
		public override int Line => (LLNodeType.Error == _nodeType) ? ErrorToken.Line : Token.Line;
		public override int Column => (LLNodeType.Error == _nodeType) ? ErrorToken.Column : Token.Column;
		public override long Position => (LLNodeType.Error == _nodeType) ? ErrorToken.Position : Token.Position;
		protected ParseContext ParseContext { get; private set; }
		protected (int SymbolId, string Value, int Line, int Column, long Position, (int First, int Last)[] ExpectingRanges, int[] ExpectingSymbols) Token { get; private set; }
		protected (int SymbolId, string Value, int Line, int Column, long Position, (int First, int Last)[] ExpectingRanges, int[] ExpectingSymbols) ErrorToken { get; private set; }
		protected Stack<int> Stack { get; } = new Stack<int>();
		protected bool IsHidden(int symId)
		{
			if (0 > symId || SubstitutionsAndHiddenTerminals.Length <= symId)
				return false;
			return -2 == SubstitutionsAndHiddenTerminals[symId];
		}
		protected int Substitute(int symId)
		{
			if (0 > symId || SubstitutionsAndHiddenTerminals.Length <= symId)
				return symId;
			var result = SubstitutionsAndHiddenTerminals[symId];
			if (-2 == result) return symId;
			return result;
		}
		protected string GetBlockEnd(int symId)
		{
			if (0 > symId || BlockEnds.Length <= symId) return null;
			return BlockEnds[symId];
		}
		protected bool IsCollapsed(int symId)
		{
			if (0 > symId || CollapsedNonTerminals.Length <= symId) return false;
			return null != CollapsedNonTerminals && -3 == CollapsedNonTerminals[symId];
		}
		protected Type GetType(int symId)
		{
			if (0 > symId || TerminalTypes.Length <= symId) return null;
			return TerminalTypes[symId];
		}
		public string[] Symbols { get; }
		public override string GetSymbolById(int symbolId)
		{
			if (null == Symbols) return null;
			if (0 > symbolId || Symbols.Length <= symbolId)
				return null;
			return Symbols[symbolId];
		}
		public override int GetSymbolId(string symbol)
		{
			if(null!=Symbols)
				for(var i = 0; i <Symbols.Length;i++)
					if (Equals(symbol, Symbols[i]))
						return i;
			return -1;
		}
		protected (int SymbolId, string Value, (int First, int Last)[] ExpectingRanges, int[] ExpectingSymbols) Lex(StringBuilder lexerBuffer = null)
			=> ParserUtility.Lex2(LexTable, ErrorId, ParseContext, lexerBuffer);
		public override bool Read()
		{
			var result = ReadImpl();
			// this is a big part of the "magic" behind clean parse trees
			// all it does is skip "collapsed" nodes in the parse tree
			// meaning any symbol with a "collapse" attribute
			while (result && IsCollapsed(SymbolId))
				result = ReadImpl();
			return result;
		}
		protected bool ReadImpl()
		{
			if (LLNodeType.Error == NodeType && -1 == ParseContext.Current) return false;
			if (NodeType == LLNodeType.Initial)
			{
				var sid = StartingConfiguration.SymbolId;
				Stack.Push(sid);
				if (StartingConfiguration.IsNonTerminal)
					UpdateNodeType(LLNodeType.NonTerminal);
				else
					UpdateNodeType(LLNodeType.Terminal);
				UpdateSymbolId(sid);
				NextToken();
				return true;
			}
			if (0 < Stack.Count)
			{
				var sid = Stack.Peek();
				UpdateSymbolId(sid);
				if (0 > sid) // end non-terminal
				{
					_DoPop();
					return true;
				}
				if (Token.SymbolId == sid) // terminal
				{
					NextToken();
					_DoPop();
					return true;
				}
				(int Left, int[] Rule)[] d = ParseTable[sid];
				if (null!=d)
				{
					var tid = Token.SymbolId - StartingConfiguration.NonTerminalCount;
					(int Left, int[] Right) rule = (-1, null);
					if(-1<tid && tid<d.Length)
						rule = d[tid];
					if (-1!=rule.Left)
					{
						_DoPop();
						sid = ~sid;
						Stack.Push(sid);
						for (int j = rule.Right.Length - 1; j >= 0; --j)
						{
							sid = rule.Right[j];
							Stack.Push(sid);
						}
						UpdateSymbolId(sid);
						if (Token.SymbolId == sid)
							UpdateNodeType(LLNodeType.Terminal);
						else if (0 > sid)
							UpdateNodeType(LLNodeType.EndNonTerminal);
						else
							UpdateNodeType(LLNodeType.NonTerminal);
						return true;
					}
					Panic();
					return true;
				}
				Panic();
				return true;
			}
			if (EosId!= Token.SymbolId)
			{
				Panic();
				return true;
			}
			return false;
		}
		protected void UpdateNodeType(LLNodeType nodeType) { _nodeType = nodeType; }
		protected void UpdateSymbolId(int symbolId) { _symbolId = symbolId; }
		protected void NextToken()
		{
			while (true)
			{
				if (-1 == ParseContext.Current)
				{
					Token = (SymbolId: EosId, Value: null, Line: ParseContext.Line, Column: ParseContext.Column, Position: ParseContext.Position, null, null);
					break;
				}
				else
				{
					long pos = ParseContext.Position;
					int l = ParseContext.Line;
					int c = ParseContext.Column;
					var t = Lex(_lexerBuffer);
					Token = (SymbolId: t.SymbolId, Value: t.Value, Line: l, Column: c, Position: pos, t.ExpectingRanges, t.ExpectingSymbols);
				}
				string blockEnd = GetBlockEnd(Token.SymbolId);
				if (null != blockEnd)
				{
					var l = ParseContext.CaptureBuffer.Length;
					if (!ParseContext.TryReadUntil(blockEnd))
						ParseContext.Expecting();
					Token = (Token.SymbolId, Token.Value + ParseContext.GetCapture(l), Token.Line, Token.Column, Token.Position, Token.ExpectingRanges, Token.ExpectingSymbols);
				}
				if (!IsHidden(Token.SymbolId))
					break;
			}
		}
		public override void Restart(ParseContext parseContext)
		{
			Stack.Clear();
			UpdateNodeType(LLNodeType.Initial);
			if (null != ParseContext)
				ParseContext.Close();
			ParseContext = parseContext;
		}
		public override void Close()
		{
			if (null != ParseContext)
				ParseContext.Close();
			UpdateNodeType(LLNodeType.EndDocument);
		}
		public override int SymbolId {
			get {
				if (LLNodeType.Error == _nodeType)
					return ErrorId;
				return (0 > _symbolId) ? ~_symbolId : _symbolId;
			}
		}
		public override string Value {
			get {
				switch (_nodeType)
				{
					case LLNodeType.Terminal:
						return Token.Value;
					case LLNodeType.Error:
						return ErrorToken.Value;
				}
				return null;
			}
		}
		public override object ParsedValue {
			get {
				if (LLNodeType.Terminal == NodeType)
				{
					Type t = GetType(Token.SymbolId);
					if (null == t) return Value;
					return ParserUtility.GetParsedValue(t, Value);
				}
				return Value;
			}
		}
		public override LLNodeType NodeType => _nodeType;
		protected bool Panic()
		{
			UpdateNodeType(LLNodeType.Error);
			var l = ParseContext.Line;
			var c = ParseContext.Column;
			var pos = ParseContext.Position;
			ErrorToken = (ErrorId, "", l, c, pos, ErrorToken.ExpectingRanges, ErrorToken.ExpectingSymbols);
			var sb = new StringBuilder();
			bool first = true;
			while (first || (!Stack.Contains(Token.SymbolId) && -1 != ParseContext.Current))
			{
				first = false;
				ErrorToken = (ErrorId, string.Concat(ErrorToken.Value, Token.Value), l, c, pos, Token.ExpectingRanges, Token.ExpectingSymbols);
				if (-1 == ParseContext.Current)
				{
					Token = (SymbolId: EosId, Value: "", Line: ParseContext.Line, Column: ParseContext.Column, Position: ParseContext.Position, null, null);
				}
				else
				{
					var t = Lex(_lexerBuffer);
					Token = (SymbolId: t.SymbolId, Value: t.Value, Line: l, Column: c, Position: pos, t.ExpectingRanges, t.ExpectingSymbols);
				}
			}
			while (Stack.Contains(Token.SymbolId) && Stack.Peek() != Token.SymbolId)
				Stack.Pop();
			if (0 < Stack.Count && Stack.Peek() == Token.SymbolId)
			{
				if (IsHidden(Token.SymbolId))
					NextToken();
				return true;
			}
			if (IsHidden(Token.SymbolId))
				NextToken();
			return false;
		}
		void _DoPop()
		{
			Stack.Pop();
			if (0 < Stack.Count)
			{
				var s = Stack.Peek();
				UpdateSymbolId(s);
				if (Token.SymbolId == s)
					UpdateNodeType(LLNodeType.Terminal);
				else if (0 > s)
					UpdateNodeType(LLNodeType.EndNonTerminal);
				else
					UpdateNodeType(LLNodeType.NonTerminal);
			}
			else
			{
				UpdateSymbolId(-1);
				UpdateNodeType(LLNodeType.EndDocument);
			}
		}
	}
}
